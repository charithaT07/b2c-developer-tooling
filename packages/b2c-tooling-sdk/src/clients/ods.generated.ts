/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve API information.
         * @description Return API version information.
         */
        get: operations["getApiInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/me": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve user information.
         * @description Return information about the user interacting with the API.
         */
        get: operations["getUserInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Retrieve system information
         * @description Returns information about the system, the user is interacting with.
         */
        get: operations["getSystemInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/realms/{realm}/system": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The four-letter ID of the realm. */
                realm: components["parameters"]["realmParam"];
            };
            cookie?: never;
        };
        /**
         * Retrieve system information
         * @description Returns information about the system, the user is interacting with.
         */
        get: operations["getRealmSystemInfo"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/realms/{realm}": {
        parameters: {
            query?: {
                /** @description Additional information, which should be shown in the realm query. Available options are: [configuration,usage, accountdetails]. */
                expand?: ("configuration" | "usage" | "accountdetails")[];
            };
            header?: never;
            path: {
                /** @description The four-letter ID of the realm. */
                realm: components["parameters"]["realmParam"];
            };
            cookie?: never;
        };
        /**
         * Show realm information.
         * @description Return metadata about a realm.
         */
        get: operations["getRealm"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/realms/{realm}/configuration": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The four-letter ID of the realm. */
                realm: components["parameters"]["realmParam"];
            };
            cookie?: never;
        };
        /**
         * Show realm configuration.
         * @description Return the current configuration values of the realm.
         */
        get: operations["getRealmConfiguration"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * Update realm configuration.
         * @description Update the customizable configuration of a realm. Note that the internal time format in weekday schedules is [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Times).
         */
        patch: operations["patchRealmConfiguration"];
        trace?: never;
    };
    "/realms/{realm}/usage": {
        parameters: {
            query?: {
                /** @description Earliest date for which data is in the response. Thirty days in the past by default. Format is <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. */
                from?: components["parameters"]["fromParam"];
                /** @description Latest date for which data is included in the response. Today's date by default. Format is <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. */
                to?: components["parameters"]["toParam"];
                /** @description Field to check whether detailed report is to be retrieved, by default detailed report will not be pulled */
                detailedReport?: components["parameters"]["detailedReportParam"];
                /** @description Granularity of usage to be included in the response. By default, granular usage is not returned. */
                granularity?: components["parameters"]["granularityParam"];
            };
            header?: never;
            path: {
                /** @description The four-letter ID of the realm. */
                realm: components["parameters"]["realmParam"];
            };
            cookie?: never;
        };
        /**
         * Show usage information for realm.
         * @description Return information about the realm's usage.
         */
        get: operations["getRealmUsage"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/realms/usages": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Show usage information for given realms.
         * @description Update the customizable configuration of a realm. Note that the internal time format in weekday schedules is [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Times).
         */
        post: operations["searchRealmUsage"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * List sandboxes.
         * @description Return all sandboxes of a realm.
         */
        get: operations["getSandboxes"];
        put?: never;
        /**
         * Create sandbox.
         * @description Create a new sandbox within the realm.
         */
        post: operations["createSandbox"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
            };
            cookie?: never;
        };
        /**
         * Retrieve sandbox information.
         * @description Return details on a specific sandbox in a realm.
         */
        get: operations["getSandbox"];
        put?: never;
        post?: never;
        /**
         * Delete sandbox.
         * @description Delete a specific sandbox in a realm.
         */
        delete: operations["deleteSandbox"];
        options?: never;
        head?: never;
        /**
         * Update sandbox.
         * @description Update a sandbox.
         */
        patch: operations["patchSandbox"];
        trace?: never;
    };
    "/sandboxes/{sandboxId}/aliases": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
            };
            cookie?: never;
        };
        /**
         * Read all sandbox aliases
         * @description Retrieve a list of all past and present operations on a sandbox within the realm.
         */
        get: operations["getAliases"];
        put?: never;
        /**
         * Create sandbox alias.
         * @description Create a new sandbox alias.
         */
        post: operations["createAlias"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxId}/aliases/{sandboxAliasId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
                /** @description The sandbox alias UUID. */
                sandboxAliasId: components["parameters"]["sandboxAliasIdParam"];
            };
            cookie?: never;
        };
        /**
         * Read Alias configuration
         * @description Retrieves a dedicated alias for the sandbox. Can be called without authentication to get cookie values for the alias.
         */
        get: operations["getAlias"];
        put?: never;
        post?: never;
        /**
         * Delete Alias configuration
         * @description Deletes a dedicated alias configuration for a sandbox.
         */
        delete: operations["deleteAlias"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxId}/operations": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
            };
            cookie?: never;
        };
        /**
         * List sandbox operations.
         * @description Retrieve a list of all past and present operations on a sandbox within the realm.
         */
        get: operations["getSandboxOperations"];
        put?: never;
        /**
         * Run sandbox operation.
         * @description Request an operation on a sandbox within the realm.
         */
        post: operations["createSandboxOperation"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxId}/operations/{operationId}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
                /** @description The operation UUID. */
                operationId: components["parameters"]["operationIdParam"];
            };
            cookie?: never;
        };
        /**
         * Retrieve sandbox operation.
         * @description Return details of a sandbox operation that was recently submitted, is currently in progress, or has already finished.
         */
        get: operations["getSandboxOperation"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxId}/settings": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
            };
            cookie?: never;
        };
        /**
         * Show sandbox settings.
         * @description Return all settings of the sandbox.
         */
        get: operations["getSandboxSettings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxId}/usage": {
        parameters: {
            query?: {
                /** @description Earliest date for which data is in the response. Thirty days in the past by default. Format is <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. */
                from?: components["parameters"]["fromParam"];
                /** @description Latest date for which data is included in the response. Today's date by default. Format is <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. */
                to?: components["parameters"]["toParam"];
            };
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
            };
            cookie?: never;
        };
        /**
         * Show sandbox usage.
         * @description Return information on sandbox usage.
         */
        get: operations["getSandboxUsage"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxId}/storage": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
            };
            cookie?: never;
        };
        /**
         * Show sandbox storage
         * @description Return information on sandbox storage capacity for a currently running sandbox.
         */
        get: operations["getSandboxStorage"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        Response: {
            /**
             * @description Type of response object.
             * @enum {string}
             */
            kind: "ApiVersion" | "UserInfo" | "SystemInfo" | "Realm" | "RealmConfiguration" | "RealmUsage" | "MultiRealmUsage" | "Sandbox" | "SandboxList" | "SandboxAlias" | "SandboxAliasList" | "SandboxSettings" | "SandboxUsage" | "SandboxStorage" | "SandboxOperationList" | "Status";
            /**
             * Format: int32
             * @description Response code sent along with the status.
             */
            code: number;
        };
        StatusResponse: components["schemas"]["Response"] & {
            /**
             * @description String with value 'Success' or 'Failure' to indicate request outcome.
             * @enum {string}
             */
            status: "Success" | "Failure";
        };
        PagedResponse: components["schemas"]["StatusResponse"] & {
            metadata?: components["schemas"]["PagingMetadata"];
        };
        PagingMetadata: {
            /**
             * Format: int32
             * @description Index of the current page.
             */
            page?: number;
            /**
             * Format: int32
             * @description Maximum count of elements per page.
             */
            perPage?: number;
            /**
             * Format: int32
             * @description Total count of pages.
             */
            pageCount?: number;
            /**
             * Format: int64
             * @description Total count of elements.
             */
            totalCount?: number;
            links?: components["schemas"]["PagingLinks"];
        };
        PagingLinks: {
            /** @description Relative link to this page. */
            self?: string;
            /** @description Relative link to the first page. */
            first?: string;
            /** @description Relative link to the previous page. 'null' if the current page is the first page. */
            previous?: string;
            /** @description Relative link to the next page. 'null' if the current page is the last page. */
            next?: string;
            /** @description Relative link to the last page. */
            last?: string;
        };
        RealmResponse: components["schemas"]["StatusResponse"] & {
            data?: components["schemas"]["RealmModel"];
        };
        RealmModel: {
            /** @description GUID of the realm in the system. */
            id: string;
            /** @description Human-readable four-letter ID of the realm. */
            name?: string;
            /** @description Flag indicating whether the realm is enabled for any operations. */
            enabled?: boolean;
            usage?: components["schemas"]["RealmUsageSummaryModel"];
            configuration?: components["schemas"]["RealmConfigurationModel"];
            accountdetails?: components["schemas"]["AccountDetailsModel"];
        };
        RealmUsageSummaryModel: {
            /**
             * Format: int64
             * @description Number of currently active sandboxes for a realm.
             * @example 42
             */
            activeSandboxes: number;
        };
        RealmConfigurationResponse: components["schemas"]["StatusResponse"] & {
            data?: components["schemas"]["RealmConfigurationModel"];
        };
        /** @description Object that holds an integer-based configuration property. A zero value means "unlimited". */
        ConfigurationIntegerValue: {
            /**
             * Format: int32
             * @description Fixed value for this configuration property. You can't use this along with a maximum or default value.
             */
            fixedValue?: number;
            /**
             * Format: int32
             * @description Maximum value for this property.
             */
            maximum?: number;
            /**
             * Format: int32
             * @description Default value for this property.
             */
            defaultValue?: number;
        };
        /** @description A schedule definition for a dedicated time on specific weekdays. */
        WeekdaySchedule: {
            /** @description List of weekdays, where the action should take place */
            weekdays?: ("MONDAY" | "TUESDAY" | "WEDNESDAY" | "THURSDAY" | "FRIDAY" | "SATURDAY" | "SUNDAY")[];
            /**
             * @description Time (with timezone) where the action should take place on the specified weekdays. Time format is [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Times). If no time zone is given, the timezone defaults to GMT.
             * @example 20:10:00Z
             */
            time?: string;
        };
        /**
         * @description Configuration object related to sandboxes of a realm.
         * @example {
         *       "limitsEnabled": true,
         *       "totalNumberOfSandboxes": 50,
         *       "sandboxTTL": {
         *         "maximum": 240,
         *         "defaultValue": 8
         *       },
         *       "localUsersAllowed": false
         *     }
         */
        RealmSandboxConfigurationModel: {
            /** @description Flag indicating whether sandbox specific limits are enforced for the realm. */
            limitsEnabled: boolean;
            /** @description Total number of sandboxes (regardless of state) that the realm can hold. */
            totalNumberOfSandboxes: number;
            sandboxTTL: components["schemas"]["ConfigurationIntegerValue"];
            /** @description Flag indicating whether users outside the Account Manager are allowed. */
            localUsersAllowed: boolean;
        };
        /**
         * @description Update data for configuration data related to sandboxes of a realm. The time formats within the weekday schedules have to be passed in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Times) format.
         * @example {
         *       "sandboxTTL": {
         *         "maximum": 240,
         *         "defaultValue": 24
         *       },
         *       "startScheduler": {
         *         "weekdays": [
         *           "MONDAY",
         *           "TUESDAY",
         *           "WEDNESDAY",
         *           "THURSDAY",
         *           "FRIDAY"
         *         ],
         *         "time": "08:00:00+03:00"
         *       },
         *       "stopScheduler": {
         *         "weekdays": [
         *           "MONDAY",
         *           "TUESDAY",
         *           "WEDNESDAY",
         *           "THURSDAY",
         *           "FRIDAY"
         *         ],
         *         "time": "19:00:00Z"
         *       }
         *     }
         */
        RealmSandboxConfigurationUpdateModel: {
            sandboxTTL?: components["schemas"]["ConfigurationIntegerValue"];
            startScheduler?: unknown;
            stopScheduler?: unknown;
        } | null;
        /**
         * @description Configuration object related to requests targeting the sandboxes of a realm.
         * @example {
         *       "enforced": true,
         *       "maxRate": 50000,
         *       "timePeriod": 60
         *     }
         */
        RealmRequestConfigurationModel: {
            /** @description If enabled, rate limiting is active. */
            enforced: boolean;
            /** @description Maximum requests allowed per time period. */
            maxRate?: number;
            /** @description Number of seconds during which to count requests. */
            timePeriod?: number;
        };
        RealmConfigurationModel: {
            /**
             * @example [
             *       "email1@example.com",
             *       "email2@example.com"
             *     ]
             */
            emails?: string[];
            sandbox?: components["schemas"]["RealmSandboxConfigurationModel"];
            requests?: components["schemas"]["RealmRequestConfigurationModel"];
            startScheduler?: components["schemas"]["WeekdaySchedule"];
            stopScheduler?: components["schemas"]["WeekdaySchedule"];
        };
        RealmConfigurationUpdateRequestModel: {
            /**
             * @example [
             *       "email1@example.com",
             *       "email2@example.com"
             *     ]
             */
            emails?: string[];
            sandbox?: components["schemas"]["RealmSandboxConfigurationUpdateModel"];
        };
        RealmUsageResponse: components["schemas"]["StatusResponse"] & {
            data?: components["schemas"]["RealmUsageModel"];
        };
        MultiRealmUsageModel: {
            /** @description GUID of the realm in the system. */
            realmName: string;
            realmUsage?: components["schemas"]["RealmUsageModel"];
            /** @description Error while getting usage. */
            error?: string;
        };
        RealmUsageModel: {
            /** @description GUID of the realm in the system. */
            id: string;
            /** @description account/SFID of the realm in clusterstate table or org62 Tenant table */
            accountId?: string;
            /**
             * Format: int64
             * @description Total number of sandboxes created during the requested timeframe (by default, the previous 30 days).
             * @example 93
             */
            createdSandboxes?: number;
            /**
             * Format: int64
             * @description Total number of sandboxes active during the requested timeframe (by default, the previous 30 days).
             * @example 128
             */
            activeSandboxes?: number;
            /**
             * Format: int64
             * @description Total number of sandboxes deleted during the requested timeframe (by default, the previous 30 days).
             * @example 86
             */
            deletedSandboxes?: number;
            /**
             * Format: int64
             * @description Total number of seconds sandboxes ran during the requested timeframe (by default, the previous 30 days).
             * @example 360000
             */
            sandboxSeconds?: number;
            minutesUpByProfile?: {
                profile?: components["schemas"]["SandboxResourceProfile"];
                /**
                 * Format: int64
                 * @description How many minutes sandboxes of this profile type were running during the report timeframe.
                 */
                minutes?: number;
            }[];
            /**
             * Format: int64
             * @description Sum of minutes sandboxes in this realm were running during the requested timeframe (by default, the previous 30 days).
             * @example 360000
             */
            minutesUp?: number;
            /**
             * Format: int64
             * @description Sum of minutes sandboxes in this realm were not running during the requested timeframe (by default, the previous 30 days).
             * @example 180000
             */
            minutesDown?: number;
            sandboxDetails?: components["schemas"]["SandboxInfo"][];
            granularUsage?: components["schemas"]["GranularUsage"][];
        };
        AccountDetailsModel: {
            /**
             * @description Account name.
             * @example Disney
             */
            accountName?: string;
            /**
             * Format: double
             * @description Total Credit Balance left.
             * @example 93.234
             */
            creditBalance?: number;
        };
        MultiRealmUsageRequest: {
            /**
             * Format: date
             * @description Time the sandbox was started.
             */
            from?: string;
            /**
             * Format: date
             * @description Time the sandbox was stopped. If the sandbox is still running, this value will not exist for the last block.
             */
            to?: string;
            realms?: string[];
            /**
             * @description Field to check whether detailed report is to be retrieved, by default detailed report will not be pulled.
             * @default false
             * @enum {boolean}
             */
            detailedReport: false | true;
        };
        MultiRealmUsageResponse: {
            data?: components["schemas"]["MultiRealmUsageModel"][];
        } & (components["schemas"]["StatusResponse"] & Record<string, never>);
        SandboxListResponse: components["schemas"]["StatusResponse"] & {
            data?: components["schemas"]["SandboxModel"][];
        };
        SandboxResponse: components["schemas"]["StatusResponse"] & {
            data?: components["schemas"]["SandboxModel"];
        };
        /** @description Shows all filesystem storages and how much space is left on them. */
        SandboxStorageModel: {
            [key: string]: components["schemas"]["StorageUsageModel"];
        };
        /** @description Represents a single filesystem storage unit with its available space. */
        StorageUsageModel: {
            /**
             * Format: int64
             * @description Total available space in MB.
             */
            spaceTotal?: number;
            /**
             * Format: int64
             * @description Used space in MB.
             */
            spaceUsed?: number;
            /**
             * Format: int32
             * @description Used space in percent, compared to total space.
             */
            percentageUsed?: number;
        };
        SandboxModel: {
            id?: string;
            realm?: string;
            emails?: string[];
            /** @description Flag indicating whether the sandbox is enabled for any operations. */
            enabled?: boolean;
            instance?: string;
            /**
             * SandboxModelVersions
             * @description Versions of the components that make up the sandbox.
             */
            versions?: {
                /** @description Version of the commerce application. */
                app?: string;
                /** @description Version of the web proxy. */
                web?: string;
            };
            /** @description Defaults to false. If set to true, the sandbox is covered by automatic start/stop actions, which can be set to a dedicated time via realm- configuration API. */
            autoScheduled?: boolean;
            /** @description Defaults to false. If set to true, analytics will be enabled in ODS. */
            analyticsEnabled?: boolean;
            resourceProfile?: components["schemas"]["SandboxResourceProfile"];
            state?: components["schemas"]["SandboxState"];
            /** Format: date-time */
            createdAt?: string;
            createdBy?: string;
            /**
             * Format: date-time
             * @description Time when the delete operation was created.
             */
            deletedAt?: string;
            /** @description User who requested the sandbox deletion. */
            deletedBy?: string;
            /** Format: date-time */
            eol?: string;
            tags?: string[];
            hostName?: string;
            /** @description Set of named links for accessing the sandbox. */
            links?: {
                /** @description Fully qualified URL of the sandbox Business Manager web app. */
                bm?: string;
                /** @description Fully qualified URL of OCAPI data API (excluding version selector). */
                ocapi?: string;
                /** @description Fully qualified WebDAV URL for accessing import and export files. */
                impex?: string;
                /** @description Fully qualified WebDAV URL for accessing code. */
                code?: string;
                /** @description Fully qualified WebDAV URL for accessing log files. */
                logs?: string;
            };
            startScheduler?: components["schemas"]["WeekdaySchedule"];
            stopScheduler?: components["schemas"]["WeekdaySchedule"];
        };
        GranularUsage: {
            /** @description start of the usage being returned */
            usageDate?: string;
            /**
             * Format: double
             * @description Credits consumed when sandboxes were up during the requested timeframe.
             * @example 3600.001
             */
            creditsUp?: number;
            /**
             * Format: double
             * @description Credits consumed when sandboxes were down during the requested timeframe.
             * @example 1440.001
             */
            creditsDown?: number;
            /**
             * Format: int64
             * @description Minutes sandboxes were up during the requested timeframe.
             * @example 360000
             */
            minutesUp?: number;
            /**
             * Format: int64
             * @description Minutes sandboxes were down during the requested timeframe.
             * @example 180000
             */
            minutesDown?: number;
        };
        SandboxInfo: {
            realm?: string;
            resourceProfile?: components["schemas"]["SandboxResourceProfile"];
            /** Format: date-time */
            createdAt?: string;
            /**
             * Format: date-time
             * @description Time when the delete operation was created.
             */
            deletedAt?: string;
            /** @description Name of the sandbox */
            name?: string;
            /** @description instanceId of the sandbox */
            instanceId?: string;
            minutesUpByProfile?: {
                profile?: components["schemas"]["SandboxResourceProfile"];
                /**
                 * Format: int64
                 * @description How many minutes sandboxes of this profile type were running during the report timeframe.
                 */
                minutes?: number;
            }[];
            /**
             * Format: int64
             * @description Minutes sandbox in this realm was running during the requested timeframe (by default, the previous 30 days).
             * @example 360000
             */
            minutesUp?: number;
            /**
             * Format: int64
             * @description Minutes sandbox in this realm was not running during the requested timeframe (by default, the previous 30 days).
             * @example 180000
             */
            minutesDown?: number;
            /** @description Defaults to false. If set to true, the sandbox is covered by automatic start/stop actions, which can be set to a dedicated time via realm- configuration API.: */
            autoScheduled?: boolean;
            startScheduler?: components["schemas"]["WeekdaySchedule"];
            stopScheduler?: components["schemas"]["WeekdaySchedule"];
            /** @description Cluster where sandbox resides. */
            clusterName?: string;
        };
        /** @enum {string} */
        SandboxState: "new" | "creating" | "starting" | "started" | "stopping" | "stopped" | "deleting" | "deleted" | "resetting" | "failed" | "unknown" | "upgrading";
        /**
         * @description Determines the resource allocation for the sandbox, "medium" is the default. Be careful, more powerful profiles consume more credits.
         * @enum {string}
         */
        SandboxResourceProfile: "medium" | "large" | "xlarge" | "xxlarge";
        SandboxOperationRequestModel: {
            /** @enum {string} */
            operation: "start" | "stop" | "restart" | "reset";
        };
        SandboxAliasResponse: components["schemas"]["StatusResponse"] & {
            data?: components["schemas"]["SandboxAliasModel"];
        };
        SandboxAliasListResponse: components["schemas"]["StatusResponse"] & {
            data?: components["schemas"]["SandboxAliasModel"][];
        };
        SandboxAliasModel: {
            /**
             * Format: uuid
             * @description The sandbox alias UUID.
             */
            readonly id?: string;
            /**
             * @description The alias name.
             * @example www.example.com
             */
            name: string;
            /**
             * @description Define if it's a unique configuration
             * @example false
             */
            unique?: boolean;
            /**
             * @description Request a valid certificate to be generated on the fly through Lets Encrypt. This action consumes certificate requests from the domain quota imposed by Let's Encrypt, please read the Alias documentation carefully.
             * @example false
             */
            requestLetsEncryptCertificate?: boolean;
            /**
             * Format: uuid
             * @description The UUID of the sandbox the sandbox alias is pointing to.
             */
            readonly sandboxId?: string;
            /** @description The cookie required for each request to this alias. */
            readonly cookie?: {
                name: string;
                value: string;
                path?: string;
                domain?: string;
            };
            /** @description The link that can be used to save the required cookie for this alias in the browser. */
            readonly registration?: string;
            /** @description The verification code to be added as TXT record in the DNS */
            readonly domainVerificationRecord?: string;
            /**
             * @description The status of the alias creation process
             * @enum {string}
             */
            readonly status?: "pending" | "verified";
        };
        SandboxOperationResponse: components["schemas"]["StatusResponse"] & {
            data?: components["schemas"]["SandboxOperationModel"];
        };
        SandboxOperationListResponse: components["schemas"]["PagedResponse"] & {
            data?: components["schemas"]["SandboxOperationModel"][];
        };
        SandboxSettingsResponse: components["schemas"]["StatusResponse"] & {
            data?: components["schemas"]["SandboxSettings"];
        };
        SandboxStorageResponse: components["schemas"]["StatusResponse"] & {
            data?: components["schemas"]["SandboxStorageModel"];
        };
        SandboxUsageResponse: components["schemas"]["StatusResponse"] & {
            data?: components["schemas"]["SandboxUsageModel"];
        };
        SandboxUsageModel: {
            id: string;
            /**
             * Format: int64
             * @description Total number of seconds during which the sandbox ran.
             */
            sandboxSeconds?: number;
            minutesUpByProfile?: {
                profile?: components["schemas"]["SandboxResourceProfile"];
                /**
                 * Format: int64
                 * @description How many minutes sandboxes of this profile type were running during the report timeframe.
                 */
                minutes?: number;
            }[];
            /**
             * Format: int64
             * @description Sum of minutes sandboxes in this realm were running during the requested timeframe (by default, the previous 30 days).
             * @example 360000
             */
            minutesUp?: number;
            /**
             * Format: int64
             * @description Sum of minutes sandboxes in this realm were not running during the requested timeframe (by default, the previous 30 days).
             * @example 180000
             */
            minutesDown?: number;
            granularUsage?: components["schemas"]["GranularUsage"][];
            /** @description List of blocks, which describe the separate uptimes of a sandbox */
            history?: {
                /**
                 * Format: date-time
                 * @description Time the sandbox was started.
                 */
                from: string;
                /**
                 * Format: date-time
                 * @description Time the sandbox was stopped. If the sandbox is still running, this value will not exist for the last block.
                 */
                to?: string;
                /**
                 * Format: int64
                 * @description Number of seconds that the sandbox was running for this block.
                 */
                sandboxSeconds?: number;
                resourceProfile?: components["schemas"]["SandboxResourceProfile"];
                /** @description This property is set to true if the block exceeds the given timeframe and was therefore trimmed. */
                exceedsTimeframe?: boolean;
                /** @description Cluster where sandbox resides. */
                clusterName?: string;
            }[];
        };
        SandboxOperationModel: {
            id: string;
            /** @enum {string} */
            operation: "start" | "stop" | "restart" | "reset" | "create" | "delete" | "upgrade";
            /** Format: date-time */
            createdAt?: string;
            operationBy?: string;
            /** @enum {string} */
            operationState: "pending" | "running" | "finished";
            sandboxState?: components["schemas"]["SandboxState"];
            /**
             * @description Indicates whether the operation finished successfully ('Success') or not ('Failure').
             * @enum {string}
             */
            status?: "success" | "failure";
        };
        /**
         * @example {
         *       "realm": "<your realm id>",
         *       "emails": [
         *         "email1@example.com",
         *         "email2@example.com"
         *       ],
         *       "ttl": 24,
         *       "autoScheduled": false,
         *       "tags": [
         *         "<your-custom-tag>"
         *       ],
         *       "analyticsEnabled": false,
         *       "startScheduler": {
         *         "weekdays": [
         *           "MONDAY",
         *           "TUESDAY",
         *           "WEDNESDAY",
         *           "THURSDAY",
         *           "FRIDAY"
         *         ],
         *         "time": "08:00:00+03:00"
         *       },
         *       "stopScheduler": {
         *         "weekdays": [
         *           "MONDAY",
         *           "TUESDAY",
         *           "WEDNESDAY",
         *           "THURSDAY",
         *           "FRIDAY"
         *         ],
         *         "time": "19:00:00Z"
         *       },
         *       "resourceProfile": "medium",
         *       "settings": {
         *         "ocapi": [
         *           {
         *             "client_id": "<your client id>",
         *             "resources": [
         *               {
         *                 "resource_id": "/**",
         *                 "methods": [
         *                   "get",
         *                   "post",
         *                   "put",
         *                   "patch",
         *                   "delete"
         *                 ],
         *                 "read_attributes": "(**)",
         *                 "write_attributes": ""
         *               }
         *             ]
         *           }
         *         ],
         *         "webdav": [
         *           {
         *             "client_id": "<your client id>",
         *             "permissions": [
         *               {
         *                 "path": "/cartridges",
         *                 "operations": [
         *                   "read_write"
         *                 ]
         *               },
         *               {
         *                 "path": "/impex",
         *                 "operations": [
         *                   "read_write"
         *                 ]
         *               }
         *             ]
         *           }
         *         ]
         *       }
         *     }
         */
        SandboxProvisioningRequestModel: {
            realm: string;
            emails?: string[];
            /**
             * Format: int32
             * @description Number of hours the sandbox will live (must adhere to the maximum TTL quotas). If set to 0 or less, the sandbox will have an infinite lifetime.
             */
            ttl?: number;
            /** @description Defaults to false. If set to true, the sandbox is covered by automatic start/stop actions, which can be set to a dedicated time via realm- configuration API. */
            autoScheduled?: boolean;
            /**
             * @description Defaults to false. If set to true, analytics will be enabled in ODS.
             * @default false
             */
            analyticsEnabled: boolean;
            tags?: string[];
            startScheduler?: unknown;
            stopScheduler?: unknown;
            resourceProfile?: components["schemas"]["SandboxResourceProfile"];
            settings?: components["schemas"]["SandboxSettings"];
        };
        /**
         * @example {
         *       "emails": [
         *         "email1@example.com",
         *         "email2@example.com"
         *       ],
         *       "ttl": null,
         *       "autoScheduled": false,
         *       "resourceProfile": "desiredProfile",
         *       "tags": [
         *         "<your-custom-tag>"
         *       ],
         *       "startScheduler": {
         *         "weekdays": [
         *           "MONDAY",
         *           "TUESDAY",
         *           "WEDNESDAY",
         *           "THURSDAY",
         *           "FRIDAY"
         *         ],
         *         "time": "08:00:00+03:00"
         *       },
         *       "stopScheduler": {
         *         "weekdays": [
         *           "MONDAY",
         *           "TUESDAY",
         *           "WEDNESDAY",
         *           "THURSDAY",
         *           "FRIDAY"
         *         ],
         *         "time": "19:00:00Z"
         *       }
         *     }
         */
        SandboxUpdateRequestModel: {
            emails?: string[];
            /**
             * Format: int32
             * @description Number of hours added to the sandbox lifetime (must, together with previous extensions, adhere to the maximum TTL configuration). If set to 0 or less, the sandbox will have an infinite lifetime.
             */
            ttl?: number;
            resourceProfile?: components["schemas"]["SandboxResourceProfile"];
            /** @description If set to true, this sandbox will be captured by automated start-/stop -management. */
            autoScheduled?: boolean;
            tags?: string[];
            startScheduler?: unknown;
            stopScheduler?: unknown;
        };
        /** @description Map of additional settings evaluated when the sandbox is provisioned and initialized. */
        SandboxSettings: {
            ocapi?: components["schemas"]["OcapiSettings"];
            webdav?: components["schemas"]["WebDavSettings"];
        };
        /** @description Use this document to configure Open Commerce API permissions for multiple client applications in the context of a single site. */
        OcapiSettings: {
            /**
             * Format: uuid
             * @description Client application ID.
             */
            client_id: string;
            /** @description Array of resource-specific permission documents. */
            resources?: {
                /** @description Open Commerce API HTTP method filter. For example, the filter ["get","patch"] allows access to the GET and PATCH methods for the specified resource path. You can specify methods that are supported for a resource. You can list all available resources and methods for the Shop API, version 18.1, with the following meta data call: http://{your-domain}/dw/meta/rest/shop/v18_1?client_id={your-client-id} */
                methods: ("get" | "delete" | "patch" | "post" | "put")[];
                /** @description String that controls which properties are included in the response document. The configuration value must be specified using property selection syntax. */
                read_attributes?: string;
                /** @description String that controls which properties can be included in the request document. The configuration value must be specified using property selection syntax. */
                write_attributes?: string;
                /** @description OCAPI resource identifier. For example: /products/*\/images or /products/specific_id/images. This property supports Ant path style to describe resource IDs. You can specify wildcards or specific product IDs; you can also specify the pattern /products/** to access to all available sub-resources. You can list all resource identifiers for the Shop API, version 18.1, with the following meta data call: http://{your-domain}/dw/meta/rest/shop/v18_1?client_id={your-client-id} */
                resource_id: string;
                /** @description Version range documents granting permissions only to a subset of OCAPI versions. */
                version_range?: {
                    /** @description From version (for example, 18.1). If you don't specify the from version, all versions including the oldest are accessible. */
                    from?: string;
                    /** @description Until version (for example, 18.1). The until version is exclusive, which means that it is not part of the range. If you don't specify the until version, all versions including the most recent one are accessible. */
                    until?: string;
                }[];
            }[];
        }[];
        /** @description WebDAV settings contain WebDAV client permissions for multiple client applications in the context of your organization. WebDAV client permissions enable you to configure which API clients can access your WebDAV files. These permissions also give you fine-grained control over which directories each client can access. */
        WebDavSettings: {
            /**
             * Format: uuid
             * @description Client ID indicating the API client for which the permissions are configured.
             */
            client_id: string;
            /** @description Array of directory-based permissions documents. Multiple permissions paths cannot intersect each other; for example, the following two paths intersect and are therefore invalid: /impex/src and /impex/src/foo. */
            permissions: {
                /** @description Directory for which the WebDAV permission is granted, including all subdirectories. File-specific permissions are not permitted. */
                path: string;
                /** @description Array of operations granted on this directory. Possible values are read and read_write. */
                operations: ("read" | "read_write")[];
            }[];
        }[];
        ApiVersionResponse: components["schemas"]["StatusResponse"] & {
            data?: components["schemas"]["ApiVersion"];
        };
        ApiVersion: {
            /** @enum {string} */
            version?: "v1";
            git?: {
                commit?: string;
                /** Format: date-time */
                time?: string;
            };
            build?: {
                version?: string;
                /** Format: date-time */
                time?: string;
            };
        };
        UserInfoResponse: components["schemas"]["StatusResponse"] & {
            data?: components["schemas"]["UserInfoSpec"];
        };
        UserInfoSpec: {
            user?: {
                /** @description User's unique ID on Account Manager. */
                id?: string;
                /** @description User's email address. */
                email?: string;
                /** @description User's human-readable, full name. */
                name?: string;
            };
            client?: {
                /** @description OAuth client ID used to retrieve the access token. */
                id?: string;
            };
            /** @description User's roles as returned by Account Manager. */
            roles?: string[];
            /** @description Realms that the user is allowed to access. All sandboxes within these realms are accessible. */
            realms?: string[];
            /** @description Sandboxes that the user is allowed to access. */
            sandboxes?: string[];
        };
        SystemInfoResponse: components["schemas"]["StatusResponse"] & {
            data?: components["schemas"]["SystemInfoSpec"];
        };
        SystemInfoSpec: {
            /** @description The region, the system is deployed on. */
            region?: string;
            /** @description Public IP addresses of internal services like API server */
            systemIps?: string[];
            /** @description Public IP addresses of all sandboxes */
            sandboxIps?: string[];
            /** @description IP addresses for incoming traffic. */
            inboundIps?: string[];
            /** @description IP addresses for outgoing traffic. */
            outboundIps?: string[];
        };
        ErrorResponse: components["schemas"]["StatusResponse"] & {
            error?: components["schemas"]["ErrorModel"];
        };
        ErrorModel: {
            /**
             * @description String with value 'Success' or 'Failure' to indicate request outcome.
             * @enum {string}
             */
            status: "Success" | "Failure";
            /** @description Human-readable description of the error. */
            message?: string;
            /** @description Machine-readable, one-word, CamelCase description of why the operation failed. If this value is empty, there is no information available. The reason clarifies an HTTP status code but does not override it. */
            reason?: string;
            /** @description Extended data associated with the reason. Each reason can define its own extended details. This field is optional, and the data returned is not guaranteed to conform to any schema except that defined by the reason type. */
            details?: {
                [key: string]: string;
            };
        };
    };
    responses: never;
    parameters: {
        /** @description The four-letter ID of the realm. */
        realmParam: string;
        /** @description The sandbox UUID. */
        sandboxIdParam: string;
        /** @description The sandbox alias UUID. */
        sandboxAliasIdParam: string;
        /** @description The operation UUID. */
        operationIdParam: string;
        /** @description The page to access in a paged response. Page numbers start with '0', which is the default value. */
        pageParam: number;
        /** @description Count of elements on a page. The default value is '20'. */
        perPageParam: number;
        /** @description Earliest date for which data is in the response. Thirty days in the past by default. Format is <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. */
        fromParam: string;
        /** @description Latest date for which data is included in the response. Today's date by default. Format is <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. */
        toParam: string;
        /** @description Order of the list. Default value is ''asc''. */
        sortOrderParam: "asc" | "desc";
        /** @description Field by which to order the list. By default, the list is not ordered. */
        sortByOperationParam: "created" | "operation_state" | "status" | "operation";
        /** @description State of operations included in the response. By default, all operations are included. */
        operationStateParam: "pending" | "running" | "finished";
        /** @description Status of operations included in the response. By default, all operations are included. */
        operationStatusParam: "success" | "failure";
        /** @description Type of operations included in the response. By default, all operations are included. */
        operationTypeParam: "start" | "stop" | "restart" | "reset" | "create" | "delete" | "upgrade";
        /** @description Field to check whether detailed report is to be retrieved, by default detailed report will not be pulled */
        detailedReportParam: false | true;
        /** @description Granularity of usage to be included in the response. By default, granular usage is not returned. */
        granularityParam: "daily" | "weekly" | "monthly";
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getApiInfo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description API version information. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ApiVersionResponse"];
                };
            };
        };
    };
    getUserInfo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Metadata about the authenticated API user. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserInfoResponse"];
                };
            };
        };
    };
    getSystemInfo: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Metadata about the system */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SystemInfoResponse"];
                };
            };
        };
    };
    getRealmSystemInfo: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The four-letter ID of the realm. */
                realm: components["parameters"]["realmParam"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Metadata about the system */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SystemInfoResponse"];
                };
            };
        };
    };
    getRealm: {
        parameters: {
            query?: {
                /** @description Additional information, which should be shown in the realm query. Available options are: [configuration,usage, accountdetails]. */
                expand?: ("configuration" | "usage" | "accountdetails")[];
            };
            header?: never;
            path: {
                /** @description The four-letter ID of the realm. */
                realm: components["parameters"]["realmParam"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Realm metadata. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RealmResponse"];
                };
            };
            /** @description The ID is not a valid realm ID. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user isn't authenticated. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to the realm. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any realm with that ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getRealmConfiguration: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The four-letter ID of the realm. */
                realm: components["parameters"]["realmParam"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Current configuration values of the realm. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RealmConfigurationResponse"];
                };
            };
            /** @description The ID isn't valid or the configuration isn't valid. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to that realm. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any realm with that ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    patchRealmConfiguration: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The four-letter ID of the realm. */
                realm: components["parameters"]["realmParam"];
            };
            cookie?: never;
        };
        /** @description Realm values to update. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["RealmConfigurationUpdateRequestModel"];
            };
        };
        responses: {
            /** @description Updated realm configuration data. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RealmConfigurationResponse"];
                };
            };
            /** @description The ID isn't a valid realm ID. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user isn't authenticated. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to that realm. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any realm with that ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getRealmUsage: {
        parameters: {
            query?: {
                /** @description Earliest date for which data is in the response. Thirty days in the past by default. Format is <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. */
                from?: components["parameters"]["fromParam"];
                /** @description Latest date for which data is included in the response. Today's date by default. Format is <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. */
                to?: components["parameters"]["toParam"];
                /** @description Field to check whether detailed report is to be retrieved, by default detailed report will not be pulled */
                detailedReport?: components["parameters"]["detailedReportParam"];
                /** @description Granularity of usage to be included in the response. By default, granular usage is not returned. */
                granularity?: components["parameters"]["granularityParam"];
            };
            header?: never;
            path: {
                /** @description The four-letter ID of the realm. */
                realm: components["parameters"]["realmParam"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Realm's usage information. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["RealmUsageResponse"];
                    "text/csv": components["schemas"]["RealmUsageResponse"];
                };
            };
            /** @description The ID isn't valid. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                    "text/csv": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to the realm. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                    "text/csv": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any realm with that ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                    "text/csv": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    searchRealmUsage: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Return information for given all realm's usage */
        requestBody: {
            content: {
                "application/json": components["schemas"]["MultiRealmUsageRequest"];
            };
        };
        responses: {
            /** @description Aggregates all realm usage data. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["MultiRealmUsageResponse"];
                    "text/csv": components["schemas"]["MultiRealmUsageResponse"];
                };
            };
            /** @description The ID isn't a valid realm ID. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                    "text/csv": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user isn't authenticated. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                    "text/csv": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to that realm. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                    "text/csv": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any realm with that ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                    "text/csv": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getSandboxes: {
        parameters: {
            query?: {
                /** @description If set, return deleted sandboxes. */
                include_deleted?: boolean;
                /** @description If passed in supported format, returns sandboxes that matches the query. Supported format: realm=zzzz&state=active&resourceProfile=medium&createdBy=user1&tags=[tag1,tag2,tag3]. */
                filter_params?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of sandboxes. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SandboxListResponse"];
                };
            };
            /** @description The request parameters are invalid (bad request). */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to that realm. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any realm with that ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    createSandbox: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Metadata about the new sandbox. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SandboxProvisioningRequestModel"];
            };
        };
        responses: {
            /** @description The sandbox creation has started. */
            201: {
                headers: {
                    /** @description URI of the created sandbox. */
                    Location?: string;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SandboxResponse"];
                };
            };
            /** @description The request parameters are invalid (bad request). */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to the realm. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any realm with that ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There were server errors initiating the sandbox deployment. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getSandbox: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Details on the sandbox (including its state). */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SandboxResponse"];
                };
            };
            /** @description The request parameters are invalid (bad request). */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to the requested realm. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any realm with that ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    deleteSandbox: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The request for deleting the sandbox has been accepted by the API server. This doesn't mean that the sandbox has already been deleted, since the actual deletion process does not necessarily start immediately and might take a while. You can track the deletion process using sandbox GET requests. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusResponse"];
                };
            };
            /** @description The request parameters are invalid (bad request). */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to that realm. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description ID not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    patchSandbox: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
            };
            cookie?: never;
        };
        /** @description Sandbox values to update. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SandboxUpdateRequestModel"];
            };
        };
        responses: {
            /** @description Updated details on the sandbox (including its state). */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SandboxResponse"];
                };
            };
            /** @description The request parameters are invalid (bad request). */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to the realm. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any sandbox with that ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getAliases: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of Alias configurations. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SandboxAliasListResponse"];
                };
            };
            /** @description The user doesn't have access to the realm or sandbox. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any sandbox with that ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    createAlias: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
            };
            cookie?: never;
        };
        /** @description The alias for the sandbox */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SandboxAliasModel"];
            };
        };
        responses: {
            /** @description The sandbox alias already exists. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SandboxAliasResponse"];
                };
            };
            /** @description The alias has been created. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SandboxAliasResponse"];
                };
            };
            /** @description The request parameters are invalid (bad request). */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to the sandbox. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any sandbox with that ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getAlias: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
                /** @description The sandbox alias UUID. */
                sandboxAliasId: components["parameters"]["sandboxAliasIdParam"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The Alias configuration. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SandboxAliasResponse"];
                };
            };
            /** @description The user doesn't have access to the realm or sandbox. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any sandbox or any alias with that ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    deleteAlias: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
                /** @description The sandbox alias UUID. */
                sandboxAliasId: components["parameters"]["sandboxAliasIdParam"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Shows, that alias currently gets deleted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StatusResponse"];
                };
            };
            /** @description The user doesn't have access to the realm or sandbox. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any sandbox or any alias with that ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getSandboxOperations: {
        parameters: {
            query?: {
                /** @description Earliest date for which data is in the response. Thirty days in the past by default. Format is <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. */
                from?: components["parameters"]["fromParam"];
                /** @description Latest date for which data is included in the response. Today's date by default. Format is <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. */
                to?: components["parameters"]["toParam"];
                /** @description State of operations included in the response. By default, all operations are included. */
                operation_state?: components["parameters"]["operationStateParam"];
                /** @description Status of operations included in the response. By default, all operations are included. */
                status?: components["parameters"]["operationStatusParam"];
                /** @description Type of operations included in the response. By default, all operations are included. */
                operation?: components["parameters"]["operationTypeParam"];
                /** @description Order of the list. Default value is ''asc''. */
                sort_order?: components["parameters"]["sortOrderParam"];
                /** @description Field by which to order the list. By default, the list is not ordered. */
                sort_by?: components["parameters"]["sortByOperationParam"];
                /** @description The page to access in a paged response. Page numbers start with '0', which is the default value. */
                page?: components["parameters"]["pageParam"];
                /** @description Count of elements on a page. The default value is '20'. */
                per_page?: components["parameters"]["perPageParam"];
            };
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description List of operations. */
            200: {
                headers: {
                    /** @description Paging metadata, as described in <a href="https://tools.ietf.org/html/rfc5988">RFC-5988</a> */
                    Link?: string;
                    /** @description Total count of elements. */
                    "X-Pagination-Count"?: number;
                    /** @description Current page index. */
                    "X-Pagination-Page"?: number;
                    /** @description Maximum count of pages. */
                    "X-Pagination-Limit"?: number;
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SandboxOperationListResponse"];
                };
            };
            /** @description The request parameters are invalid (bad request). */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to the sandbox. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any sandbox with that ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There were server errors during the operation. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    createSandboxOperation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
            };
            cookie?: never;
        };
        /** @description Operation to be carried out on a sandbox. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["SandboxOperationRequestModel"];
            };
        };
        responses: {
            /** @description The operation has been accepted. */
            202: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SandboxOperationResponse"];
                };
            };
            /** @description The request parameters are invalid (bad request). */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to the sandbox. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any sandbox with that ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The operation isn't allowed in the current state of the sandbox. */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There were server errors during the operation. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getSandboxOperation: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
                /** @description The operation UUID. */
                operationId: components["parameters"]["operationIdParam"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Details of the sandbox operation's state and the state of its target.  If the operation has already finished, indicates whether the operation was successful. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SandboxOperationResponse"];
                };
            };
            /** @description The request parameters are invalid (bad request). */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to the requested operation or sandbox. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any sandbox or realm matching the given parameters. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getSandboxSettings: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Details of the sandbox settings. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SandboxSettingsResponse"];
                };
            };
            /** @description The sandbox ID isn't valid. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to the requested sandbox. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any sandbox matching the ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getSandboxUsage: {
        parameters: {
            query?: {
                /** @description Earliest date for which data is in the response. Thirty days in the past by default. Format is <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. */
                from?: components["parameters"]["fromParam"];
                /** @description Latest date for which data is included in the response. Today's date by default. Format is <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a>. */
                to?: components["parameters"]["toParam"];
            };
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Sandbox usage information. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SandboxUsageResponse"];
                };
            };
            /** @description The sandbox ID isn't valid. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to the requested sandbox. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any sandbox matching the ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getSandboxStorage: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The sandbox UUID. */
                sandboxId: components["parameters"]["sandboxIdParam"];
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Sandbox storage information. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["SandboxStorageResponse"];
                };
            };
            /** @description The sandbox ID isn't valid. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description The user doesn't have access to the requested sandbox. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
            /** @description There isn't any sandbox matching the ID. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
}
