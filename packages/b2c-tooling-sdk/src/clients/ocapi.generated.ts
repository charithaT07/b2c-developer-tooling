/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/alerts/descriptors": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a collection of all alert descriptors */
        get: operations["getAlertsDescriptors"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/alerts/descriptors/{application_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a collection of all alert descriptors for the given application context. */
        get: operations["getAlertsDescriptorsByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/alerts/descriptors/{application_id}/{application_context_path}/{message_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a single alert descriptor */
        get: operations["getAlertsDescriptorsByIDByIDByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/alerts/descriptors/{application_id}/{application_context_path}/{message_id}/revalidate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** @description <p> Triggers rule validation for all described descriptors. </p>   <p> When a validation rule for a descriptor is triggered active alerts might be deleted if the conditions are not met anymore.    Additionally, new alerts might be created if conditions of a descriptor are now met. </p>   <p> If the alert descriptor is context-specific, a context object ID needs to be provided in the request body.    The request body can be ued to further restrict the set of descriptors that are validated. </p> */
        patch: operations["patchAlertsDescriptorsByIDByIDByIDRevalidate"];
        trace?: never;
    };
    "/alerts/usersettings": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the alert settings for the user. */
        get: operations["getAlertsUsersettings"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** @description Changes the alert settings for the user. */
        patch: operations["patchAlertsUsersettings"];
        trace?: never;
    };
    "/catalog_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for catalogs. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. These are the list
         *      of searchable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> name - String </li>
         *       <li> description - String </li>
         *       <li> creation_date - DateTime </li>
         *       <li> last_modified - DateTime </li>
         *       </ul>
         *
         *       <p> There are two additional fields that can be used as search filters. They are not attributes in CatalogWO object,
         *      but can be used as filters to query catalogs based on site assignments. </p>
         *       <ul>
         *       <li> is_master_catalog - Boolean </li>
         *       <li> is_storefront_catalog - Boolean </li>
         *       </ul>
         *
         *       <p> On using is_master_catalog in the search query, catalogs without any site assignments are returned.
         *      On using is_storefront_catalog in the search query, catalogs with one or more site assignments are returned. </p>
         *
         *       <p> The output of the query can also be sorted. These are the list of sortable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> name - String </li>
         *       <li> description - String </li>
         *       <li> creation_date - DateTime </li>
         *       </ul>
         */
        post: operations["postCatalogSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/catalogs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the catalogs with no filtering. */
        get: operations["getCatalogs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/catalogs/{catalog_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @description Gets catalog information by catalog Id.
         *
         *      Expansion "stats" can be used to retrieved some expensive statistic data, such as assigned_product_count and owned_product_count.
         *      Example: /s/-/dw/data/v99_9/catalogs/my-catalog?expand=stats
         */
        get: operations["getCatalogsByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** @description Updates the catalog with the specified information. */
        patch: operations["patchCatalogsByID"];
        trace?: never;
    };
    "/catalogs/{catalog_id}/categories": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the categories with no filtering. */
        get: operations["getCatalogsByIDCategories"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/catalogs/{catalog_id}/categories/{category_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @description Action to read an existing category within a catalog. By default, the server
         *      also returns the first level of sub-categories, but you can specify another level by setting the levels
         *      parameter. Please note, using a large value for levels may cause performance
         *      issues in case of a large and deep category tree.
         */
        get: operations["getCatalogsByIDCategoriesByID"];
        /** @description Creates a catalog category using the information provided. */
        put: operations["putCatalogsByIDCategoriesByID"];
        post?: never;
        /** @description Deletes the category by catalog ID and category ID */
        delete: operations["deleteCatalogsByIDCategoriesByID"];
        options?: never;
        head?: never;
        /** @description Updates a catalog category using the information provided. */
        patch: operations["patchCatalogsByIDCategoriesByID"];
        trace?: never;
    };
    "/catalogs/{catalog_id}/categories/{category_id}/category_links": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get a set of outgoing category links in a given catalog category, sorted by position. */
        get: operations["getCatalogsByIDCategoriesByIDCategoryLinks"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/catalogs/{catalog_id}/categories/{category_id}/category_links/{target_catalog_id}/{target_category_id}/{type}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get category link information. */
        get: operations["getCatalogsByIDCategoriesByIDCategoryLinksByIDByIDByID"];
        /**
         * @description Creates a category link using the information provided. If a category link with the same unique identifier,
         *      it will be updated with the new position.
         */
        put: operations["putCatalogsByIDCategoriesByIDCategoryLinksByIDByIDByID"];
        post?: never;
        /** @description Deletes the category link by ID */
        delete: operations["deleteCatalogsByIDCategoriesByIDCategoryLinksByIDByIDByID"];
        options?: never;
        head?: never;
        /** @description Updates the category link with the specified information. */
        patch: operations["patchCatalogsByIDCategoriesByIDCategoryLinksByIDByIDByID"];
        trace?: never;
    };
    "/catalogs/{catalog_id}/categories/{category_id}/category_product_assignment_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for category product assignments. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. This is the list
         *      of searchable attributes: </p>
         *       <ul>
         *       <li> product_id - String </li>
         *       <li> product_name - String </li>
         *       <li> online_flag - Boolean  </li>
         *       <li> searchable - Boolean  </li>
         *       <li> valid_from - DateTime  </li>
         *       <li> valid_to - DateTime  </li>
         *       <li> creation_date - DateTime </li>
         *       </ul>
         *
         *       <p> Sortable Fields: </p>
         *       <ul>
         *       <li> product_id - String </li>
         *       <li> product_name - String </li>
         *       <li> position - Double </li>
         *       <li> creation_date - DateTime </li>
         *       </ul>
         *
         *       <p> Expansions that can be applied for the search request: </p>
         *       <ul>
         *       <li> product_base - String - This expand will enable retrieval of the following basic  <b> Product </b>  information:  </li>
         *       <li> product_images - String - to fetch preview image and image groups specified for the given product </li>
         *       <li> product_all_images - String - to fetch preview image and image groups specified for the product plus images for its variants and variation groups </li>
         *       <li> product_variations - String to fetch variations related information, version 17.8+ </li>
         *       <li> product_availability - String to fetch availability related information, version 17.8+ </li>
         *       <li> product_categories - String to fetch category related information, version 17.8+ </li>
         *       <li> product_prices - String to fetch prices related information, version 17.8+ </li>
         *       <li> product_options - String to fetch options related information, version 17.8+ </li>
         *       <li> <p> product_all - String to fetch all expanded information, version 17.8+ </p>
         *
         *      	 <ul>
         *      		 <li> brand </li>
         *         	 <li> ean </li>
         *            <li> link </li>
         *       	 <li> long_description </li>
         *            <li> manufacturer_name </li>
         *            <li> manufacturer_sku </li>
         *      		 <li> name </li>
         *            <li> page_description </li>
         *            <li> page_keywords </li>
         *            <li> page_title </li>
         *            <li> searchable </li>
         *        	 <li> short_description </li>
         *            <li> type </li>
         *            <li> unit </li>
         *          	 <li> upc </li>
         *      	 </ul> </li>
         *       </ul>
         */
        post: operations["postCatalogsByIDCategoriesByIDCategoryProductAssignmentSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/catalogs/{catalog_id}/categories/{category_id}/products/{product_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @description Retrieves category product assignment information.
         *
         *      Expands that can be applied for the get request
         *       <ul>
         *       <li> product_base - String </li>
         *       <li> product_images - String - to fetch image groups specified for the given product </li>
         *       <li> product_all_images - String - to fetch image groups specified for the given product plus images for its variants and variation groups </li>
         *       </ul>
         */
        get: operations["getCatalogsByIDCategoriesByIDProductsByID"];
        /**
         * @description <p> <b> Creates </b>  a category product assignment using the information provided;  </p>
         *
         *       <p> As the assigned position n is a  <b> normalized target position </b> , we'll make sure that the product is assigned
         *      to a position so that the order of positions are maintained.
         *
         *      For example, product A, B, C at position 1, 2, 3. product D is assigned to
         *      position 2, the end result is A, D, B, C with order of positions 1, 2, 3, 4; </p>
         *
         *       <p> If there are n existing positioned assignment, assigning a new product to position >= n+1 will end
         *      with new assignment with position n+1. </p>
         */
        put: operations["putCatalogsByIDCategoriesByIDProductsByID"];
        post?: never;
        /**
         * @description <b> Removes </b>  a category product assignment;
         *
         *
         *       <p> For example, if we have products A, B, C at positions 1, 2, 7.5 and delete assignment for product B,
         *      this will end up the products A, B, C at positions 1, null, 7.5. </p>
         */
        delete: operations["deleteCatalogsByIDCategoriesByIDProductsByID"];
        options?: never;
        head?: never;
        /**
         * @description <p> <b> Updates </b>  the category product assignment with the specified information, such as position. </p>
         *       <p>  As the assigned position n is a  <b> normalized target position </b> , we'll make sure that the product is assigned
         *      to a position so that the order of positions are maintained.  </p>
         *
         *       <p> For example, if we have products A, B, C, D at positions 1, 2, 3, 4 and update product A with new position 3,
         *      the end result is B, C, A, D with order of positions 1, 2, 3, 4.  </p> <p> If we then update product C to no position,
         *      the end result is B, A, D, C with order of positions 1, 2, 3, null. </p>
         *
         *       <p> If there are n existing positioned assignment, updating product to position >= n will end with new assignment with position such that the order of positions is maintained. </p>
         */
        patch: operations["patchCatalogsByIDCategoriesByIDProductsByID"];
        trace?: never;
    };
    "/catalogs/{catalog_id}/category_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for catalog categories in the scope of catalog </p>
         *       <p> By default, the server also returns the first level of subcategories,
         *       but you can specify another level by setting the levels parameter.
         *       Please note, using a large value for levels may cause performance
         *       issues in case of a large and deep category tree. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. These are the list
         *      of searchable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> name - String </li>
         *       <li> description - String </li>
         *       <li> creation_date - DateTime </li>
         *       <li> online - Boolean </li>
         *       <li> parent_category_id - String </li>
         *       </ul>
         *
         *       <p> The output of the query can also be sorted. These are the list of sortable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> name - String </li>
         *       <li> description - String </li>
         *       <li> creation_date - DateTime </li>
         *       <li> online - Boolean  </li>
         *       <li> position - Double  </li>
         *       </ul>
         */
        post: operations["postCatalogsByIDCategorySearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/catalogs/{catalog_id}/shared_product_options": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Read shared product options in a catalog. */
        get: operations["getCatalogsByIDSharedProductOptions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/catalogs/{catalog_id}/shared_product_options/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Read a shared product option in a catalog. */
        get: operations["getCatalogsByIDSharedProductOptionsByID"];
        /** @description Creates a shared product option using the information provided. */
        put: operations["putCatalogsByIDSharedProductOptionsByID"];
        post?: never;
        /** @description Deletes a shared product option by ID. */
        delete: operations["deleteCatalogsByIDSharedProductOptionsByID"];
        options?: never;
        head?: never;
        /** @description Updates a shared product option with the information provided. */
        patch: operations["patchCatalogsByIDSharedProductOptionsByID"];
        trace?: never;
    };
    "/catalogs/{catalog_id}/shared_product_options/{option_id}/values": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Read shared product option values of a shared product option in a catalog. */
        get: operations["getCatalogsByIDSharedProductOptionsByIDValues"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/catalogs/{catalog_id}/shared_product_options/{option_id}/values/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Read a shared product option value of a shared product option in a catalog. */
        get: operations["getCatalogsByIDSharedProductOptionsByIDValuesByID"];
        /** @description Creates a shared product option value using the information provided. */
        put: operations["putCatalogsByIDSharedProductOptionsByIDValuesByID"];
        post?: never;
        /** @description Deletes a shared product option value by ID. */
        delete: operations["deleteCatalogsByIDSharedProductOptionsByIDValuesByID"];
        options?: never;
        head?: never;
        /** @description Updates a shared product option value with the information provided. */
        patch: operations["patchCatalogsByIDSharedProductOptionsByIDValuesByID"];
        trace?: never;
    };
    "/catalogs/{catalog_id}/shared_variation_attributes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Reads variation attributes of a Domain. */
        get: operations["getCatalogsByIDSharedVariationAttributes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/catalogs/{catalog_id}/shared_variation_attributes/{attribute_id}/values": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Reads variation attribute values of a variation attribute of a catalog. */
        get: operations["getCatalogsByIDSharedVariationAttributesByIDValues"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/catalogs/{catalog_id}/shared_variation_attributes/{attribute_id}/values/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get Shared Variation Attribute value information. */
        get: operations["getCatalogsByIDSharedVariationAttributesByIDValuesByID"];
        /** @description Action to create a Shared Variation Attribute value. */
        put: operations["putCatalogsByIDSharedVariationAttributesByIDValuesByID"];
        post?: never;
        /** @description Deletes the variation attribute value of a variation attribute bound to a catalog */
        delete: operations["deleteCatalogsByIDSharedVariationAttributesByIDValuesByID"];
        options?: never;
        head?: never;
        /** @description Updates the variation attribute value of a variation attribute of a catalog. */
        patch: operations["patchCatalogsByIDSharedVariationAttributesByIDValuesByID"];
        trace?: never;
    };
    "/catalogs/{catalog_id}/shared_variation_attributes/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get shared variation attribute information only for master Catalog. */
        get: operations["getCatalogsByIDSharedVariationAttributesByID"];
        /**
         * @description Creates a shared variation attribute using the information provided.
         *      To create a variation attribute specific to a product, use the products resource.
         */
        put: operations["putCatalogsByIDSharedVariationAttributesByID"];
        post?: never;
        /** @description Deletes the shared variation attribute by ID. */
        delete: operations["deleteCatalogsByIDSharedVariationAttributesByID"];
        options?: never;
        head?: never;
        /**
         * @description Updates the shared variation attribute with the specified information.
         *
         *       <ul>
         *       <li> name </li>
         *       <li> slicing </li>
         *       </ul>
         */
        patch: operations["patchCatalogsByIDSharedVariationAttributesByID"];
        trace?: never;
    };
    "/category_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for catalog categories anywhere they appear. </p>
         *       <p> By default, the server also returns the first level of subcategories,
         *       but you can specify another level by setting the levels parameter.
         *       Please note, using a large value for levels may cause performance
         *       issues in case of a large and deep category tree. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. These are the list
         *      of searchable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> name - String </li>
         *       <li> description - String </li>
         *       <li> creation_date - DateTime </li>
         *       <li> online - Boolean </li>
         *       <li> catalog_id - String </li>
         *       </ul>
         *
         *       <p> The output of the query can also be sorted. These are the list of sortable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> name - String </li>
         *       <li> description - String </li>
         *       <li> creation_date - DateTime </li>
         *       <li> online - Boolean  </li>
         *       <li> position - Double  </li>
         *       </ul>
         */
        post: operations["postCategorySearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/code_versions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Read all existing code versions. */
        get: operations["getCodeVersions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/code_versions/{code_version_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Read a code version. */
        get: operations["getCodeVersionsByID"];
        /** @description Create a new code version. */
        put: operations["putCodeVersionsByID"];
        post?: never;
        /** @description Delete a code version. */
        delete: operations["deleteCodeVersionsByID"];
        options?: never;
        head?: never;
        /**
         * @description Update an existing code version.
         *       <ul>
         *        <li> Only an inactive code version can be updated. </li>
         *        <li> Only the active flag and the id can be changed. The active flag can therefore only set to "true". </li>
         *        <li> To set the active flag to "false" will not work. </li>
         *       </ul>
         */
        patch: operations["patchCodeVersionsByID"];
        trace?: never;
    };
    "/custom_object_definitions/{object_type}/attribute_definition_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches the attribute definitions of the specified custom object type. </p>
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. Attributes are grouped
         *      into different buckets.  These are the list of searchable attributes with their corresponding buckets: </p>
         *
         *       <p> Main: </p>
         *       <ul>
         *          <li> id - String </li>
         *          <li> display_name* - Localized String </li>
         *          <li> description* - Localized String </li>
         *          <li> key - boolean </li>
         *          <li> mandatory - boolean </li>
         *          <li> searchable - boolean </li>
         *          <li> system - boolean </li>
         *          <li> visible - boolean </li>
         *       </ul>
         *       <p> Definition version: </p>
         *       <ul>
         *          <li> localizable - boolean </li>
         *          <li> site_specific - boolean </li>
         *          <li> value_type - one of {string, int, double, text, html, date, image, boolean, money, quantity, datetime, email, password, set_of_string, set_of_int, set_of_double, enum_of_string, enum_of_int, unknown} </li>
         *       </ul>
         *
         *       <p> Only attributes in the same bucket can be joined using a disjunction (OR).
         *      For instance, when joining localizable and description above, only a conjunction is allowed (AND), whereas display_name
         *      and description can be joined using a disjunction because they are in the same bucket.  If an attribute
         *      is used in a disjunction (OR) that violates this rule, an exception will be thrown. </p>
         *
         *       <p>  Additionally, attribute definitions can also be searched by attribute group.
         *       <ul> <li> group - String </li> </ul>
         *       </p>
         *
         *       <p> These attributes are not searchable or sortable for built in system attributes.  They work normally for non
         *      system attributes. </p>
         *
         *       <p> Note that only searchable attributes can be used in sorting. </p>
         */
        post: operations["postCustomObjectDefinitionsByIDAttributeDefinitionSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom_object_definitions/{object_type}/attribute_definitions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the attribute definitions with no filtering. */
        get: operations["getCustomObjectDefinitionsByIDAttributeDefinitions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom_object_definitions/{object_type}/attribute_definitions/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get attribute definition information. */
        get: operations["getCustomObjectDefinitionsByIDAttributeDefinitionsByID"];
        /** @description Creates a attribute definition using the information provided. */
        put: operations["putCustomObjectDefinitionsByIDAttributeDefinitionsByID"];
        post?: never;
        /** @description Deletes the attribute definition by ID */
        delete: operations["deleteCustomObjectDefinitionsByIDAttributeDefinitionsByID"];
        options?: never;
        head?: never;
        /** @description Updates the attribute definition with the specified information. */
        patch: operations["patchCustomObjectDefinitionsByIDAttributeDefinitionsByID"];
        trace?: never;
    };
    "/custom_object_definitions/{object_type}/attribute_group_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for attribute groups. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. These are the list
         *      of searchable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> display_name - Localized  &lt; String &gt; </li>
         *       <li> description - Localized  &lt; String &gt; </li>
         *       <li> position - Double </li>
         *       <li> internal - Boolean </li>
         *       </ul>
         *
         *       <p> The output of the query can also be sorted. These are the list of sortable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> display_name - Localized  &lt; String &gt; </li>
         *       <li> description - Localized  &lt; String &gt; </li>
         *       <li> position - Double </li>
         *       <li> internal - Boolean </li>
         *       </ul>
         */
        post: operations["postCustomObjectDefinitionsByIDAttributeGroupSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom_object_definitions/{object_type}/attribute_groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the attribute groups with no filtering. */
        get: operations["getCustomObjectDefinitionsByIDAttributeGroups"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom_object_definitions/{object_type}/attribute_groups/{group_id}/attribute_definitions/{def_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Assign an attribute definition to an attribute group. */
        put: operations["putCustomObjectDefinitionsByIDAttributeGroupsByIDAttributeDefinitionsByID"];
        post?: never;
        /** @description Un-assign an attribute definition from an attribute group. */
        delete: operations["deleteCustomObjectDefinitionsByIDAttributeGroupsByIDAttributeDefinitionsByID"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/custom_object_definitions/{object_type}/attribute_groups/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get attribute group information. */
        get: operations["getCustomObjectDefinitionsByIDAttributeGroupsByID"];
        /** @description Creates a attribute group using the information provided. */
        put: operations["putCustomObjectDefinitionsByIDAttributeGroupsByID"];
        post?: never;
        /** @description Deletes the attribute group by ID */
        delete: operations["deleteCustomObjectDefinitionsByIDAttributeGroupsByID"];
        options?: never;
        head?: never;
        /** @description Updates the attribute group with the specified information. */
        patch: operations["patchCustomObjectDefinitionsByIDAttributeGroupsByID"];
        trace?: never;
    };
    "/custom_objects/{object_type}/{key}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Reads a global Custom Object with a given object type ID and a value for the key attribute of the object which represents its unique identifier. */
        get: operations["getCustomObjectsByIDByID"];
        /** @description <p>  Creates a global Custom Object from the request body. Note that an existing global Custom Object with the same key is overwritten by this action.  </p>   <p>  Use Custom Properties prefixed with  <code> c_ </code>  to define the Custom Object fields. <br/>  For localizable strings, structure the field to support multiple language values by using a map where each locale, for example: en_US, fr_FR, has its corresponding string value.  </p> */
        put: operations["putCustomObjectsByIDByID"];
        post?: never;
        /** @description Deletes a global Custom Object. If the Custom Object does not exist, this will do nothing. Note that the customization scripts are only called, if the Custom Object does exist. */
        delete: operations["deleteCustomObjectsByIDByID"];
        options?: never;
        head?: never;
        /** @description <p>  Updates a global Custom Object with information from the request body. Note that only provided attributes are updated and that the key attribute is ignored. All other attributes are unchanged.  </p>   <p>  Use Custom Properties prefixed with  <code> c_ </code>  to define the Custom Object fields. <br/>  For localizable strings, structure the field to support multiple language values by using a map where each locale, for example: en_US, fr_FR, has its corresponding string value.  </p> */
        patch: operations["patchCustomObjectsByIDByID"];
        trace?: never;
    };
    "/custom_objects_search/{object_type}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Search resource for custom objects in scope of a specific custom object type. </p>
         *
         *       <p> The custom object search document contains a search object that allows filtering on various attributes. </p>
         *
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. These are the list
         *      of searchable attributes: </p>
         *       <ul>
         *       <li> key_value_string - String </li>
         *       <li> key_value_integer - Integer </li>
         *       <li> creation_date - Date </li>
         *       <li> last_modified - Date </li>
         *       <li> site_id - String </li>
         *       <li> any custom attribute </li>
         *       </ul>
         *
         *       <p> Note that only searchable attributes can be used in sorting. </p>
         */
        post: operations["postCustomObjectsSearchByID"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customer_lists/{customer_list_id}/customer_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description Action to search for customers in a customer list.
         *
         *      The query attribute specifies a complex query that can be used to narrow down the search.
         *      Note that a text_query search only returns exact word matches. For example, the search
         *      term "Jon" returns "Jon Smith", but doesn't return "Jonathan Smith".
         *
         *      The sum of the values of the start and count parameters should not be more than 10000.
         *
         *      These attributes are searchable:
         *
         *       <ul>
         *       <li> customer_no - String </li>
         *       <li> first_name - String </li>
         *       <li> second_name - String </li>
         *       <li> last_name - String </li>
         *       <li> suffix - String </li>
         *       <li> salutation - String </li>
         *       <li> title - String </li>
         *       <li> fax - String </li>
         *       <li> phone_home - String </li>
         *       <li> phone_business - String </li>
         *       <li> phone_mobile - String </li>
         *       <li> email - String </li>
         *       <li> gender - Integer </li>
         *       <li> company_name - String </li>
         *       <li> credentials.login - String </li>
         *       <li> credentials.enabled - boolean </li>
         *       </ul>
         */
        post: operations["postCustomerListsByIDCustomerSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customer_lists/{list_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to read an existing customerlist. */
        get: operations["getCustomerListsByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customer_lists/{list_id}/customers": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description Action to create a new customer. The customer is created using the specified credentials and customer
         *      information.This action verifies the following:
         *       <ul>
         *       <li> Login acceptance criteria and uniqueness </li>
         *       <li> Mandatory customer properties </li>
         *       </ul>
         *      If the action fails to create the customer, it returns a 400 fault with an appropriate message.
         */
        post: operations["postCustomerListsByIDCustomers"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customer_lists/{list_id}/customers/{customer_no}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get customer information. */
        get: operations["getCustomerListsByIDCustomersByID"];
        /**
         * @description Action to create a new customer. The customer is created using the specified customer number, credentials and
         *      customer information.This action verifies the following:
         *       <ul>
         *       <li> Login acceptance criteria and uniqueness </li>
         *       <li> Mandatory customer properties </li>
         *       </ul>
         *      If the action fails to create the customer, it returns a 400 fault with an appropriate message.
         */
        put: operations["putCustomerListsByIDCustomersByID"];
        post?: never;
        /**
         * @description Deletes the customer including all related information like the customer addresses.   <br/>
         *
         *      Returns a status code of 204 on successful completion when deleting the customer. If the customer to be deleted
         *      did not exist, a 204 will still be returned to indicate the resource is no longer present in the system.
         */
        delete: operations["deleteCustomerListsByIDCustomersByID"];
        options?: never;
        head?: never;
        /**
         * @description Updates the customer with the specified information. The customer number is allowed to be updated but will result in a
         *      CustomerNumberAlreadyInUseException if there is already another customer with the same customer number existing.
         */
        patch: operations["patchCustomerListsByIDCustomersByID"];
        trace?: never;
    };
    "/customer_lists/{list_id}/customers/{customer_no}/addresses": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @description Action that returns a pageable list of all customer addresses. The
         *      default page size is 10 customer addresses.
         */
        get: operations["getCustomerListsByIDCustomersByIDAddresses"];
        put?: never;
        /**
         * @description The action creates a new customer address with the given address
         *      information.
         */
        post: operations["postCustomerListsByIDCustomersByIDAddresses"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/customer_lists/{list_id}/customers/{customer_no}/addresses/{address_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action which returns an address of a customer. */
        get: operations["getCustomerListsByIDCustomersByIDAddressesByID"];
        put?: never;
        post?: never;
        /** @description Action which deletes a customer address. */
        delete: operations["deleteCustomerListsByIDCustomersByIDAddressesByID"];
        options?: never;
        head?: never;
        /** @description Action which updates an address of a customer with the given address information. */
        patch: operations["patchCustomerListsByIDCustomersByIDAddressesByID"];
        trace?: never;
    };
    "/global_preferences/preference_groups/{group_id}/{instance_type}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @description For the specified instance, read the custom preferences in the preference group at the global(organization) level.
         *      Specify 'current' to retrieve the preferences for the instance on which this call is being made. The system will recognize its type.
         *
         *       <p> Note: If instance type sandbox is used, the preference values of development instance type will be returned as fallback. </p>
         */
        get: operations["getGlobalPreferencesPreferenceGroupsByIDByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * @description For the specified instance, update one or more custom preferences in the preference group  at the global(organization) level.
         *
         *       <p> Note: If instance type sandbox is used, the preference values of development instance type will be returned as fallback. </p>
         */
        patch: operations["patchGlobalPreferencesPreferenceGroupsByIDByID"];
        trace?: never;
    };
    "/inventory_list_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p>
         *      Searches for inventory lists.
         *       </p>
         *       <p>
         *      The query attribute specifies a complex query that can be used to narrow down the search. This is the list of
         *      searchable attributes:
         *       </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> default_in_stock - boolean </li>
         *       <li> description - String </li>
         *       <li> on_order_inventory_enabled - boolean </li>
         *       <li> status - one of {"normal","delete"} </li>
         *       <li> use_bundle_inventory_only - boolean </li>
         *       </ul>
         */
        post: operations["postInventoryListSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/inventory_lists": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the inventory lists with no filtering. */
        get: operations["getInventoryLists"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/inventory_lists/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get inventory list information. */
        get: operations["getInventoryListsByID"];
        /** @description Creates an inventory list using the information provided. */
        put: operations["putInventoryListsByID"];
        post?: never;
        /** @description Deletes the inventory list by ID */
        delete: operations["deleteInventoryListsByID"];
        options?: never;
        head?: never;
        /** @description Updates the inventory list with the specified information. */
        patch: operations["patchInventoryListsByID"];
        trace?: never;
    };
    "/inventory_lists/{inventory_list_id}/product_inventory_records": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets all product inventory records for an inventory list. */
        get: operations["getInventoryListsByIDProductInventoryRecords"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/inventory_lists/{inventory_list_id}/product_inventory_records/{product_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a product inventory record. */
        get: operations["getInventoryListsByIDProductInventoryRecordsByID"];
        /** @description Creates a product inventory record using the information provided. */
        put: operations["putInventoryListsByIDProductInventoryRecordsByID"];
        post?: never;
        /** @description Deletes a product inventory record by ID. */
        delete: operations["deleteInventoryListsByIDProductInventoryRecordsByID"];
        options?: never;
        head?: never;
        /** @description Updates the product inventory record with the specified information. */
        patch: operations["patchInventoryListsByIDProductInventoryRecordsByID"];
        trace?: never;
    };
    "/job_execution_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description Searches for job executions.
         *       <p/>
         *      The query attribute specifies a complex query that can be used to narrow down the search. This is the list of
         *      searchable attributes:
         *       <ul>
         *       <li> id - String </li>
         *       <li> job_id - String </li>
         *       <li> start_time - Date </li>
         *       <li> end_time - Date </li>
         *       <li> status - String </li>
         *       </ul>
         *      This is the list of sortable attributes:
         *       <ul>
         *       <li> job_id - String </li>
         *       <li> start_time - Date </li>
         *       <li> end_time - Date </li>
         *       <li> status - String </li>
         *       </ul>
         */
        post: operations["postJobExecutionSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/jobs/{job_id}/executions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description Executes the job with the given job ID by creating and returning a job execution for it. The job might still be
         *      executed when the job execution is returned. Note that this resource is also intended for running system jobs.
         *       <p>
         *      See  <u> Global Jobs </u>  for information on available system jobs.
         *       </p>
         */
        post: operations["postJobsByIDExecutions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/jobs/{job_id}/executions/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Returns job execution information using the specified ID for the job having the specified job ID. */
        get: operations["getJobsByIDExecutionsByID"];
        put?: never;
        post?: never;
        /** @description Deletes job execution information using the specified ID for the job having the specified job ID. */
        delete: operations["deleteJobsByIDExecutionsByID"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/libraries/{library_id}/content/{content_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Returns a content asset using the specified ID. If the content asset cannot be found, the server returns a 404 (ContentNotFoundException) fault. If the connection is not secure, the server returns a 403 (SecureCommunicationRequiredException). */
        get: operations["getLibrariesByIDContentByID"];
        /** @description Creates a new content asset in the specified library, or overwrites an existing content asset. If a content asset with the specified ID already exists, the server completely overwrites the content asset. Please note: Existing folder assignments are not touched. If the existing content asset is locked, the server returns a 409 (ResourceLockedException) fault. If the connection is not secure, the server returns a 403 (SecureCommunicationRequiredException) fault. */
        put: operations["putLibrariesByIDContentByID"];
        post?: never;
        /** @description Deletes the content asset with the specified ID from the specified library. If the content asset is not found, the server returns a 404 (NotFoundException) fault. If the content asset is locked by another user, the server returns a 409 (ResourceLockedException) fault. If the connection is not secure, the server returns a 403 (SecureCommunicationRequiredException) fault. */
        delete: operations["deleteLibrariesByIDContentByID"];
        options?: never;
        head?: never;
        /** @description Updates a content asset. In the request, the If-Match header is required. The value of the header is an 'ETag' representing the last known base-point information for the content asset. If the header is missing, the server returns a 409 (IfMatchRequiredException) fault. If the header value does not match the server's 'ETag', the server returns a 412 (InvalidIfMatchException) fault. The delta information for the library folder containing the content asset is updated atomically: the information is written completely or not at all. If the content asset is locked, the server returns a 409 (ResourceLockedException) fault. */
        patch: operations["patchLibrariesByIDContentByID"];
        trace?: never;
    };
    "/libraries/{library_id}/content/{content_id}/folders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all assigned folders of a content asset. */
        get: operations["getLibrariesByIDContentByIDFolders"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/libraries/{library_id}/folder_assignments/{content_id}/{folder_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get a single content to folder assignment */
        get: operations["getLibrariesByIDFolderAssignmentsByIDByID"];
        /** @description Action to assign a content asset to a specified folder. */
        put: operations["putLibrariesByIDFolderAssignmentsByIDByID"];
        post?: never;
        /** @description Action to unassign a content asset from the specified library folder. */
        delete: operations["deleteLibrariesByIDFolderAssignmentsByIDByID"];
        options?: never;
        head?: never;
        /** @description Action to update a single content to folder assignment. Currently only the position and default attribute can be changed. */
        patch: operations["patchLibrariesByIDFolderAssignmentsByIDByID"];
        trace?: never;
    };
    "/libraries/{library_id}/folders/{folder_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get folder information. */
        get: operations["getLibrariesByIDFoldersByID"];
        /** @description Action to create a new library folder, or to replace an existing folder. This action completely overwrites existing folders. Please note: Sub folders and assignments to content assets are not touched. This action ignores the folder ID in the input document. */
        put: operations["putLibrariesByIDFoldersByID"];
        post?: never;
        /** @description Delete folder */
        delete: operations["deleteLibrariesByIDFoldersByID"];
        options?: never;
        head?: never;
        /** @description Updates an existing folder. In the request, the If-Match header is required. The value of the header is an 'ETag' representing the last known base-point information for the library folder. If the header is missing, the server returns a 409 (IfMatchRequiredException) fault. If the header value does not match the server's 'ETag', the server returns a 412 (InvalidIfMatchException) fault. The delta information for the library folder is updated atomically: the information is written completely or not at all. */
        patch: operations["patchLibrariesByIDFoldersByID"];
        trace?: never;
    };
    "/libraries/{library_id}/folders/{folder_id}/content": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all assigned content assets of a folder. */
        get: operations["getLibrariesByIDFoldersByIDContent"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/libraries/{library_id}/folders/{folder_id}/sub_folders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get sub folders information. */
        get: operations["getLibrariesByIDFoldersByIDSubFolders"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/locale_info/locales": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get the set of active locales for which the user has read or write permission. */
        get: operations["getLocaleInfoLocales"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/log_requests/ecdn": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Requests a LogFile-Fetching for the passed zone and time frame. */
        post: operations["postLogRequestsEcdn"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/log_requests/ecdn/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Retrieves the current execution status of the log file fetching. */
        get: operations["getLogRequestsEcdnByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/metrics/{apitype}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The metrics resource provides insights into runtimes of individual OCAPI requests against the shop or the data-API. Responses of the metrics resource are JSON wrapped metrics in Prometheus Exposition format. For each OCAPI resource, following metrics are available for the given dimension and the current time-frame (1-minute averages).  <ul>     <li> average time of a request (p50 and p95 timings are available under the quantile dimension) in milliseconds </li>     <li> minimum time of all requests in milliseconds </li>     <li> maximum time of all requests in milliseconds </li>     <li> m1-rate, or the one-minute-rate of requests in operations / second </li>   </ul>  Refer to the documentation of the response document for a detailed description of the metrics and dimensions exposed by this API. */
        get: operations["getMetricsByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/ocapi_configs/{clientId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get all allowed resources for the client. */
        get: operations["getOcapiConfigsByID"];
        /** @description Add a client to existing OCAPI configurations. Overwrite config if the client already exists. */
        put: operations["putOcapiConfigsByID"];
        /** @description Add a client to existing OCAPI configurations. Return errors when client already exists. */
        post: operations["postOcapiConfigsByID"];
        /** @description Delete a client. */
        delete: operations["deleteOcapiConfigsByID"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/permissions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get application specific permissions per type. */
        get: operations["getPermissions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/permissions/bm": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get Business Manager permissions per type. */
        get: operations["getPermissionsBm"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/permissions/bm/functional": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get functional permissions per scope. */
        get: operations["getPermissionsBmFunctional"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/permissions/bm/locale": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get locale permissions per scope. */
        get: operations["getPermissionsBmLocale"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/permissions/bm/module": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get Business Manager module permissions per scope. */
        get: operations["getPermissionsBmModule"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/permissions/bm/webdav": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get WebDAV permissions per scope. */
        get: operations["getPermissionsBmWebdav"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/permissions/csc": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get permissions per type. */
        get: operations["getPermissionsCsc"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/permissions/csc/module": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get CSC module permissions per scope. */
        get: operations["getPermissionsCscModule"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/product_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for products. </p>
         *
         *       <p> Note: This resource does not return information about product master and product variation relationships. Use the  <u> ProductSearch SHOP API  </u> resource to retrieve more details about product relationships. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. Attributes are grouped
         *      into different buckets.  These are the list of searchable attributes with their corresponding buckets: </p>
         *
         *       <p> Main: </p>
         *       <ul>
         *          <li> id - String </li>
         *          <li> name - String </li>
         *          <li> online - SiteSpecific Boolean </li>
         *          <li> searchable - SiteSpecific Boolean  </li>
         *          <li> valid_from - SiteSpefic DateTime  </li>
         *          <li> valid_to - SiteSpecfic DateTime  </li>
         *          <li> type - ProductType  </li>
         *          <li> creation_date - DateTime </li>
         *          <li> last_modified - DateTime </li>
         *       </ul>
         *       <p> Catalog: </p>
         *       <ul>
         *          <li> catalog_id - String </li>
         *       </ul>
         *       <p> Category: </p>
         *       <ul>
         *          <li> category_id - String </li>
         *       </ul>
         *       <p> Special: </p>
         *       <ul>
         *          <li> type - {"item", "set, "bundle", "master", "part_of_product_set", "bundled", "variant", "variation_group", "option", "retail_set", "part_of_retail_set"} </li>
         *       </ul>
         *
         *       <p> The sortable properties are: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> name - String </li>
         *       <li> creation_date - DateTime </li>
         *       </ul>
         *
         *       <p> When you specify a catalog_id or category_id, only products explicitly assigned to that catalog or
         *      category are returned. For example, if a product with variants is assigned to a catalog, but its
         *      variants are not, searching on that catalog_id only returns the main product, not the variants. This
         *      behavior is different from that of the product search in Business Manager, which returns products
         *      that inherit the selected catalog or category assignment. </p>
         *
         *       <p> Only attributes in the same bucket can be joined using a disjunction (OR).
         *      For instance, when joining id and catalog_id above, only a conjunction is allowed (AND), whereas id
         *      and searchable can be joined using a disjunction because they are in the same bucket.  If an attribute
         *      is used in a disjunction (OR) that violates this rule, an exception will be thrown. </p>
         *
         *       <p> The product search retrieves additional properties of the product when expansions are used.
         *     	The available expand attribute values are: </p>
         *       <ul>
         *             	 <li> 'all' will retrieve all the product properties. </li>
         *                <li> 'availability' will retrieve the following properties:
         *                  <ul> <li> ats </li>
         *                  <li> in_stock </li>
         *                  <li> online </li> </ul>
         *     		     </li>
         *                <li> 'categories' will retrieve the following properties:
         *                  <ul> <li> assigned_categories </li> </ul>
         *     			 </li>
         *                <li> 'images' will retrieve the following properties:
         *                  <ul> <li> image </li> </ul>
         *     			 </li>
         *     			 <li> 'all_images' used with images will retrieve the following properties:
         *                  <ul> <li> image </li> </ul>
         *                  <ul> <li> image_groups </li> </ul>
         *     			 </li>
         *                <li> 'prices' will retrieve the following properties:
         *                  <ul> <li> price </li>
         *                  <li> price_currency </li> </ul>
         *     			 </li>
         *                <li> 'sets' will retrieve the following properties:
         *                  <ul> <li> set_products </li>
         *                  <li> product_sets </li> </ul>
         *     			 </li>
         *                <li> 'bundles' will retrieve the following properties:
         *                  <ul> <li> product_bundles </li>
         *                  <li> bundled_products </li>
         *                  </ul>
         *     			 </li>
         *
         *       </ul>
         */
        post: operations["postProductSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/products/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get product information. */
        get: operations["getProductsByID"];
        /**
         * @description Creates a product using the information provided. If a product exists with the same identifier, it is
         *      cleared and overwritten unless the request includes the header x-dw-validate-existing=true.
         *      Note that the following read-only attributes aren't replaced:  <code> assigned_categories </code> ,  <code> bundled_products </code> ,  <code> classification_category </code> ,  <code> creation_date </code> ,  <code> default_variant_id </code> ,  <code> image </code> ,  <code> image_groups </code> ,  <code> last_modified </code> ,  <code> owning_catalog_name </code> ,  <code> price_per_unit </code> ,  <code> primary_categories </code> ,  <code> primary_category_id </code> ,  <code> product_bundles </code> ,  <code> product_options </code> ,  <code> product_sets </code> ,  <code> set_products </code> ,  <code> type </code> ,  <code> variants </code> ,  <code> variation_attributes </code> ,  <code> variation_groups </code> , and  <code> variation_values </code> .
         */
        put: operations["putProductsByID"];
        post?: never;
        /** @description Deletes the product by ID */
        delete: operations["deleteProductsByID"];
        options?: never;
        head?: never;
        /**
         * @description Update a product using the information provided.
         *
         *      Fields that can be updated:
         *      name, page_description, long_description, page_title,
         *      page_keywords, brand, ean,upc, manufacture_sku,
         *      manufacture_name, searchable, unit, searchable,
         *      online_flag, default_variant_id, valid_to,
         *      valid_from, tax_class_id, localized_tax_class_id.
         */
        patch: operations["patchProductsByID"];
        trace?: never;
    };
    "/products/{id}/variant_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches product variations for master product or variation group product. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. This is the list
         *      of searchable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> product_id - String </li>
         *       <li> name - String </li>
         *       <li> online - SiteSpecific Boolean </li>
         *       <li> in_stock - Boolean  </li>
         *       <li> searchable - SiteSpecific Boolean  </li>
         *       <li> ats - Actual available quantity to sell - Double  </li>
         *       <li> variation_attribute.ATTRIBUTE_ID (Ex:variation_attribute.color) - String </li>
         *       </ul>
         *       <p> Sortable Fields: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> product_id - String </li>
         *       <li> name - String </li>
         *       <li> online - SiteSpecific Boolean </li>
         *       <li> in_stock - Boolean  </li>
         *       <li> searchable - SiteSpecific Boolean  </li>
         *       <li> ats - Actual available quantity to sell - Double  </li>
         *       </ul>
         *
         *       <p> Note:
         *      The calculated value of "online" and "searchable" is used in the search/sort. </p>
         *       <p> A search/sort by the the site specific attributes require the Site ID query parameter to be set.
         *      They are "online", "in_stock", "searchable" and "ats". </p>
         *       <p>  We assume that every field that starts with variation_attribute. is searchable and dot is followed by ATTRIBUTE_ID". </p>
         *
         *
         *       <p> The list of expansions to retrieve product information. The expand values available are: </p>
         *      		   <ul>
         *      			 <li> _base - Basic product information is retrieved. This expand is included by default. </li>
         *      			 <li> all - All product information including the following properties are retrieved:
         *             	 <ul>
         *             		 <li> image </li>
         *             		 <li> price - site_id has to be provided to see this property </li>
         *             		 <li> price_currency - site_id has to be provided to see this property </li>
         *             	 </ul> </li>
         *      			 <li> availability - Information related to the availability of the product variation.  This expand is not included by default.
         *             	 <ul>
         *             		 <li> ats - site_id has to be provided to see this property </li>
         *             		 <li> in_stock - site_id has to be provided to see this property </li>
         *             		 <li> online - site_id has to be provided to see this property </li>
         *             		 <li> searchable </li>
         *             	 </ul> </li>
         *                <li> variations - Information related to product variation is retrieved. This expand is included by default. </li>
         *      			 <li> attributes - Information related to product variation attributes is retrieved. This expand is not included by default. </li>
         *      		   </ul>
         */
        post: operations["postProductsByIDVariantSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/products/{master_product_id}/variation_groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Reads variation groups for a product master. */
        get: operations["getProductsByIDVariationGroups"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/products/{master_product_id}/variation_groups/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Read a variation group for a product master. */
        get: operations["getProductsByIDVariationGroupsByID"];
        /**
         * @description Assign a variation group for a product master.  If the variation group product does not initially exist,
         *      one is created using the body passed in.
         */
        put: operations["putProductsByIDVariationGroupsByID"];
        post?: never;
        /**
         * @description Unassign a variation group product from a product master.  The variation group product is not
         *      deleted: it remains as a normal product after unsassign.
         */
        delete: operations["deleteProductsByIDVariationGroupsByID"];
        options?: never;
        head?: never;
        /** @description Update a variation group for a product master. */
        patch: operations["patchProductsByIDVariationGroupsByID"];
        trace?: never;
    };
    "/products/{master_product_id}/variations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Reads variation for a product master. */
        get: operations["getProductsByIDVariations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/products/{master_product_id}/variations/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Read a variation for a product master. */
        get: operations["getProductsByIDVariationsByID"];
        /**
         * @description Assign a variation for a product master.  If the variation product does not initially exist,
         *      one is created using the body passed in.
         */
        put: operations["putProductsByIDVariationsByID"];
        post?: never;
        /**
         * @description Unassign a variation product from a product master.  The variation product is not deleted: it remains as a
         *      normal product after unsassign.
         */
        delete: operations["deleteProductsByIDVariationsByID"];
        options?: never;
        head?: never;
        /** @description Update a variation for a product master. */
        patch: operations["patchProductsByIDVariationsByID"];
        trace?: never;
    };
    "/products/{product_id}/product_options": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Read local and shared product options of a product. */
        get: operations["getProductsByIDProductOptions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/products/{product_id}/product_options/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Read a local or shared product option of a product. */
        get: operations["getProductsByIDProductOptionsByID"];
        /** @description Creates a local product option using the information provided or binds a shared product option to the product. */
        put: operations["putProductsByIDProductOptionsByID"];
        post?: never;
        /** @description Deletes a local product option or unbinds a shared product option from the product. */
        delete: operations["deleteProductsByIDProductOptionsByID"];
        options?: never;
        head?: never;
        /** @description Updates a local product option with the information provided. */
        patch: operations["patchProductsByIDProductOptionsByID"];
        trace?: never;
    };
    "/products/{product_id}/product_options/{option_id}/values": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Read local product option values of a local product option in a product. */
        get: operations["getProductsByIDProductOptionsByIDValues"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/products/{product_id}/product_options/{option_id}/values/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Read a local product option value of a local product option in a product. */
        get: operations["getProductsByIDProductOptionsByIDValuesByID"];
        /** @description Creates a local product option value using the information provided. */
        put: operations["putProductsByIDProductOptionsByIDValuesByID"];
        post?: never;
        /** @description Deletes a local product option value by ID. */
        delete: operations["deleteProductsByIDProductOptionsByIDValuesByID"];
        options?: never;
        head?: never;
        /** @description Updates a local product option value with the information provided. */
        patch: operations["patchProductsByIDProductOptionsByIDValuesByID"];
        trace?: never;
    };
    "/products/{product_id}/variation_attributes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Reads variation attributes of a product of type variant or variation master or variation group. */
        get: operations["getProductsByIDVariationAttributes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/products/{product_id}/variation_attributes/{attribute_id}/values": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Reads variation attribute values of a variation attribute bound to a product. */
        get: operations["getProductsByIDVariationAttributesByIDValues"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/products/{product_id}/variation_attributes/{attribute_id}/values/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get product variation attribute value information. */
        get: operations["getProductsByIDVariationAttributesByIDValuesByID"];
        /** @description Action to create a product variation attribute value. */
        put: operations["putProductsByIDVariationAttributesByIDValuesByID"];
        post?: never;
        /** @description Deletes the variation attribute value of a variation attribute bound to a master product */
        delete: operations["deleteProductsByIDVariationAttributesByIDValuesByID"];
        options?: never;
        head?: never;
        /** @description Updates the variation attribute value of a variation attribute of a master product. */
        patch: operations["patchProductsByIDVariationAttributesByIDValuesByID"];
        trace?: never;
    };
    "/products/{product_id}/variation_attributes/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get variation attribute information only for master product. */
        get: operations["getProductsByIDVariationAttributesByID"];
        /**
         * @description Creates a local variation attribute using the information provided. This endpoint can't create shared variation attributes.
         *      To create a shared variation attribute, use the catalogs resource.
         */
        put: operations["putProductsByIDVariationAttributesByID"];
        post?: never;
        /** @description Deletes a variation attribute by ID. */
        delete: operations["deleteProductsByIDVariationAttributesByID"];
        options?: never;
        head?: never;
        /**
         * @description Updates the variation attribute with the specified information.
         *
         *       <ul>
         *       <li> name </li>
         *       <li> slicing </li>
         *       </ul>
         */
        patch: operations["patchProductsByIDVariationAttributesByID"];
        trace?: never;
    };
    "/role_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description Searches for access roles.
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. These are the list
         *      of searchable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> description - String </li>
         *       </ul>
         *       <p> Optionally, a user ID (the user login) can be specified. When it is supplied, the search for roles is limited to the
         *      roles assigned to this user. When expanding the permissions for the roles, all effective permissions for this user can be retrieved. </p>
         *
         *       <p> Optionally, a (single) permission can be specified. When it is supplied, the search for roles is limited to the
         *      roles having this permission. When expanding the users for the roles, all users having this permission can be retrieved. </p>
         *
         *       <p> The output of the query can also be sorted. These are the list of sortable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> description - String </li>
         *       </ul>
         */
        post: operations["postRoleSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the access roles with no filtering. */
        get: operations["getRoles"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get a single access role. */
        get: operations["getRolesByID"];
        /** @description Action to create an access role. */
        put: operations["putRolesByID"];
        post?: never;
        /** @description Action to delete an access role. */
        delete: operations["deleteRolesByID"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles/{id}/permissions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Retrieves a list of permissions assigned to the given role. */
        get: operations["getRolesByIDPermissions"];
        /**
         * @description Assigns permissions to the given role. This will replace the current permission assignments. For the 'Administrator'
         *      role only adjustments for custom module permissions will be processed but other given permissions will be ignored.
         */
        put: operations["putRolesByIDPermissions"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles/{id}/user_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description Searches for users of the specified access role.
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. These are the list
         *      of searchable attributes: </p>
         *       <ul>
         *       <li> login - String </li>
         *       <li> email - String </li>
         *       <li> first_name - String </li>
         *       <li> last_name - String </li>
         *       <li> external_id - String </li>
         *       <li> last_login_date - Date </li>
         *       <li> is_locked - Boolean </li>
         *       <li> is_disabled - Boolean </li>
         *       </ul>
         *
         *       <p> The output of the query can also be sorted. These are the list of sortable attributes: </p>
         *       <ul>
         *       <li> login - String </li>
         *       <li> email - String </li>
         *       <li> first_name - String </li>
         *       <li> last_name - String </li>
         *       <li> external_id - String </li>
         *       <li> last_login_date - Date </li>
         *       </ul>
         */
        post: operations["postRolesByIDUserSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles/{id}/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the users assigned to the specified access role. */
        get: operations["getRolesByIDUsers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/roles/{id}/users/{login}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Action to assign a user to an access role */
        put: operations["putRolesByIDUsersByID"];
        post?: never;
        /** @description Action to unassign a user to an access role */
        delete: operations["deleteRolesByIDUsersByID"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/settings/logging/custom": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get custom log settings. */
        get: operations["getSettingsLoggingCustom"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** @description Updates the custom log settings. */
        patch: operations["patchSettingsLoggingCustom"];
        trace?: never;
    };
    "/site_preferences/preference_groups/{group_id}/{instance_type}/preference_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Search preferences across sites in the specified preference group and instance. </p>
         *       <p/>
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. </p>
         *
         *       <p> The following is a list of searchable fields: </p>
         *
         *       <ul>
         *       <li> id - String </li>
         *       <li> display_name - Localized String </li>
         *       <li> description - Localized String </li>
         *       <li> value_type* - one of {string, int, double, text, html, date, image, boolean, money, quantity, datetime, email, password, set_of_string, set_of_int, set_of_double, enum_of_string, enum_of_int} </li>
         *       </ul>
         *
         *       <p> * value_type can only be joined with other attributes using a conjunction (AND). </p>
         *       <p> Note that only searchable attributes can be used in sorting. </p>
         *
         *       <p> Note: If instance type sandbox is used, the preference values of development instance type will be returned as fallback. </p>
         */
        post: operations["postSitePreferencesPreferenceGroupsByIDByIDPreferenceSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/site_preferences/preference_groups/{group_id}/{instance_type}/preferences/{preference_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @description Get a preference across sites in the specified preference group and instance.
         *
         *       <p> Note: If instance type sandbox is used, the preference values of development instance type will be returned as fallback. </p>
         */
        get: operations["getSitePreferencesPreferenceGroupsByIDByIDPreferencesByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/site_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for sites. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. These are the list
         *      of searchable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> display_name - Localized  &lt; String &gt; </li>
         *       <li> description - Localized  &lt; String &gt; </li>
         *       <li> in_deletion - Boolean </li>
         *       </ul>
         *
         *       <p> The output of the query can also be sorted. These are the list of sortable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> display_name - Localized  &lt; String &gt; </li>
         *       <li> description - Localized  &lt; String &gt; </li>
         *       <li> in_deletion - Boolean </li>
         *       </ul>
         */
        post: operations["postSiteSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all existing sites. */
        get: operations["getSites"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to read an existing site. */
        get: operations["getSitesByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/ab_test_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description <p> Searches for A/B Tests. </p>   <p> The query attribute specifies a complex query that can be used to narrow down the search. This is the list of searchable attributes: </p>   <ul>   <li> id - String </li>   <li> description - String </li>   <li> enabled - Boolean </li>   <li> paused - Boolean </li>   <li> key_metric_id - String </li>   <li> email_addresses - String </li>   <li> tags- String </li>   <li> expiration_type - String enum[session, never] </li>   <li> start_date - DateTime </li>   <li> end_date - DateTime </li>   </ul>   <p> These fields can only be used in Queries as conjunctions (using AND).  If the field is used in a disjunction (OR) an exception will be thrown. </p>   <p> The output of the query can also be sorted. These are the list of sortable attributes: </p>   <ul>   <li> id - String </li>   <li> description - String </li>   <li> enabled - Boolean </li>   <li> paused - Boolean </li>   <li> key_metric_id - String </li>   </ul> */
        post: operations["postSitesByIDAbTestSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/ab_tests": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the A/B tests with searching. */
        get: operations["getSitesByIDAbTests"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/ab_tests/{ab_test_id}/segments/{segment_id}/promotions/{promotion_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Action to bind a single promotion to a given abTest. */
        put: operations["putSitesByIDAbTestsByIDSegmentsByIDPromotionsByID"];
        post?: never;
        /** @description Action to unbind one promotions from a given abTest. */
        delete: operations["deleteSitesByIDAbTestsByIDSegmentsByIDPromotionsByID"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/ab_tests/{ab_test_id}/segments/{segment_id}/slot_configurations/{slot_id}/{slot_config_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Action to bind a slot configuration to a given abTest. */
        put: operations["putSitesByIDAbTestsByIDSegmentsByIDSlotConfigurationsByIDByID"];
        post?: never;
        /** @description Action to unbind a slot configuration from a given abTest. */
        delete: operations["deleteSitesByIDAbTestsByIDSegmentsByIDSlotConfigurationsByIDByID"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/ab_tests/{ab_test_id}/segments/{segment_id}/sorting_rules/{sorting_rule_id}/{category_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Action to bind a single sorting rule to a given abTest. */
        put: operations["putSitesByIDAbTestsByIDSegmentsByIDSortingRulesByIDByID"];
        post?: never;
        /** @description Action to unbind a single sorting rule from a given abTest. */
        delete: operations["deleteSitesByIDAbTestsByIDSegmentsByIDSortingRulesByIDByID"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/ab_tests/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get an A/B Test information. */
        get: operations["getSitesByIDAbTestsByID"];
        /** @description Creates an A/B Test using the information provided. If an A/B Test with the same unique identifier exists, it will be deleted and a new one will be created unless the header x-dw-validate-existing=true is passed in with the request. */
        put: operations["putSitesByIDAbTestsByID"];
        post?: never;
        /** @description Deletes the A/B Test by ID */
        delete: operations["deleteSitesByIDAbTestsByID"];
        options?: never;
        head?: never;
        /** @description Updates the A/B Test with the specified information. */
        patch: operations["patchSitesByIDAbTestsByID"];
        trace?: never;
    };
    "/sites/{site_id}/ab_tests/{id}/segments/{segment_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets an A/B Test segment using the information provided. */
        get: operations["getSitesByIDAbTestsByIDSegmentsByID"];
        /** @description Creates an A/B Test segment using the information provided. */
        put: operations["putSitesByIDAbTestsByIDSegmentsByID"];
        post?: never;
        /** @description Deletes the A/B Test Segment by ID */
        delete: operations["deleteSitesByIDAbTestsByIDSegmentsByID"];
        options?: never;
        head?: never;
        /** @description Updates the A/B Test segment with the specified information. */
        patch: operations["patchSitesByIDAbTestsByIDSegmentsByID"];
        trace?: never;
    };
    "/sites/{site_id}/ai/recommender_names": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a list of available AI recommenders. Recommenders are configured in the Einstein configurator and are required with AI recommendation API requests. */
        get: operations["getSitesByIDAiRecommenderNames"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/campaign_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for campaigns. </p>
         *
         *       <p> The Campaign Search document contains a search object that allows filtering on various attributes. </p>
         *
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. These are the list
         *      of searchable attributes: </p>
         *       <ul>
         *           <li> campaign_id - String </li>
         *           <li> description - String </li>
         *           <li> enabled - Boolean </li>
         *           <li> coupon_id* - String </li>
         *           <li> customer_group* - String </li>
         *           <li> source_code* - String </li>
         *           <li> start_date - Date </li>
         *           <li> end_date - Date </li>
         *           <li> last_modified - Date </li>
         *
         *       </ul>
         *
         *       <p> These fields can only be used in Queries as conjunctions (using AND).  If the field is used in a disjunction
         *      (OR) an exception will be thrown. </p>
         *
         *       <p> Note that only searchable attributes (excluding the ones marked with above with an asterisk) can be used in sorting
         *      Additionally start_date, end_date and last_modified cannot be used in sorting. </p>
         */
        post: operations["postSitesByIDCampaignSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/campaigns/{campaign_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get campaign information. */
        get: operations["getSitesByIDCampaignsByID"];
        /** @description Creates a campaign using the information provided. */
        put: operations["putSitesByIDCampaignsByID"];
        post?: never;
        /** @description Deletes the campaign by ID */
        delete: operations["deleteSitesByIDCampaignsByID"];
        options?: never;
        head?: never;
        /** @description Updates the campaign with the specified information. */
        patch: operations["patchSitesByIDCampaignsByID"];
        trace?: never;
    };
    "/sites/{site_id}/campaigns/{campaign_id}/coupons/{coupon_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Action to bind a single coupon to a given campaign. */
        put: operations["putSitesByIDCampaignsByIDCouponsByID"];
        post?: never;
        /** @description Action to unbind a coupon from a given campaign. */
        delete: operations["deleteSitesByIDCampaignsByIDCouponsByID"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/campaigns/{campaign_id}/customer_groups/{customer_group_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Action to bind a single customer group to a given campaign. */
        put: operations["putSitesByIDCampaignsByIDCustomerGroupsByID"];
        post?: never;
        /** @description Action to unbind a customer group from a given campaign. */
        delete: operations["deleteSitesByIDCampaignsByIDCustomerGroupsByID"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/campaigns/{campaign_id}/promotions/{promotion_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Action to bind a single promotion to a given campaign. */
        put: operations["putSitesByIDCampaignsByIDPromotionsByID"];
        post?: never;
        /** @description Action to unbind a single promotion from a given campaign. */
        delete: operations["deleteSitesByIDCampaignsByIDPromotionsByID"];
        options?: never;
        head?: never;
        /** @description Action to update the assignment of promotion to a campaign. */
        patch: operations["patchSitesByIDCampaignsByIDPromotionsByID"];
        trace?: never;
    };
    "/sites/{site_id}/campaigns/{campaign_id}/slot_configurations/{slot_id}/{slot_config_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Action to bind a slot configuration to a given campaign. */
        put: operations["putSitesByIDCampaignsByIDSlotConfigurationsByIDByID"];
        post?: never;
        /** @description Action to unbind a slot configuration from a given campaign. */
        delete: operations["deleteSitesByIDCampaignsByIDSlotConfigurationsByIDByID"];
        options?: never;
        head?: never;
        /** @description Action to update the assignment of slot configuration to a campaign. */
        patch: operations["patchSitesByIDCampaignsByIDSlotConfigurationsByIDByID"];
        trace?: never;
    };
    "/sites/{site_id}/campaigns/{campaign_id}/sorting_rules/{sorting_rule_id}/{category_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Action to bind a single sorting rule to a given campaign. */
        put: operations["putSitesByIDCampaignsByIDSortingRulesByIDByID"];
        post?: never;
        /** @description Action to unbind a single sorting rule from a given campaign. */
        delete: operations["deleteSitesByIDCampaignsByIDSortingRulesByIDByID"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/campaigns/{campaign_id}/source_code_groups/{source_code_group_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Action to bind a single source code group to a given campaign. */
        put: operations["putSitesByIDCampaignsByIDSourceCodeGroupsByID"];
        post?: never;
        /** @description Action to unbind a source code group from a given campaign. */
        delete: operations["deleteSitesByIDCampaignsByIDSourceCodeGroupsByID"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/cartridges": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Overwrite cartridge path. */
        put: operations["putSitesByIDCartridges"];
        /** @description Add a cartridge to current cartridge path. */
        post: operations["postSitesByIDCartridges"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/cartridges/{cartridge_name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /** @description Remove a cartridge from cartridge path. */
        delete: operations["deleteSitesByIDCartridgesByID"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/coupon_redemption_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p>
         *      Searches for coupon redemptions.
         *       </p>
         *       <p>
         *      The Coupon Redemption Search document contains a search object that allows filtering on various attributes.
         *       </p>
         *       <p>
         *      The query attribute specifies a complex query that can be used to narrow down the search. These are the list of
         *      searchable attributes:
         *       </p>
         *       <ul>
         *       <li> code - String </li>
         *       <li> coupon_id - String </li>
         *       <li> customer_email - String </li>
         *       <li> order_no - String </li>
         *       </ul>
         *       <p>
         *      Note that only searchable attributes can be used in sorting.
         *       </p>
         *      If the role to which the user belongs does not have View_Coupon_Codes permission, then the coupon codes returned
         *      will be masked.
         */
        post: operations["postSitesByIDCouponRedemptionSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/coupon_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p>
         *      Searches for coupons.
         *       </p>
         *       <p>
         *      The Coupon Search document contains a search object that allows filtering on various attributes.
         *       </p>
         *       <p>
         *      The query attribute specifies a complex query that can be used to narrow down the search. These are the list of
         *      searchable attributes:
         *       </p>
         *       <ul>
         *       <li> coupon_id - String </li>
         *       <li> description - String </li>
         *       <li> type - one of {"single_code", "multiple_codes", "system_codes"} </li>
         *       <li> enabled - boolean </li>
         *       </ul>
         *       <p>
         *      Note that only searchable attributes can be used in sorting. In case no sorting attribute is specified the result
         *      is sorted by coupon_id.
         *       </p>
         *       <p>
         *      The  <i> stats </i>  expand value is required to return the following fields in the Coupon document:
         *       </p>
         *       <ul>
         *       <li> exported_code_count </li>
         *       <li> redemption_count </li>
         *       <li> total_codes_count </li>
         *       </ul>
         */
        post: operations["postSitesByIDCouponSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/coupons": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @description Action to get all the coupons with no filtering.
         *       <p>
         *      The result is sorted by by coupon_id ascending.
         *       </p>
         */
        get: operations["getSitesByIDCoupons"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/coupons/{coupon_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @description Action to get coupon information.
         *
         *       <p> The following fields are returned in the Coupon document when specifying the  <i> stats </i>  expand:
         *       <ul>
         *           <li> exported_code_count </li>
         *           <li> redemption_count </li>
         *           <li> total_codes_count </li>
         *       </ul>
         *       </p>
         *
         *      If the role to which the user belongs does not have View_Coupon_Codes permission, then the coupon codes returned will be masked.
         */
        get: operations["getSitesByIDCouponsByID"];
        /**
         * @description Creates a coupon using the information provided. If a coupon exists with the same unique identifier,
         *      the coupon is replaced completely.
         */
        put: operations["putSitesByIDCouponsByID"];
        post?: never;
        /** @description Delete a coupon by id. */
        delete: operations["deleteSitesByIDCouponsByID"];
        options?: never;
        head?: never;
        /** @description Updates the coupon with the specified information. */
        patch: operations["patchSitesByIDCouponsByID"];
        trace?: never;
    };
    "/sites/{site_id}/coupons/{coupon_id}/campaigns": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get the campaigns that have a coupon assigned to them either directly or through promotions */
        get: operations["getSitesByIDCouponsByIDCampaigns"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/coupons/{coupon_id}/campaigns/{campaign_id}/promotions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get the promotions for a campaign that have a coupon assigned to them either directly or through campaigns. */
        get: operations["getSitesByIDCouponsByIDCampaignsByIDPromotions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/coupons/{coupon_id}/codes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @description Get the coupon codes for the given coupon.
         *
         *      If the role to which the user belongs does not have View_Coupon_Codes permission, then the coupon codes returned will be masked.
         */
        get: operations["getSitesByIDCouponsByIDCodes"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/coupons/{coupon_id}/multiple_codes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Add or delete (modify) multiple codes to/from the supplied coupon. */
        post: operations["postSitesByIDCouponsByIDMultipleCodes"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/coupons/{coupon_id}/promotions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get the promotions that have a coupon assigned to them either directly or through campaigns. */
        get: operations["getSitesByIDCouponsByIDPromotions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/custom_objects/{object_type}/{key}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Reads a site specific Custom Object with a given object type ID and a value for the key attribute of the object which represents its unique identifier. */
        get: operations["getSitesByIDCustomObjectsByIDByID"];
        /** @description <p>  Creates a site specific Custom Object from the request body. Note that an existing site specific Custom Object with the same key is overwritten by this action.  </p>   <p>  Use Custom Properties prefixed with  <code> c_ </code>  to define the Custom Object fields. <br/>  For localizable strings, structure the field to support multiple language values by using a map where each locale, for example: en_US, fr_FR, has its corresponding string value.  </p> */
        put: operations["putSitesByIDCustomObjectsByIDByID"];
        post?: never;
        /** @description Deletes a site specific Custom Object. If the Custom Object does not exist, this will do nothing. Note that the customization scripts are only called, if the Custom Object does exist. */
        delete: operations["deleteSitesByIDCustomObjectsByIDByID"];
        options?: never;
        head?: never;
        /** @description <p>  Updates a site specific Custom Object with information from the request body. Note that only provided attributes are updated and that the key attribute is ignored. All other attributes are unchanged.  </p>   <p>  Use Custom Properties prefixed with  <code> c_ </code>  to define the Custom Object fields. <br/>  For localizable strings, structure the field to support multiple language values by using a map where each locale, for example: en_US, fr_FR, has its corresponding string value.  </p> */
        patch: operations["patchSitesByIDCustomObjectsByIDByID"];
        trace?: never;
    };
    "/sites/{site_id}/customer_group_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for customer groups. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. These are the list
         *      of searchable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> description - String </li>
         *       <li> type - String Enum value[system, dynamic, static] </li>
         *       </ul>
         *
         *       <p> The output of the query can also be sorted. These are the list of sortable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> description - String </li>
         *       </ul>
         */
        post: operations["postSitesByIDCustomerGroupSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/customer_groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the customer groups with no filtering. */
        get: operations["getSitesByIDCustomerGroups"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/customer_groups/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get customer group information. */
        get: operations["getSitesByIDCustomerGroupsByID"];
        /** @description Creates a customer group using the information provided. */
        put: operations["putSitesByIDCustomerGroupsByID"];
        post?: never;
        /**
         * @description Triggers customer group deletion by ID. Be aware that the deletion happens via asynchronous batch process
         *      which is the reason the deletion itself is not necessarily finished after the call to this resource returned. The
         *      customer group that is in deletion will be provided in the response.
         */
        delete: operations["deleteSitesByIDCustomerGroupsByID"];
        options?: never;
        head?: never;
        /** @description Updates the customer group with the specified information. */
        patch: operations["patchSitesByIDCustomerGroupsByID"];
        trace?: never;
    };
    "/sites/{site_id}/customer_groups/{id}/member_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for customer group members. For dynamic customer groups and the system groups "Everyone" and "Unregistered" no result is returned (Status Code: 204 - No Content). </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. Attributes are grouped
         *      into different buckets.  These are the list of searchable attributes with their corresponding buckets: </p>
         *
         *       <p> Main: </p>
         *       <ul>
         *            <li> login - String </li>
         *            <li> active - Boolean </li>
         *       </ul>
         *       <p> Customer Profile: </p>
         *       <ul>
         *            <li> customer_no - String </li>
         *            <li> first_name - String </li>
         *            <li> last_name - String </li>
         *            <li> email - String </li>
         *            <li> zip - String </li>
         *       </ul>
         *
         *       <p> Only attributes in the same bucket can be joined using a disjunction (OR).
         *      For instance, when joining login and customer_no above, only a conjunction is allowed (AND), whereas customer_no
         *      and email can be joined using a disjunction because they are in the same bucket.  If an attribute
         *      is used in a disjunction (OR) that violates this rule, an exception will be thrown. </p>
         *
         *       <p> The output of the query can also be sorted. These are the list of sortable attributes: </p>
         *       <ul>
         *       <li> customer_no - String </li>
         *       <li> login - String </li>
         *       </ul>
         *
         *       <p/> If the Business manager customer search is configured to use the new Search Service, the following differences apply:
         *       <ul>
         *           <li> all attributes can be used for sorting (except for 'active') </li>
         *           <li> searching for 'zip' will only search in the customers default address </li>
         *           <li> logical operators can be used without limits (but may result in degraded performance, depending on how they are combined) </li>
         *           <li> new assignments might not be found immediately via the search service, and removed assignments
         *          might also not be in effect immediately (there is a slight delay in updating the index) </li>
         *       </ul>
         */
        post: operations["postSitesByIDCustomerGroupsByIDMemberSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/customer_groups/{id}/members": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the customer group members with no filtering. For dynamic customer groups and the system groups "Everyone" and "Unregistered" no result is returned (Status Code: 204 - No Content). */
        get: operations["getSitesByIDCustomerGroupsByIDMembers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/customer_groups/{id}/members/{customer_no}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get customer group member information. */
        get: operations["getSitesByIDCustomerGroupsByIDMembersByID"];
        /** @description Action to add customer to (static) customer group. */
        put: operations["putSitesByIDCustomerGroupsByIDMembersByID"];
        post?: never;
        /** @description Action to remove a customer from a (static) customer group. */
        delete: operations["deleteSitesByIDCustomerGroupsByIDMembersByID"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/gift_certificate_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for gift certificates. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. These are the list
         *      of searchable attributes: </p>
         *       <ul>
         *       <li> merchant_id - String </li>
         *       <li> masked_gift_certificate_code* - String </li>
         *       <li> order_no - String </li>
         *       <li> sender_name - String </li>
         *       <li> recipient_name - String </li>
         *       <li> recipient_email - String </li>
         *       <li> status - String </li>
         *       <li> enabled - Boolean </li>
         *       <li> message - String </li>
         *       <li> description - String </li>
         *       <li> creation_date - Date </li>
         *       <li> currency_mnemonic* - String </li>
         *       </ul>
         *
         *       <p> * masked_gift_certificate_code, also known as just code, can only be used in a term query.  If a
         *      four-character code is supplied, it is assumed that the search is on the unmasked portion of the code, otherwise
         *      the full code must be matched.  Text queries are not allowed. </p>
         *
         *       <p> * currency_mnemonic can only be joined with other attributes using a conjunction (AND). </p>
         *
         *       <p> Note that only searchable attributes can be used in sorting.  The code attribute cannot be used for sorting. </p>
         */
        post: operations["postSitesByIDGiftCertificateSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/gift_certificates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the gift certificates with no filtering. */
        get: operations["getSitesByIDGiftCertificates"];
        put?: never;
        /** @description Creates a gift certificate using the information provided. */
        post: operations["postSitesByIDGiftCertificates"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/gift_certificates/{merchant_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get gift certificate information using merchant ID. */
        get: operations["getSitesByIDGiftCertificatesByID"];
        put?: never;
        post?: never;
        /** @description Deletes the gift certificate by merchant ID */
        delete: operations["deleteSitesByIDGiftCertificatesByID"];
        options?: never;
        head?: never;
        /**
         * @description Updates the gift certificate with the specified information using merchant ID.
         *
         *      This API can not operate on the transactions attribute of the GiftCertificate request object.
         */
        patch: operations["patchSitesByIDGiftCertificatesByID"];
        trace?: never;
    };
    "/sites/{site_id}/locale_info/locales": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get the set of locales with the system given a site. */
        get: operations["getSitesByIDLocaleInfoLocales"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/orders/{order_no}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** @description Updates the order. */
        patch: operations["patchSitesByIDOrdersByID"];
        trace?: never;
    };
    "/sites/{site_id}/orders/{order_no}/confirmation_status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Updates the order confirmation status. */
        put: operations["putSitesByIDOrdersByIDConfirmationStatus"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/orders/{order_no}/export_status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Updates the order export status. Setting the status to EXPORTED will also trigger the finalization of on-order inventory transactions for this order, meaning that all inventory transactions with type on-order will be moved into final inventory transactions. This is only relevant when on-order inventory is turned on for the inventory list ordered products are in. */
        put: operations["putSitesByIDOrdersByIDExportStatus"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/orders/{order_no}/external_status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Updates the order external status. */
        put: operations["putSitesByIDOrdersByIDExternalStatus"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/orders/{order_no}/payment_instruments/{payment_instrument_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** @description Updates the payment instrument of an order. */
        patch: operations["patchSitesByIDOrdersByIDPaymentInstrumentsByID"];
        trace?: never;
    };
    "/sites/{site_id}/orders/{order_no}/payment_instruments/{payment_instrument_id}/transaction": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /** @description Updates the transaction of an order payment instrument. */
        patch: operations["patchSitesByIDOrdersByIDPaymentInstrumentsByIDTransaction"];
        trace?: never;
    };
    "/sites/{site_id}/orders/{order_no}/payment_status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Updates the order payment status. */
        put: operations["putSitesByIDOrdersByIDPaymentStatus"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/orders/{order_no}/shipments/{shipment_id}/shipping_address": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Updates (create or replace) the order shipment address. */
        put: operations["putSitesByIDOrdersByIDShipmentsByIDShippingAddress"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/orders/{order_no}/shipping_status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Updates the order shipping status. */
        put: operations["putSitesByIDOrdersByIDShippingStatus"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/orders/{order_no}/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Updates the order status by using the corresponding methods (fail, undoFail, place, cancel and undoCancel) from the dw.order.OrderMgr. Orders which are not in status CREATED or FAILED can not be set back. */
        put: operations["putSitesByIDOrdersByIDStatus"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/promotion_campaign_assignment_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for promotion campaign assignments. </p>
         *
         *       <p> The PromotionCampaignAssignment Search document contains a search object that allows filtering on various attributes. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. Attributes are grouped
         *      into different buckets.  These are the list of searchable attributes with their corresponding buckets: </p>
         *
         *       <p> Main: </p>
         *       <ul>
         *           <li> rank - Integer </li>
         *           <li> start_date - Date </li>
         *           <li> end_date - Date </li>
         *       </ul>
         *       <p> Campaign: </p>
         *       <ul>
         *           <li> campaign_id - String </li>
         *       </ul>
         *       <p> Promotion: </p>
         *       <ul>
         *           <li> promotion_id - String </li>
         *           <li> description - String </li>
         *           <li> enabled - Boolean </li>
         *       </ul>
         *       <p> Special handling: </p>
         *       <ul>
         *           <li> coupon_id - String </li>
         *       </ul>
         *
         *       <p> Only fields in the same bucket can be joined using a disjunction (OR). For instance, when joining
         *      campaign_id and rank above, only a conjunction is allowed (AND), whereas promotion_id and description can be
         *      joined to each other using an OR because they are in the same bucket.  Special handling fields must always use
         *      conjunctions. If the field is used in a disjunction (OR) that violates this rule, an exception will be thrown. </p>
         *
         *       <p> Expands that can be applied for the search request </p>
         *       <ul>
         *      	    <li> promotion </li>
         *           <li> campaign </li>
         *       </ul>
         *
         *       <p> Note that only searchable attributes (excluding the ones marked with above with an asterisk) can be used in sorting. </p>
         */
        post: operations["postSitesByIDPromotionCampaignAssignmentSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/promotion_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for promotions. </p>
         *
         *       <p> The SearchRequest document contains a search object that allows filtering on various attributes. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. These are the searchable
         *      attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> name - String </li>
         *       <li> currency_code - String </li>
         *       <li> exclusivity - String </li>
         *       <li> enabled - Boolean </li>
         *       </ul>
         *       <p> Note that only searchable attributes can be used in sorting. Additionally, the following attribute can be used to
         *      sort: </p>
         *       <ul>
         *       <li> promotion_class - String </li>
         *       </ul>
         */
        post: operations["postSitesByIDPromotionSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/promotions/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get promotion information. */
        get: operations["getSitesByIDPromotionsByID"];
        /** @description Creates a promotion using the information provided. */
        put: operations["putSitesByIDPromotionsByID"];
        post?: never;
        /** @description Deletes the promotion by ID */
        delete: operations["deleteSitesByIDPromotionsByID"];
        options?: never;
        head?: never;
        /** @description Updates the promotion with the specified information. */
        patch: operations["patchSitesByIDPromotionsByID"];
        trace?: never;
    };
    "/sites/{site_id}/site_preferences/preference_groups/{group_id}/{instance_type}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * @description For the specified site and instance, read the custom preferences in the preference group.
         *      Specify 'current' to retrieve the preferences for the instance on which this call is being made. The system will recognize its type.
         */
        get: operations["getSitesByIDSitePreferencesPreferenceGroupsByIDByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * @description For the specified site and instance, update one or more custom preferences in the preference group.
         *      Preferences of type password cannot be set to "************" since it is a reserved value.
         */
        patch: operations["patchSitesByIDSitePreferencesPreferenceGroupsByIDByID"];
        trace?: never;
    };
    "/sites/{site_id}/slot_configuration_campaign_assignment_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for slotconfiguration campaign assignments. </p>
         *
         *       <p> The SlotConfigCampaignAssignment Search document contains a search object that allows filtering on various attributes. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. Attributes are grouped
         *      into different buckets.  These are the list of searchable attributes with their corresponding buckets: </p>
         *
         *       <p> Main: </p>
         *       <ul>
         *           <li> rank - Integer </li>
         *           <li> start_date - Date </li>
         *           <li> end_date - Date </li>
         *       </ul>
         *       <p> Campaign: </p>
         *       <ul>
         *           <li> campaign_id - String </li>
         *           <li> enabled - Boolean </li>
         *       </ul>
         *       <p> Slot configuration: </p>
         *       <ul>
         *           <li> slot_configuration_id - String </li>
         *           <li> description - String </li>
         *       </ul>
         *
         *       <p> Only attributes in the same bucket can be joined using a disjunction (OR).
         *      For instance, when joining rank and description above, only a conjunction is allowed (AND), whereas slot_configuration_id
         *      and description can be joined using a disjunction because they are in the same bucket.  If an attribute
         *      is used in a disjunction (OR) that violates this rule, an exception will be thrown. </p>
         *
         *       <p> Expands that can be applied for the search request </p>
         *       <ul>
         *      	    <li> campaign </li>
         *      	    <li> slotConfiguration </li>
         *       </ul>
         *
         *       <p> Note that only searchable attributes (excluding the ones marked with above with an asterisk) can be used in sorting. </p>
         */
        post: operations["postSitesByIDSlotConfigurationCampaignAssignmentSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/slot_configuration_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for slot configurations. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. Attributes are grouped
         *      into different buckets.  These are the list of searchable attributes with their corresponding buckets: </p>
         *
         *       <p> Main: </p>
         *       <ul>
         *          <li> configuration_id - String </li>
         *          <li> default - Boolean </li>
         *          <li> description - String </li>
         *          <li> enabled - Boolean </li>
         *       </ul>
         *       <p> Slot: </p>
         *       <ul>
         *          <li> context - String </li>
         *          <li> slot_id - String </li>
         *       </ul>
         *
         *       <p> Only fields in the same bucket can be joined using a disjunction (OR). For instance, when joining context and
         *      description above, only a conjunction is allowed (AND), whereas context and slot_id can be joined to each other
         *      using a disjunction because they are in the same bucket.  If the field is used in a disjunction (OR) that
         *      violates this rule, an exception will be thrown. </p>
         */
        post: operations["postSitesByIDSlotConfigurationSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/slot_configurations": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the slot configurations with no filtering. */
        get: operations["getSitesByIDSlotConfigurations"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/slot_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for slots. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. The set of fields that
         *      are available to search are: </p>
         *       <ul>
         *       <li> slot_id - String </li>
         *       <li> description - String </li>
         *       <li> context_type - String  </li>
         *       </ul>
         *
         *       <p> Note that only searchable attributes can be used in sorting. "context_type" value is restricted to Global/Folder/Category. </p>
         */
        post: operations["postSitesByIDSlotSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/slots": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the slots with no filtering. Fetches the slot entities which are already populated in the database by crawling the active code. */
        get: operations["getSitesByIDSlots"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/slots/{slot_id}/slot_configurations/{configuration_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to read an existing slot configuration. */
        get: operations["getSitesByIDSlotsByIDSlotConfigurationsByID"];
        /**
         * @description Creates a new configuration for an existing slot. If a slot configuration
         *      exists with the specified configuration_id, slot_id, and context, the existing
         *      slot configuration is overwritten.
         */
        put: operations["putSitesByIDSlotsByIDSlotConfigurationsByID"];
        post?: never;
        /** @description Removes a configuration for slot in a given context from a site. */
        delete: operations["deleteSitesByIDSlotsByIDSlotConfigurationsByID"];
        options?: never;
        head?: never;
        /**
         * @description Updates an existing slot configuration. This action ignores the slot_id and
         *      the context information in the input document. Note that this operation will
         *      not touch any relational properties, which means, that e.g. the rank on a specific
         *      campaign assignment will not be changed, when the rank for the slot configuration
         *      itself is updated.
         */
        patch: operations["patchSitesByIDSlotsByIDSlotConfigurationsByID"];
        trace?: never;
    };
    "/sites/{site_id}/slots/{slot_id}/{context_type}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get slot information. Fetches the slot entities which are already populated in the database by crawling the active code. */
        get: operations["getSitesByIDSlotsByIDByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/sorting_rule_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for product sorting rules. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. These are the list
         *      of searchable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> description - String </li>
         *       <li> creation_date - date of creation </li>
         *       </ul>
         *
         *       <p> The output of the query can also be sorted. These are the list of sortable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> description - String </li>
         *       <li> creation_date - date of creation </li>
         *       </ul>
         *
         *       <p> This resource does not support expand options. </p>
         */
        post: operations["postSitesByIDSortingRuleSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/source_code_group_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description Searches for source code groups.
         *       <p/>
         *      The query attribute specifies a complex query that can be used to narrow down the search. These are the list
         *      of searchable attributes:
         *       <ul>
         *       <li> id - String </li>
         *       <li> description - String </li>
         *       <li> source_code* - String  </li>
         *       <li> start_time - DateTime </li>
         *       <li> end_time - DateTime </li>
         *       <li> creation_date - DateTime </li>
         *       <li> enabled - Boolean </li>
         *       <li> active* - Boolean </li>
         *       </ul>
         *
         *       <p> * - These fields can only be used in Queries as conjunctions (using AND).  If the field is used in a disjunction
         *      (OR) an exception will be thrown. </p>
         *
         *       <p> The output of the query can also be sorted. These are the list of sortable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> description - String </li>
         *       <li> enabled - Boolean </li>
         *       <li> creation_date - DateTime </li>
         *       </ul>
         *
         *       <p> Expands that can be applied for the search request </p>
         *       <ul>
         *       <li> specifications - String </li>
         *       </ul>
         */
        post: operations["postSitesByIDSourceCodeGroupSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/source_code_groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the source code groups with no filtering. */
        get: operations["getSitesByIDSourceCodeGroups"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/source_code_groups/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to retrieve source code group information. */
        get: operations["getSitesByIDSourceCodeGroupsByID"];
        /** @description Creates a source code group using the information provided. */
        put: operations["putSitesByIDSourceCodeGroupsByID"];
        post?: never;
        /** @description Deletes the source code group by ID */
        delete: operations["deleteSitesByIDSourceCodeGroupsByID"];
        options?: never;
        head?: never;
        /** @description <p> Updates the source code group with the specified information. </p> */
        patch: operations["patchSitesByIDSourceCodeGroupsByID"];
        trace?: never;
    };
    "/sites/{site_id}/store_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p>
         *      Searches for stores.
         *       </p>
         *       <p>
         *      The query attribute specifies a complex query that can be used to narrow down the search. This is the list of
         *      searchable attributes:
         *       </p>
         *       <ul>
         *       <li> address1 - String </li>
         *       <li> address2 - String </li>
         *       <li> city - String </li>
         *       <li> country_code - String </li>
         *       <li> email - String </li>
         *       <li> fax - String </li>
         *       <li> id - String </li>
         *       <li> inventory_id - String </li>
         *       <li> latitude - double </li>
         *       <li> longitude - double </li>
         *       <li> name - String </li>
         *       <li> phone - String </li>
         *       <li> postal_code - String </li>
         *       <li> state_code - String </li>
         *       <li> store_hours - String </li>
         *       <li> store_events - String </li>
         *       </ul>
         */
        post: operations["postSitesByIDStoreSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/stores": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the stores with no filtering. */
        get: operations["getSitesByIDStores"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sites/{site_id}/stores/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get store information. */
        get: operations["getSitesByIDStoresByID"];
        /** @description Creates a store using the information provided. */
        put: operations["putSitesByIDStoresByID"];
        post?: never;
        /** @description Deletes the store by ID */
        delete: operations["deleteSitesByIDStoresByID"];
        options?: never;
        head?: never;
        /** @description Updates the store with the specified information. */
        patch: operations["patchSitesByIDStoresByID"];
        trace?: never;
    };
    "/system_object_definition_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for system objects. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. These are the list
         *      of searchable attributes: </p>
         *       <ul>
         *       <li> object_type - String </li>
         *       <li> display_name - Localized &lt; String &gt; </li>
         *       <li> description - Localized &lt; String &gt; </li>
         *       <li> read_only - Boolean </li>
         *       </ul>
         *
         *       <p> The output of the query can also be sorted. These are the list of sortable attributes: </p>
         *       <ul>
         *       <li> object_type - String </li>
         *       <li> display_name - Localized &lt; String &gt; </li>
         *       <li> description - Localized &lt; String &gt; </li>
         *       <li> read_only - Boolean </li>
         *       </ul>
         */
        post: operations["postSystemObjectDefinitionSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system_object_definitions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the system objects with no filtering. */
        get: operations["getSystemObjectDefinitions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system_object_definitions/{object_type}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get system object information. */
        get: operations["getSystemObjectDefinitionsByID"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system_object_definitions/{object_type}/attribute_definition_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches the attribute definitions of the specified system object type. </p>
         *       <p/>
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. Attributes are grouped
         *      into different buckets.  These are the list of searchable attributes with their corresponding buckets: </p>
         *
         *       <p> Main: </p>
         *       <ul>
         *          <li> id - String </li>
         *          <li> display_name* - Localized String </li>
         *          <li> description* - Localized String </li>
         *          <li> key - boolean </li>
         *          <li> mandatory - boolean </li>
         *          <li> searchable - boolean </li>
         *          <li> system - boolean </li>
         *          <li> visible - boolean </li>
         *       </ul>
         *       <p> Definition version: </p>
         *       <ul>
         *          <li> localizable - boolean </li>
         *          <li> site_specific - boolean </li>
         *          <li> value_type - one of {string, int, double, text, html, date, image, boolean, money, quantity, datetime, email, password, set_of_string, set_of_int, set_of_double, enum_of_string, enum_of_int} </li>
         *       </ul>
         *       <p> Group: </p>
         *       <ul>
         *          <li> group - String </li>
         *       </ul>
         *
         *       <p> Only attributes in the same bucket can be joined using a disjunction (OR).
         *      For instance, when joining localizable and description above, only a conjunction is allowed (AND), whereas display_name
         *      and description can be joined using a disjunction because they are in the same bucket.  If an attribute
         *      is used in a disjunction (OR) that violates this rule, an exception will be thrown. </p>
         *
         *       <p> * These attributes are not searchable or sortable for built in system attributes.  They work normally for non
         *      system attributes. </p>
         *
         *       <p> Note that only searchable attributes can be used in sorting. </p>
         */
        post: operations["postSystemObjectDefinitionsByIDAttributeDefinitionSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system_object_definitions/{object_type}/attribute_definitions": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the attribute definitions with no filtering. */
        get: operations["getSystemObjectDefinitionsByIDAttributeDefinitions"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system_object_definitions/{object_type}/attribute_definitions/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get attribute definition information. */
        get: operations["getSystemObjectDefinitionsByIDAttributeDefinitionsByID"];
        /** @description Creates a attribute definition using the information provided. */
        put: operations["putSystemObjectDefinitionsByIDAttributeDefinitionsByID"];
        post?: never;
        /** @description Deletes the attribute definition by ID */
        delete: operations["deleteSystemObjectDefinitionsByIDAttributeDefinitionsByID"];
        options?: never;
        head?: never;
        /**
         * @description Updates the attribute definition with the specified information. The request must include the If-Match header, which holds
         *      the last known base-point information. The value of this header is an "ETag" representing the attribute definition state. If
         *      the request does not contain an If-Match header with the current server customer "ETag", a 409 (IfMatchRequiredException)
         *      fault is returned. If the If-Match header does not match the current server attribute definition "ETag", a 412 (InvalidIfMatchException)
         *      fault is returned.
         */
        patch: operations["patchSystemObjectDefinitionsByIDAttributeDefinitionsByID"];
        trace?: never;
    };
    "/system_object_definitions/{object_type}/attribute_group_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description <p> Searches for attribute groups. </p>
         *
         *       <p> The query attribute specifies a complex query that can be used to narrow down the search. These are the list
         *      of searchable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> display_name - Localized &lt; String &gt; </li>
         *       <li> description - Localized &lt; String &gt; </li>
         *       <li> position - Double </li>
         *       <li> internal - Boolean </li>
         *       </ul>
         *
         *       <p> The output of the query can also be sorted. These are the list of sortable attributes: </p>
         *       <ul>
         *       <li> id - String </li>
         *       <li> display_name - Localized &lt; String &gt; </li>
         *       <li> description - Localized &lt; String &gt; </li>
         *       <li> position - Double </li>
         *       <li> internal - Boolean </li>
         *       </ul>
         */
        post: operations["postSystemObjectDefinitionsByIDAttributeGroupSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system_object_definitions/{object_type}/attribute_groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all the attribute groups with no filtering. */
        get: operations["getSystemObjectDefinitionsByIDAttributeGroups"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system_object_definitions/{object_type}/attribute_groups/{group_id}/attribute_definitions/{def_id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Assign an attribute definition to an attribute group. */
        put: operations["putSystemObjectDefinitionsByIDAttributeGroupsByIDAttributeDefinitionsByID"];
        post?: never;
        /** @description Un-assign an attribute definition from an attribute group. */
        delete: operations["deleteSystemObjectDefinitionsByIDAttributeGroupsByIDAttributeDefinitionsByID"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/system_object_definitions/{object_type}/attribute_groups/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get attribute group information. */
        get: operations["getSystemObjectDefinitionsByIDAttributeGroupsByID"];
        /** @description Creates a attribute group using the information provided. If a attribute group with the same unique identifier, it will be deleted and a new one will be created unless the header x-dw-validate-existing=true is passed in with the request. */
        put: operations["putSystemObjectDefinitionsByIDAttributeGroupsByID"];
        post?: never;
        /** @description Deletes the attribute group by ID */
        delete: operations["deleteSystemObjectDefinitionsByIDAttributeGroupsByID"];
        options?: never;
        head?: never;
        /**
         * @description Updates the attribute group with the specified information. The request must include the If-Match header, which holds
         *      the last known base-point information. The value of this header is an "ETag" representing the attribute group state. If
         *      the request does not contain an If-Match header with the current server customer "ETag", a 409 (IfMatchRequiredException)
         *      fault is returned. If the If-Match header does not match the current server attribute group "ETag", a 412 (InvalidIfMatchException)
         *      fault is returned.
         */
        patch: operations["patchSystemObjectDefinitionsByIDAttributeGroupsByID"];
        trace?: never;
    };
    "/user_search": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * @description Searches for users.
         *       <p>
         *      The query attribute specifies a complex query that can be used to narrow down the search. These are the list
         *      of searchable attributes:
         *       </p>
         *       <ul>
         *       <li> login - String </li>
         *       <li> email - String </li>
         *       <li> first_name - String </li>
         *       <li> last_name - String </li>
         *       <li> external_id - String </li>
         *       <li> last_login_date - Date </li>
         *       <li> is_locked - Boolean </li>
         *       <li> is_disabled - Boolean </li>
         *       </ul>
         *
         *       <p> The output of the query can also be sorted. These are the list of sortable attributes: </p>
         *       <ul>
         *       <li> login - String </li>
         *       <li> email - String </li>
         *       <li> first_name - String </li>
         *       <li> last_name - String </li>
         *       <li> external_id - String </li>
         *       <li> last_login_date - Date </li>
         *       </ul>
         */
        post: operations["postUserSearch"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get all users with no filtering. */
        get: operations["getUsers"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/this": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get the user password expiration information. */
        get: operations["getUsersThis"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/users/this/password": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        /**
         * @description Action to change a local user password. This action cannot change the password for a user managed by Account
         *      Manager.
         */
        patch: operations["patchUsersThisPassword"];
        trace?: never;
    };
    "/users/{login}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Action to get a user. */
        get: operations["getUsersByID"];
        /**
         * @description Action to create or overwrite a user. <lines outputclass="pdfonly"/>
         *
         *      If a user with the given login already exists, the existing user will be overwritten.
         *      If no such login exists, a new user is created.
         */
        put: operations["putUsersByID"];
        post?: never;
        /** @description Action to delete a single user. */
        delete: operations["deleteUsersByID"];
        options?: never;
        head?: never;
        /**
         * @description <p> Action to update a user. </p> <lines outputclass="pdfonly"/>
         *
         *       <p> Note: The  <code> locked </code>  flag and the user  <code> password </code>  cannot be updated with this resource. </p>
         */
        patch: operations["patchUsersByID"];
        trace?: never;
    };
    "/users/{login}/access_key/{scope}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets a single access key. */
        get: operations["getUsersByIDAccessKeyByID"];
        /** @description Creates a single access key (and removes an existing one for the same scope). */
        put: operations["putUsersByIDAccessKeyByID"];
        post?: never;
        /** @description Deletes a single access key. */
        delete: operations["deleteUsersByIDAccessKeyByID"];
        options?: never;
        head?: never;
        /** @description Enables / disables a single access key. */
        patch: operations["patchUsersByIDAccessKeyByID"];
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        string: string;
        /** @description <p>The id of the A/B Test</p> */
        ab_test: {
            /** @description The list of customer group ids assigned to the A/B Test. Defaults to 'Everyone' if not specified on create */
            customer_groups?: string[];
            /** @description The optional description of the A/B Test */
            description?: string;
            /** @description The optional list of email addresses to send A/B Test results */
            email_addresses?: string[];
            /** @description The flag representing the enabled state of the A/B Test. Defaults to false if not specified on create */
            enabled?: boolean;
            /**
             * Format: date-time
             * @description The date that the A/B Test ends. Defaults to two weeks from creation date if both start and end dates are not specified on create
             */
            end_date?: string;
            /**
             * @description The participant expiration type of the A/B Test. Defaults to 'never' if not specified on create
             * @enum {string}
             */
            expiration_type?: "session" | "never";
            /** @description The id of the A/B Test */
            id?: string;
            /** @description The key metric that is most important to the A/B Test, among the metrics collected. Defaults to 'Revenue' if not specified from test participant activity */
            key_metric_id?: string;
            /** @description The URL to get the A/B test. This is a computed attribute and cannot be modified */
            link?: string;
            /** @description The flag representing the paused state of the A/B Test. Defaults to false if not specified on create */
            paused?: boolean;
            /**
             * Format: int32
             * @description Segment count of A/B test. This is a computed attribute and cannot be modified
             */
            segment_count?: number;
            /**
             * Format: date-time
             * @description The date that the A/B Test begins. Defaults to a week from creation date if both start and end dates are not specified on create
             */
            start_date?: string;
            /**
             * @description Status of A/B test. This is a computed attribute and cannot be modified
             * @enum {string}
             */
            status?: "ended" | "planned" | "running";
            /** @description The optional list of tags to group similar A/B Tests so that they can be searched easily. */
            tags?: string[];
            /** @description Test Groups created for an A/B Test. This is a read only attribute for now. */
            test_groups?: components["schemas"]["ab_test_group"][];
            /** @description Test Segments created for an A/B Test. This is a read only attribute for now */
            test_segments?: components["schemas"]["ab_test_segment"][];
            trigger?: components["schemas"]["ab_test_trigger"];
        };
        /** @description <p>Document representing an A/B Test Group</p> */
        ab_test_group: {
            /**
             * Format: int32
             * @description Test Group percentage allocation
             */
            allocation?: number;
            /** @description Flag to determine if this Test Group is a customer experience */
            custom_experience?: boolean;
            /** @description Test Group description */
            description?: string;
            /** @description Test group id */
            id?: string;
        };
        /** @description <p>Request document containing a search response for A/B test</p> */
        ab_test_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: Record<string, never>[];
            /** Format: int32 */
            db_start_record_?: number;
            expand?: string[];
            /** @description The search hits returned as an ordered list */
            hits?: components["schemas"]["ab_test"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The fields that you want to select. */
            select?: string;
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing an A/B Test Segment</p> */
        ab_test_segment: {
            /**
             * Format: int32
             * @description Test Group percentage allocation
             */
            allocation?: number;
            /** @description Flag to determine if this Test Group is a customer experience */
            custom_experience?: boolean;
            /** @description Test Group description */
            description?: string;
            /** @description Test group id */
            id?: string;
            link?: string;
            /** @description Promotions which this segment has as experiences */
            promotions?: Record<string, never>[];
            /** @description Slot configurations which this segment has as experiences */
            slot_configs?: Record<string, never>[];
            /** @description Sorting rules which this segment has as experiences */
            sorting_rules?: Record<string, never>[];
            stats?: components["schemas"]["ab_test_segment_stats"];
        };
        ab_test_segment_stats: {
            /** Format: int32 */
            adds_to_baskets?: number;
            /** Format: double */
            average_adds_per_basket?: number;
            /** Format: double */
            average_adds_per_basket_std_error?: number;
            /** Format: double */
            average_discount_amount?: number;
            /** Format: double */
            average_discount_amount_std_error?: number;
            /** Format: double */
            average_discount_amount_with_coupon?: number;
            /** Format: double */
            average_discount_amount_with_coupon_std_error?: number;
            /**
             * Format: double
             * @description The standard error for the average amount discounted for orders without using a coupon
             */
            average_discount_amount_without_coupon?: number;
            /**
             * Format: double
             * @description Units sold per hour
             */
            average_discount_amount_without_coupon_std_error?: number;
            /** Format: double */
            average_order_value?: number;
            /** Format: double */
            average_order_value_std_error?: number;
            /** Format: double */
            average_revenue_per_visit?: number;
            /** Format: double */
            average_revenue_per_visit_std_error?: number;
            /** Format: double */
            average_units_added_per_basket?: number;
            /** Format: double */
            average_units_adder_per_basket_std_error?: number;
            /** Format: double */
            average_units_per_order_std_error?: number;
            /** Format: double */
            average_units_per_visit?: number;
            /** Format: double */
            average_units_per_visit_std_error?: number;
            /** Format: double */
            basket_rate?: number;
            /** Format: double */
            baskets?: number;
            /** Format: double */
            checkout_rate?: number;
            /** Format: int32 */
            checkouts?: number;
            /** Format: double */
            conversion_rate?: number;
            /** Format: double */
            discount_amount_with_coupon?: number;
            /** Format: double */
            discount_amount_without_coupon?: number;
            /** Format: int32 */
            orders?: number;
            /** Format: double */
            revenue?: number;
            /** Format: double */
            total_discount_amount?: number;
            /** Format: double */
            units?: number;
            /** Format: double */
            units_added_to_baskets?: number;
            /** Format: int32 */
            visitors?: number;
            /** Format: int32 */
            visits?: number;
        };
        /** @description <p>Document representing an A/B Test trigger.</p> */
        ab_test_trigger: {
            /** @description The list of categories. This is a modifiable attribute when trigger type is 'category_page_view' only */
            categories?: string[];
            /** @description The flag indicating if the trigger is based on pipelines. This is a computed attribute and cannot be modified */
            is_pipeline_based?: boolean;
            /** @description The list of pipeline name and start node combinations (for example, Account-Show). This is a modifiable attribute when trigger type is 'pipeline_calls' only */
            pipeline_calls?: string[];
            /**
             * @description The type of the trigger. Defaults to 'immediately' if not specified on create
             * @enum {string}
             */
            trigger_type?: "immediately" | "category_page_view" | "home_page_view" | "pipeline_call";
        };
        /** @description <p>Request document containing a set of ABTests</p> */
        ab_tests: {
            /** Format: int32 */
            count?: number;
            data?: components["schemas"]["ab_test"][];
            expand?: string[];
            next?: string;
            previous?: string;
            select?: string;
            /** Format: int32 */
            start?: number;
            /** Format: int32 */
            total?: number;
        };
        /** @description <p>Access key information</p> */
        access_key_details: {
            /** @description The newly created access key (only available upon access key creation, missing otherwise). */
            access_key?: string;
            /** @description True when the access key is enabled. */
            enabled?: boolean;
            /**
             * Format: date-time
             * @description The date when the access key expires.
             */
            expiration_date?: string;
        };
        /** @description <p>Request body to enable / disable an access key.</p> */
        access_key_update_request: {
            /** @description True when the access key should be enabled. */
            enabled?: boolean;
        };
        /** @description <p>Document representing an account transaction</p> */
        account_transaction: {
            amount?: components["schemas"]["money"];
            /** @description The order number of the gift certificate */
            order_no?: string;
            /**
             * Format: date-time
             * @description The timestamp of the transaction of the gift certificate
             */
            timestamp?: string;
            /**
             * @description The type code of the gift certificate
             * @enum {string}
             */
            type_code?: "create" | "redeem" | "delete" | "enable" | "disable";
        };
        /** @description <p>Document describing a single alert descriptor.</p> */
        alert_descriptor: {
            /** @description The application context path. */
            application_context_path?: string;
            /** @description The application ID. */
            application_id?: string;
            /** @description The context object type. */
            context_object_type?: string;
            /**
             * @description The default priority.
             * @enum {string}
             */
            default_priority?: "not_allowed" | "hidden" | "informational" | "warning" | "action_required";
            /** @description URL for this resource. */
            link?: string;
            /** @description The message ID. */
            message_id?: string;
        };
        /** @description <p>Document describing settings for a single alert descriptor.</p> */
        alert_descriptor_settings: {
            /** @description The application context path. */
            application_context_path: string;
            /** @description The application ID. */
            application_id: string;
            /** @description <p>Flag that indicates whether the settings for this descriptor have been changed by the user.</p> <p>In a PATCH request, this flag must be set to <code>true</code> to override the default settings. If this flag to <code>false</code> in a PATCH request, the default user settings for this descriptor are restored (and all other fields are ignored).</p> */
            is_user_override: boolean;
            /** @description The message ID. */
            message_id: string;
            /**
             * @description The user priority.
             * @enum {string}
             */
            priority: "hidden" | "informational" | "warning" | "action_required";
            /** @description Flag that indicates whether the alert is shown in the Business Manager header. */
            show_in_header: boolean;
            /** @description Flag that indicates whether the alert is shown on the Business Manager banner (on every page). */
            show_on_banner?: boolean;
            /** @description Flag that indicates whether the alert is shown on the Business Manager homepage. */
            show_on_homepage: boolean;
        };
        /** @description <p>Document containing a collection of alert descriptors.</p> */
        alert_descriptors: {
            /** @description Collection of alert descriptors */
            data?: components["schemas"]["alert_descriptor"][];
        };
        /** @description <p>Contains parameters for a alert descriptor revalidation request.</p> */
        alert_descriptors_revalidation_request: {
            /** @description ID of the object in which context messages should be revalidated. */
            context_object_id?: string;
        };
        /** @description <p>Document containing the alert settings of a user.</p> */
        alert_settings: {
            /** @description Alert settings. */
            settings?: components["schemas"]["alert_descriptor_settings"][];
        };
        /** @description <p>Document representing the available applications for retrieving permissions.</p> */
        application_permissions: {
            /** @description The available applications (e.g. 'bm' for Business Manager). */
            applications?: string[];
            bm?: components["schemas"]["bmpermissions"];
            csc?: components["schemas"]["cscpermissions"];
        };
        bmpermissions: {
            functional?: components["schemas"]["functional_permissions"];
            functional_link?: string;
            locale?: components["schemas"]["locale_permissions"];
            locale_link?: string;
            module?: components["schemas"]["module_permissions"];
            module_link?: string;
            types?: string[];
            webdav?: components["schemas"]["webdav_permissions"];
            webdav_link?: string;
        };
        /**
         * @description <p>Document representing a boolean filter.
         *
         *      A boolean filter allows you to combine other filters into (possibly recursive) logical expression trees. A boolean filter
         *      is configured with a boolean operator (AND, OR, NOT) and a list of filters the operator relates to. If multiple
         *      filters are given to a boolean NOT operator, this is interpreted as a NOT upon a boolean OR of the given filters.
         *
         *       <b> Example: </b>  (id="myId" AND coupon_id="couponOne")
         *        <pre>
         *       query: {
         *          filtered_query: {
         *              query: { match_all_query: {} },
         *              filter: {
         *                  bool_filter: {
         *                      operator: "and",
         *                      filters: [
         *                          { term_filter: { field: "id", operator: "is", values: ["myId"] } },
         *                          { term_filter: { field: "coupon_id", operator: "is", values: ["couponOne"] } }
         *                      ]
         *                  }
         *              }
         *          }
         *       }
         *        </pre>
         *        <b> Example: </b>  (id="holidaySale" OR redemption_count BETWEEN(1, 20)
         *        <pre>
         *          query: {
         *              filtered_query: {
         *                  query: { match_all_query: {} },
         *                  filter: {
         *                      bool_filter: {
         *                      operator: "or",
         *                      filters: [
         *                          { term_filter: { field: "id", operator: "is", values: ["holidaySale"] } },
         *                          { range_filter: { field: "redemption_count", from: 1, to: 20 } }
         *                      ]
         *                  }
         *              }
         *          }
         *       }
         *        </pre>
         *        <b> Example: </b>  NOT(enabled=false OR coupon_id="special")
         *        <pre>
         *          query: {
         *              filtered_query: {
         *                  query: { match_all_query: {} },
         *                  filter: {
         *                      bool_filter: {
         *                      operator: "not",
         *                      filters: [
         *                          { term_filter: { field: "enabled", operator: "is", values: [false] } },
         *                          { term_filter: { field: "coupon_id", operator: "is", values: ["special"] } }
         *                      ]
         *                  }
         *              }
         *          }
         *       }
         *        </pre></p>
         */
        bool_filter: {
            /** @description A list of filters, which are logically combined by an operator. */
            filters?: components["schemas"]["filter"][];
            /**
             * @description The logical operator the filters are combined with.
             * @enum {string}
             */
            operator: "and" | "or" | "not";
        };
        /**
         * @description <p>A boolean query allows construction of full logical expression trees consisting of other queries (usually term and text
         *     queries). A boolean query basically has 3 sets of clauses that 'must', 'should' and / or 'must not' match.  If 'must',
         *     'must_not', or 'should' appear in the same boolean query, they are combined logically using the AND operator.
         *     The difference between must and should operators is that the must operator requires all subqueries to match whereas the should operator only requires one match
         *
         *      <b> Example: </b>  (id = 'foo' AND description LIKE 'bar')
         *      <pre>
         *        query: {
         *            bool_query: {
         *                must: [
         *                    { term_query: { fields: ["id"], operator: "is", values: ["foo"] } },
         *                    { text_query: { fields: ["description"], search_phrase: "bar" } }
         *                ]
         *            }
         *        }
         *      </pre>
         *
         *      <b> Example: </b>  (id = 'foo' OR description LIKE 'bar')
         *      <pre>
         *        query: {
         *            bool_query: {
         *                should: [
         *                    { term_query: { fields: ["id"], operator: "is", values: ["foo"] } },
         *                    { text_query: { fields: ["description"], search_phrase: "bar" } }
         *                ]
         *            }
         *        }
         *      </pre>
         *
         *      <b> Example: </b>  (NOT (id = 'foo' AND description LIKE 'bar'))
         *      <pre>
         *        query: {
         *            bool_query: {
         *                must_not: [
         *                    { term_query: { fields: ["id"], operator: "is", values: ["foo"] } },
         *                    { text_query: { fields: ["description"], search_phrase: "bar" } }
         *                ]
         *            }
         *        }
         *      </pre>
         *
         *      <b> Example: </b>  ((coupon_id LIKE "limit" AND description LIKE "limit per customer") AND NOT (enabled=false))
         *      <pre>
         *        query: {
         *            bool_query: {
         *                must: [
         *                    { text_query: { fields: [ "coupon_id" ], search_phrase: "limit" } },
         *                    { text_query: { fields: [ "description" ], search_phrase: "limit per customer" } }
         *                ],
         *                must_not: [
         *                    { term_query: { fields: [ "enabled" ], operator: "is", values: [false] } }
         *                ]
         *            }
         *        }
         *      </pre></p>
         */
        bool_query: {
            /** @description List of queries that must match. */
            must?: components["schemas"]["query"][];
            /** @description List of queries that must not match. */
            must_not?: components["schemas"]["query"][];
            /** @description List of queries that should match (i.e., at least one query must match). */
            should?: components["schemas"]["query"][];
        };
        /** @description <p>Document representing a campaign.</p> */
        campaign: {
            /** @description The ID of the campaign. */
            campaign_id?: string;
            /** @description The array of assigned coupon IDs, not sorted */
            coupons?: string[];
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            /** @description The array of assigned customer groups, not sorted */
            customer_groups?: string[];
            /**
             * Format: text
             * @description The description of the campaign.
             */
            description?: string;
            /** @description The enabled flag for campaign. */
            enabled?: boolean;
            /**
             * Format: date-time
             * @description The date that the Scenario ends
             */
            end_date?: string;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /** @description link for convenience */
            link?: string;
            /** @description The array of assigned source code groups, not sorted */
            source_code_groups?: string[];
            /**
             * Format: date-time
             * @description The date that the Scenario begins
             */
            start_date?: string;
        };
        /** @description <p>Document representing a campaign search result.</p> */
        campaign_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["campaign"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of campaigns.</p> */
        campaigns: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["campaign"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Request body for post operation</p> */
        cartridge_path_add_request: {
            /** @description Name of the cartridge. */
            name: string;
            /**
             * @description Position of the cartridge.
             * @enum {string}
             */
            position: "first" | "last" | "before" | "after";
            /** @description When position is 'before' or 'after', need to specify the target cartridge */
            target?: string;
        };
        /** @description <p>Response of cartridge path related operation</p> */
        cartridge_path_api_response: {
            /** @description Updated cartridge path */
            cartridges?: string;
            /** @description Site id */
            site_id?: string;
        };
        /** @description <p>Request Body for put operation</p> */
        cartridge_path_create_request: {
            /** @description New cartridge path */
            cartridges: string;
        };
        /** @description <p>Document representing a catalog</p> */
        catalog: {
            /**
             * Format: int32
             * @description The count of products assigned to the catalog. It is read only.
             */
            assigned_product_count?: number;
            /** @description The sites assigned to the catalog. It is read only. */
            assigned_sites?: components["schemas"]["site"][];
            /**
             * Format: int32
             * @description The category count of catalog. It is read only.
             */
            category_count?: number;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            /**
             * Format: localized
             * @description The description of catalog
             */
            description?: {
                [key: string]: string;
            };
            /** @description The catalog Id */
            id?: string;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /** @description URL that is used to get this instance. It is read only. */
            link?: string;
            /**
             * Format: localized
             * @description The catalog name
             */
            name?: {
                [key: string]: string;
            };
            /** @description The online status of catalog */
            online?: boolean;
            /**
             * Format: int32
             * @description The count of products owned by the catalog. It is read only.
             */
            owned_product_count?: number;
            /**
             * Format: int32
             * @description The recommendation count of the catalog. It is read only.
             */
            recommendation_count?: number;
            /** @description The root category of the catalog.  It is read only */
            root_category?: string;
        };
        /** @description <p>Document representing a catalog category id.</p> */
        catalog_category_id: {
            /** @description The id of the catalog that owns the category. */
            catalog_id?: string;
            /** @description The id of the category. */
            category_id?: string;
        };
        /** @description <p>Document representing a catalog search result.</p> */
        catalog_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["catalog"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of catalogs.</p> */
        catalogs: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            /** @description The collection of catalogs. */
            data?: components["schemas"]["catalog"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of categories.</p> */
        categories: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["category"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a category.</p> */
        category: {
            c_alternativeUrl?: components["schemas"]["markup_text"];
            /** @description Used to define the content asset used to populate a grid page banner for a category. This value is applied to all sub-category navigation (cascading) if no specific catBannerID has been defined for  a sub-category. */
            c_catBannerID?: string;
            c_customCSSFile?: components["schemas"]["media_file"];
            /** @description Used to define if/when the Compare feature is to be visualized in the storefront based on navigation. If enableCompare = FALSE, no Compare checkboxes will be displayed in the grid view. If enableCompare = TRUE, the category (and its children) will support the Compare feature. */
            c_enableCompare?: boolean;
            c_headerMenuBanner?: components["schemas"]["markup_text"];
            /**
             * @description Which way to orient the menu and optional header menu HTML. Vertical will list all in one line. Horizontal will list in columns.
             * @enum {string}
             */
            c_headerMenuOrientation?: "Horizontal" | "Vertical";
            /** @description Used to indicate that a category (such as Mens -> Footwear -> Boots) will display in the roll-over navigation. A sub-category only shows if also the parent category is marked as showInMenu. Up to three category levels are shown in roll-over navigation. */
            c_showInMenu?: boolean;
            /** @description Used to define the content asset ID of the Size Chart that is appropriate for products whose PRIMARY category is the associated category (and its children). Whenever a product detail page (or quick view) is rendered, the Size Chart link is populated based on the value of this attribute for the products primary categorization. If not defined, NO size chart link is displayed. */
            c_sizeChartID?: string;
            /** Format: localized */
            c_slotBannerHtml?: {
                [key: string]: components["schemas"]["markup_text"];
            };
            c_slotBannerImage?: components["schemas"]["media_file"];
            /** @description The id of the catalog that contains it. */
            catalog_id?: string;
            /** @description The array of sub categories for the category. */
            categories?: components["schemas"]["category"][];
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            /**
             * Format: localized
             * @description The localized description of the category.
             */
            description?: {
                [key: string]: string;
            };
            /** @description The id of the category. */
            id?: string;
            /** @description The name of the category image. The URL to the image is computed. */
            image?: string;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /** @description The URL to get the category. This is a computed attribute and cannot be modified. */
            link?: string;
            /**
             * Format: localized
             * @description The localized name of the category.
             */
            name?: {
                [key: string]: string;
            };
            /** @description The online status of the category determines if it is visible in the storefront. Defaults to false if not specified on create. */
            online?: boolean;
            /**
             * Format: localized
             * @description The localized page description of the category.
             */
            page_description?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The localized page keywords for the category.
             */
            page_keywords?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The localized page title of the category.
             */
            page_title?: {
                [key: string]: string;
            };
            /** @description The id of the parent category. Defaults to root if not specified on create. */
            parent_category_id?: string;
            paths?: components["schemas"]["path_record"][];
            /**
             * Format: double
             * @description The position of the category determines the display order in the storefront.
             */
            position?: number;
            sorting_rules?: components["schemas"]["sorting_rule"][];
            /** @description The name of the category thumbnail. The URL to the thumbnail is computed. */
            thumbnail?: string;
        };
        /** @description <p>Document representing a category link</p> */
        category_link: {
            /**
             * Format: date-time
             * @description The date the link was last modified
             */
            last_modified?: string;
            /** @description URL that is used to get this instance */
            link?: string;
            /**
             * Format: double
             * @description The position in the source catalog / category for this link relative to the other links in the same category.
             */
            position?: number;
            /** @description The source catalog for the link */
            source_catalog_id?: string;
            /**
             * Format: localized
             * @description The name of the source catalog
             */
            source_catalog_name?: {
                [key: string]: string;
            };
            /** @description The source category for the link */
            source_category_id?: string;
            /**
             * Format: localized
             * @description The name of the source category
             */
            source_category_name?: {
                [key: string]: string;
            };
            /** @description The target category for the link */
            target_catalog_id?: string;
            /**
             * Format: localized
             * @description The name of the target catalog
             */
            target_catalog_name?: {
                [key: string]: string;
            };
            /** @description The target category for the link */
            target_category_id?: string;
            /**
             * Format: localized
             * @description The name of the target category
             */
            target_category_name?: {
                [key: string]: string;
            };
            /**
             * @description The link type
             * @enum {string}
             */
            type?: "other" | "accessories" | "cross_selling" | "up_selling" | "spare_parts";
        };
        /** @description <p>Document representing an unfiltered list of category links.</p> */
        category_links: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["category_link"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a category product assignment.</p> */
        category_product_assignment: {
            /** @description The id of the catalog. */
            catalog_id?: string;
            /** @description The id of the category. */
            category_id?: string;
            /** Format: date-time */
            creation_date?: string;
            /** Format: date-time */
            last_modified?: string;
            /** @description The URL used to get the product category assignment. */
            link?: string;
            /**
             * Format: localized
             * @description The name of the catalog that owns the product.
             */
            owning_catalog_name?: {
                [key: string]: string;
            };
            /**
             * Format: double
             * @description The position of product category assignment.
             */
            position?: number;
            product?: components["schemas"]["product"];
            /** @description The id of the Product. */
            product_id?: string;
            /**
             * Format: localized
             * @description The name of the product.
             */
            product_name?: {
                [key: string]: string;
            };
        };
        /** @description <p>Document representing product_search_request</p> */
        category_product_assignment_search_request: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /**
             * @description The list of expansions that can be applied:
             *      <ul>
             *      <li><p>product_base - String - This expand will enable retrieval of the following basic <b>Product</b> information:</p>
             *      	<ul>
             *      		<li>brand</li>
             *         	<li>ean</li>
             *           <li>link</li>
             *       	<li>long_description</li>
             *           <li>manufacturer_name</li>
             *           <li>manufacturer_sku</li>
             *      		<li>name</li>
             *           <li>page_description</li>
             *           <li>page_keywords</li>
             *           <li>page_title</li>
             *           <li>searchable</li>
             *        	<li>short_description</li>
             *           <li>type</li>
             *           <li>unit</li>
             *          	<li>upc</li>
             *      	</ul></li>
             *      </ul>
             */
            expand?: string[];
            query: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
        };
        /** @description <p>Document representing a product search result.</p> */
        category_product_assignment_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. This array can be empty. */
            hits?: components["schemas"]["category_product_assignment"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing a catalog search result.</p> */
        category_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["category"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing a code version</p> */
        code_version: {
            /**
             * Format: date-time
             * @description The code version activation time.
             */
            activation_time?: string;
            /** @description Use this method to determine, if this code version is currently active. */
            active?: boolean;
            /** @description A list containing the names of all cartridges participating in this code version. */
            cartridges?: string[];
            /** @description The code version compatibility mode. */
            compatibility_mode?: string;
            /** @description The code version id. */
            id?: string;
            /**
             * Format: date-time
             * @description The last time, when the code version was changed.
             */
            last_modification_time?: string;
            /** @description Use this method to determine, if this code version is the current rollback version. */
            rollback?: boolean;
            /**
             * Format: int64
             * @description Returns the total size of the file system content of this code version in bytes.
             */
            total_size?: number;
            /** @description Returns the HTTPS based WebDAV URL that can be used to access the code version resources. */
            web_dav_url?: string;
        };
        /** @description <p>Result document containing an array of code versions.</p> */
        code_version_result: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            /** @description The array of code versions */
            data?: components["schemas"]["code_version"][];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a content asset.</p> */
        content_asset: {
            c_Year?: string;
            /** Format: localized */
            c_body?: {
                [key: string]: components["schemas"]["markup_text"];
            };
            c_customCSSFile?: components["schemas"]["media_file"];
            /** @description The ID of the classification folder. It is only part of the response, if the assignment from  this content asset to the folder is marked as 'default'. The property is read-only. To  set the classification folder just create/update an assignment between this content asset and  a folder and mark it as 'default'. See details in  /libraries/{library_id}/folder_assignments/{content_id}/{folder_id} resource. */
            classification_folder_id?: string;
            /** @description The link to the classification folder. It is only part of the response, if the assignment from  this content asset to the folder is marked as 'default'. The property is read-only. To  set the classification folder just create/update an assignment between this content asset and  a folder and mark it as 'default'. See details in  /libraries/{library_id}/folder_assignments/{content_id}/{folder_id} resource. */
            classification_folder_link?: string;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            /**
             * Format: localized
             * @description The localized content asset description.
             */
            description?: {
                [key: string]: string;
            };
            /** @description The id of the content asset. */
            id?: string;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /** @description The link to the content asset resource. */
            link?: string;
            /**
             * Format: localized
             * @description The localized content asset name.
             */
            name?: {
                [key: string]: string;
            };
            /**
             * Format: site-specific
             * @description Is the asset online?
             */
            online?: {
                [key: string]: boolean;
            };
            /**
             * Format: localized
             * @description The localized content asset page description.
             */
            page_description?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The localized content asset page keywords.
             */
            page_keywords?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The localized content asset page title.
             */
            page_title?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The localized content asset page url.
             */
            page_url?: {
                [key: string]: string;
            };
            /**
             * Format: site-specific
             * @description Is the asset searchable?
             */
            searchable?: {
                [key: string]: boolean;
            };
            /**
             * Format: site-specific
             * @description The content assets change frequency needed for the sitemap creation  (always, hourly, daily, weekly, monthly, yearly, never).
             */
            site_map_change_frequency?: {
                [key: string]: "always" | "daily" | "hourly" | "monthly" | "never" | "weekly" | "yearly";
            };
            /**
             * Format: site-specific
             * @description The status if the content asset is included into the sitemap (either 0 or  1).
             */
            site_map_included?: {
                [key: string]: 0 | 1;
            };
            /**
             * Format: site-specific
             * @description The content assets priority needed for the sitemap creation (0.0 for no  priority defined).
             */
            site_map_priority?: {
                [key: string]: number;
            };
            /** @description The rendering template. */
            template?: string;
        };
        /** @description <p>Result document containing an array of content assets.</p> */
        content_asset_result: {
            /**
             * Format: int32
             * @description The number of search results in the current page.
             */
            count?: number;
            /** @description The returned objects. */
            data?: Record<string, never>[];
            /** @description The sorted array of search hits. This array can be empty. */
            hits?: components["schemas"]["content_asset"][];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search result to include in the document.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of search results.
             */
            total?: number;
        };
        /** @description <p>Document representing a content folder.</p> */
        content_folder: {
            c_customCSSFile?: components["schemas"]["media_file"];
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            /**
             * Format: localized
             * @description The localized content folder description.
             */
            description?: {
                [key: string]: string;
            };
            /** @description The id of the content folder. */
            id?: string;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /** @description The link to the content folder resource. */
            link?: string;
            /**
             * Format: localized
             * @description The localized content folder name.
             */
            name?: {
                [key: string]: string;
            };
            /** @description A flag indicating whether the folder in online (default is false). */
            online?: boolean;
            /**
             * Format: localized
             * @description The localized content folder page description.
             */
            page_description?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The localized content folder page keywords.
             */
            page_keywords?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The localized content folder page title.
             */
            page_title?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The localized content folder page URL.
             */
            page_url?: {
                [key: string]: string;
            };
            /** @description The id of the parent content folder. */
            parent_folder_id?: string;
            /** @description The URL to the parent content folder. */
            parent_link?: string;
            /** @description The URL to list the content sub-folders. */
            sub_folders_link?: string;
            /** @description The rendering template. */
            template?: string;
        };
        /** @description <p>Document representing a content folder assignment.</p> */
        content_folder_assignment: {
            /** @description A flag indicating whether the assignment is the default one. */
            200?: boolean;
            /** @description The content id. */
            content_id?: string;
            /** @description The content link. */
            content_link?: string;
            /** @description The folder id. */
            folder_id?: string;
            /** @description The folder link. */
            folder_link?: string;
            /**
             * Format: double
             * @description The position of the content asset in the folder.
             */
            position?: number;
        };
        /** @description <p>Result document containing an array of content folders.</p> */
        content_folder_result: {
            /**
             * Format: int32
             * @description The number of search results in the current page.
             */
            count?: number;
            /** @description The returned objects. */
            data?: Record<string, never>[];
            /** @description The sorted array of search hits. This array can be empty. */
            hits?: components["schemas"]["content_folder"][];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search result to include in the document.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of search results.
             */
            total?: number;
        };
        /** @description <p>Result document containing an array of content subfolders.</p> */
        content_sub_folder_result: {
            /**
             * Format: int32
             * @description The number of search results in the current page.
             */
            count?: number;
            /** @description The returned objects. */
            data?: Record<string, never>[];
            /** @description The sorted array of search hits. This array can be empty. */
            hits?: components["schemas"]["content_folder"][];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search result to include in the document.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of search results.
             */
            total?: number;
        };
        /** @description <p>Document representing a coupon.</p> */
        coupon: {
            /**
             * @description <code>True</code> if a coupon is case insensitive; <code>false</code> otherwise. This attribute on the coupon can not be
             *      modified after the coupon has been created. If an attempt was made to modify this the system would return
             *      CouponUpdateForbiddenException
             */
            case_insensitive?: boolean;
            /** @description The id of the coupon. */
            readonly coupon_id?: string;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            /** @description The description of the coupon. */
            description?: string;
            /** @description A flag indicating whether the coupon is enabled. */
            enabled?: boolean;
            /**
             * Format: int32
             * @description The number of coupon codes attached to the coupon that have been issued (request search only).
             */
            exported_code_count?: number;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /** @description A link to the coupon. */
            link?: string;
            /**
             * @description <code>True</code> if a coupon with multiple codes can have different codes used on the same basket or order. If the coupon
             *      type does not support this configuration, this will return <code>false</code>.
             */
            multiple_codes_per_basket?: boolean;
            /**
             * Format: int32
             * @description The number of times the coupon has been redeemed (request search only).
             */
            redemption_count?: number;
            redemption_limits?: components["schemas"]["redemption_limits"];
            /** @description Single coupon code, only valid for Single Code type */
            single_code?: string;
            system_codes_config?: components["schemas"]["coupon_system_code_config"];
            /**
             * Format: int32
             * @description The total number of coupon codes associated with this coupon
             */
            total_codes_count?: number;
            /**
             * @description The type of the coupon code.
             * @enum {string}
             */
            readonly type?: "single_code" | "multiple_codes" | "system_codes";
        };
        /** @description <p>A coupon code with accompanying stats for redemptions and issued.</p> */
        coupon_code: {
            /** @description The code used to redeem the coupon */
            code?: string;
            /** @description Flag indicating if the coupon code has been issued */
            issued?: boolean;
            /**
             * Format: int32
             * @description The count of the number of redemptions associated with the code
             */
            redemption_count?: number;
        };
        /** @description <p>Document representing a set of coupon codes.</p> */
        coupon_codes: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            /** @description The collection of coupon codes */
            data?: components["schemas"]["coupon_code"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>A request object to add and remove coupon codes from a document</p> */
        coupon_multi_codes_request: {
            /** @description The list of coupon codes to add or delete */
            codes: string[];
        };
        /** @description <p>A redemption record returned from the coupon redemption resources</p> */
        coupon_redemption: {
            /** @description The coupon code that was redeemed */
            code?: string;
            /** @description The coupon id that was redeemed */
            coupon_id?: string;
            /** Format: date-time */
            creation_date?: string;
            /** @description The customer email that was used to redeem it */
            customer_email?: string;
            /** Format: date-time */
            last_modified?: string;
            /** @description The order number where the redemption occurred */
            order_no?: string;
            /** @description A URL able to access the order */
            view_order_url?: string;
        };
        /** @description <p>The result of the coupon redemption search</p> */
        coupon_redemption_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The hits from the search */
            hits?: components["schemas"]["coupon_redemption"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing a coupon search result.</p> */
        coupon_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["coupon"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        coupon_system_code_config: {
            /** @description The code prefix for system-generated coupon codes. */
            code_prefix?: string;
            /**
             * Format: int32
             * @description The number of system coupon codes that can be issued.
             */
            number_of_codes?: number;
        };
        /** @description <p>Document representing an unfiltered list of coupons.</p> */
        coupons: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["coupon"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing the credentials of a customer.</p> */
        credentials: {
            /** @description A flag indicating whether the customer is enabled and can log. */
            enabled?: boolean;
            /** @description A flag indicating whether the customer account is locked. */
            locked?: boolean;
            /** @description The login of the customer. */
            login: string;
            /** @description The password question. */
            password_question?: string;
        };
        cscpermissions: {
            module?: components["schemas"]["module_permissions"];
            module_link?: string;
            types?: string[];
        };
        /** @description <p>Document representing custom logging settings.</p> */
        custom_log_settings: {
            /** @description False if the current instance is production. */
            debug_permitted?: boolean;
            /** @description Indicates if custom debug logs are written to file. */
            debug_to_file?: boolean;
            /** @description Email addresses for fatal log messages with a maximum length of 1000 characters. */
            email_to?: string;
            /** @description Indicates if custom error logs are written to file. */
            error_to_file?: boolean;
            /** @description Indicates if custom fatal logs are written to file. */
            fatal_to_file?: boolean;
            /** @description Indicates if custom info logs are written to file. */
            info_to_file?: boolean;
            /** @description Defined custom log categories. */
            log_categories?: components["schemas"]["log_category"][];
            /** @description Custom root category log level. */
            root_level?: string;
            /** @description Indicates if custom warn logs are written to file. */
            warn_to_file?: boolean;
        };
        /** @description <p>Document representing a custom object that contains all defined custom attributes for its object type.</p> */
        custom_object: {
            /** @description The name of the key property for the custom object. This is ignored in input documents. */
            key_property?: string;
            /**
             * Format: int32
             * @description The id of the custom object when the type of the key is Integer. This is ignored in input documents.
             */
            key_value_integer?: number;
            /** @description The id of the custom object when the type of the key is String. This is ignored in input documents. */
            key_value_string?: string;
            /** @description The id of the object type. This is ignored in input documents. */
            object_type?: string;
        };
        /** @description <p>Document representing a custom object search result.</p> */
        custom_object_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. May be empty. */
            hits?: components["schemas"]["custom_object"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing a customer.</p> */
        customer: {
            /**
             * Format: date
             * @description The customer's birthday.
             */
            birthday?: string;
            c_familyStatus?: string;
            /** @description The customer's company name. */
            company_name?: string;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            credentials?: components["schemas"]["credentials"];
            /**
             * @description The customer's id. Both registered and guest customers have a
             *      customer id.
             */
            customer_id?: string;
            /** @description The customer's number. */
            customer_no?: string;
            /**
             * Format: email
             * @description The customer's email address.
             */
            email?: string;
            /**
             * @description The fax number to use for the customer.
             *      The length is restricted to 32 characters.
             */
            fax?: string;
            /** @description The customer's first name. */
            first_name?: string;
            /**
             * Format: int32
             * @description The customer's gender.
             * @enum {integer}
             */
            gender?: 1 | 2;
            /** @description The Global Party ID is set by Customer 360 and identifies a person across multiple systems. */
            global_party_id?: string;
            /** @description The customer's job title. */
            job_title?: string;
            /**
             * Format: date-time
             * @description The last login time of the customer.
             */
            readonly last_login_time?: string;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /** @description The customer's last name. */
            last_name?: string;
            /**
             * Format: date-time
             * @description The last visit time of the customer.
             */
            readonly last_visit_time?: string;
            /** @description The customer's business phone number. */
            phone_business?: string;
            /** @description The customer's home phone number. */
            phone_home?: string;
            /** @description The customer's mobile phone number. */
            phone_mobile?: string;
            /**
             * @description The customer's preferred locale, formatted with a hyphen. (For example: en-US)
             *      If the request uses an underscore, as with the Java locale format, the stored value is converted to a hyphen.
             *      (For example: en_US is stored as en-US)
             */
            readonly preferred_locale?: string;
            /**
             * Format: date-time
             * @description The time when the customer logged in previously.
             */
            previous_login_time?: string;
            /**
             * Format: date-time
             * @description The time when the customer previously visited the store.
             */
            previous_visit_time?: string;
            primary_address?: components["schemas"]["customer_address"];
            /** @description The customer's salutation. */
            salutation?: string;
            /** @description The customer's second name. */
            second_name?: string;
            /** @description The customer's suffix (for example, "Jr." or "Sr."). */
            suffix?: string;
            /** @description The customer's title (for example, "Mrs" or "Mr"). */
            title?: string;
        };
        /** @description <p>Document representing a customer address.</p> */
        customer_address: {
            /** @description The customer's first address. */
            address1?: string;
            /** @description The customer's second address value. */
            address2?: string;
            /** @description The customer address id. */
            address_id: string;
            /** @description The customer's city. */
            city?: string;
            /** @description The customer's company name. */
            company_name?: string;
            /**
             * @description The customer's two-character country code per ISO 3166-1 alpha-2.
             * @enum {string}
             */
            country_code: "CN" | "FR" | "GB" | "IT" | "JP" | "US";
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            etag?: string;
            /** @description The customer's first name. */
            first_name?: string;
            /** @description The concatenation of the customer's first, middle, and last names and its suffix. */
            full_name?: string;
            /** @description The customer's job title. */
            job_title?: string;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /** @description The customer's last name. */
            last_name: string;
            /** @description The customer's phone number. */
            phone?: string;
            /** @description The customer's post box. */
            post_box?: string;
            /** @description The customer's postal code. */
            postal_code?: string;
            /** @description The customer's salutation. */
            salutation?: string;
            /** @description The customer's second name. */
            second_name?: string;
            /** @description The customer's state. */
            state_code?: string;
            /** @description The customer's suffix. */
            suffix?: string;
            /** @description The customer's suite. */
            suite?: string;
            /** @description The customer's title. */
            title?: string;
        };
        /** @description <p>Result document containing an array of customer addresses.</p> */
        customer_address_result: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            /** @description The array of customer address documents. */
            data?: components["schemas"]["customer_address"][];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a customer group</p> */
        customer_group: {
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            /** @description The description for the customer group.  This property is read-only for system groups. */
            description?: string;
            /**
             * @description The user specific identifier for the customer group, which must be unique across the organization.  Property
             *      is read-only.
             */
            readonly id?: string;
            /** @description The deletion status of this customer group. */
            in_deletion?: boolean;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /** @description URL that is used to get this instance.  This property is computed and cannot be modified. */
            link?: string;
            /**
             * Format: int32
             * @description The number of members in this customer group.
             */
            member_count?: number;
            rule?: components["schemas"]["rule"];
            /**
             * @description The type of the customer group.  This property is read-only.
             * @enum {string}
             */
            type?: "system" | "dynamic" | "static";
        };
        /** @description <p>Document representing a customer group member</p> */
        customer_group_member: {
            /** @description A flag indicating whether the customer is enabled and can log in. */
            active?: boolean;
            c_familyStatus?: string;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            /** @description The link to the customer resource. */
            customer_link?: string;
            /** @description The customers number (id). */
            customer_no?: string;
            /**
             * Format: email
             * @description The customer's email address.
             */
            email?: string;
            /** @description The customer's first name. */
            first_name?: string;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /** @description The customer's last name. */
            last_name?: string;
            /** @description The link to the customer group member resource. */
            link?: string;
            /** @description The login of the customer. */
            login?: string;
        };
        /** @description <p>Document representing a customer group member search result.</p> */
        customer_group_member_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["customer_group_member"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of customer groups.</p> */
        customer_group_members: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["customer_group_member"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a customer group search result.</p> */
        customer_group_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["customer_group"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of customer groups.</p> */
        customer_groups: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["customer_group"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a customer list.</p> */
        customer_list: {
            /** @description The id of the customer list. */
            id: string;
            preferences?: components["schemas"]["customer_list_preferences"];
        };
        /** @description <p>Document representing a link to a customer list.</p> */
        customer_list_link: {
            /** @description The customerlist id. */
            customer_list_id?: string;
            /** @description The target of the link. */
            link?: string;
            /**
             * Format: localized
             * @description The link title.
             */
            title?: {
                [key: string]: string;
            };
        };
        /**
         * @description <p>Document representing customer list preferences:
         *       <ul>
         *       <li> data-retention-age </li>
         *       <li> customerno-sequence-enabled </li>
         *       <li> lockout-enabled </li>
         *       <li> max-failed-logins </li>
         *       <li> lockout-effective-period </li>
         *       <li> login-attempt-reset-time </li>
         *       <li> min-password-length </li>
         *       <li> min-password-special-chars </li>
         *       <li> force-password-contains-alpha </li>
         *       <li> force-password-contains-numeric </li>
         *       <li> force-password-mixed-case </li>
         *       <li> max-password-age </li>
         *       <li> max-password-reset-token-age </li>
         *       </ul></p>
         */
        customer_list_preferences: {
            /** @description Used to determine if the customer number sequence is separated by customer list. */
            customer_no_sequence_enabled: boolean;
            /**
             * Format: int32
             * @description The number days to retain customer data (null or 0 <= x <= 99999).
             */
            data_retention_age: number;
            /** @description Used to determine if the password must contain an alphabetic character. */
            force_password_contains_alpha: boolean;
            /** @description Used to determine if the password must contain a numeric character. */
            force_password_contains_numeric: boolean;
            /** @description Used to determine if the password must be mixed case. */
            force_password_mixed_case: boolean;
            /**
             * Format: int32
             * @description The customer lockout period in minutes (one of 1, 30, 60, 120, 1440, 14400).
             */
            lockout_effective_period: number;
            /** @description Used to determine if customers can be locked out. */
            lockout_enabled: boolean;
            /**
             * Format: int32
             * @description The period after which the customer login attempt count resets in minutes (one of 0, 5, 30, 60, 120, 1440).
             *
             *              1440)
             */
            login_attempt_reset_time: number;
            /**
             * Format: int32
             * @description The maximum number of failed logins before a customer lockout can occur (1 <= x <= 200).
             */
            max_failed_logins: number;
            /**
             * Format: int32
             * @description The maximum age of the customer password in days (one of 7, 10, 14, 30, 60, 90, 365000).
             */
            max_password_age: number;
            /**
             * Format: int32
             * @description The maximum age of the customer password reset token in minutes (one of 30, 60, 120, 360, 720, 1440).
             */
            max_password_reset_token_age: number;
            /**
             * Format: int32
             * @description The minimum number of characters required for a customer password (one of 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
             *      13, 14, 15, 20).
             *
             *              12, 13, 14, 15, 20)
             */
            min_password_length: number;
            /**
             * Format: int32
             * @description The minimum number of special characters required within a customer password (one of 0, 1, 2, 3, 4, 5).
             */
            min_password_special_chars: number;
        };
        /** @description <p>Document representing a customer search hit.</p> */
        customer_search_hit: {
            data?: components["schemas"]["customer"];
            /**
             * Format: double
             * @description The hit's relevance score.
             */
            relevance?: number;
        };
        /** @description <p>Document representing a customer search result.</p> */
        customer_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: Record<string, never>[];
            /** Format: int32 */
            db_start_record_?: number;
            /** @description The list of expands set. Can be empty. */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["customer_search_hit"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The fields that you want to select. */
            select?: string;
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Input-Document for requesting a Log-Fetch process.</p> */
        ecdn_log_fetch_request: {
            /**
             * Format: date-time
             * @description Optional end time for log file entries, in Unix time stamp format. Must not be more than 1 hour after the start time. If not passed, a one hour time frame is assumed for the log file.
             */
            end_time?: string;
            /**
             * Format: date-time
             * @description Start time for log file entries, in Unix time stamp format. Must not be more than 7 days in the past
             */
            start_time: string;
            /** @description zone id is optional but if it is provided then zone_name is not considered */
            zone_id?: string;
            /** @description The internationalized domain name representation (from RFC 3490) of the zone name */
            zone_name: string;
        };
        /** @description <p>Response object, providing the status of the current log fetch request.</p> */
        ecdn_log_fetch_response: {
            /** @description ID of the log fetch request */
            id?: string;
            /** @description HTTPS Download link to the fetched log file, which has a lifetime of 30 minutes. This link will only appear, if the current status of the log fetching is 'finished'. */
            link?: string;
            /** @description message for the log fetch request */
            message?: string;
            /**
             * @description Current status of the log fetch request
             * @enum {string}
             */
            status?: "pending" | "running" | "finished";
        };
        empty_body: unknown;
        /**
         * @description <p>Document representing a filter.
         *
         *      A filter contains a set of objects that define criteria used to select records. A filter
         *      can contain one of the following:
         *       <ul>
         *         <li> term_filter - matches records where a field (or fields) exactly match some simple value (including null). </li>
         *         <li> range_filter - matches records where a field value lies in a specified range. </li>
         *         <li> query_filter - provides filtering based on a query. </li>
         *         <li> bool_filter - provides filtering of records using a set of filters combined with a specified operator. </li>
         *       </ul></p>
         */
        filter: unknown;
        /**
         * @description <p>A filtered query allows to filter the result of a (possibly complex) query using a (possibly complex) filter.
         *
         *       <b> Example: </b>
         *       <pre>
         *         query : {
         *             filtered_query: {
         *                 query: {
         *                     text_query: { fields: ["coupon_id"], search_phrase: "disabled" }
         *                 },
         *                 filter: {
         *                     term_filter: {
         *                         field: "enabled", operator: "is", values: [ false ]
         *                     }
         *                 }
         *             }
         *         }
         *       </pre></p>
         */
        filtered_query: {
            filter: components["schemas"]["filter"];
            query: components["schemas"]["query"];
        };
        /** @description <p>Document representing a functional permission.</p> */
        functional_permission: {
            /**
             * Format: localized
             * @description The description of the functional permission.
             */
            description?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The display name of the functional permission.
             */
            display_name?: {
                [key: string]: string;
            };
            /** @description The name of the functional permission. */
            name?: string;
            /** @description The permission type. */
            type?: string;
            /** @description The list of possible values for the functional permission, e.g. ACCESS or READONLY. */
            values?: string[];
        };
        /** @description <p>Document representing the available functional permissions.</p> */
        functional_permissions: {
            /** @description The collection of available organization functional permissions. */
            organization?: components["schemas"]["functional_permission"][];
            /** @description The available functional permission scopes (e.g. organization, site). */
            scopes?: string[];
            /** @description The list of available site functional permissions. */
            site?: components["schemas"]["functional_permission"][];
        };
        /** @description <p>Document representing a gift certificate</p> */
        gift_certificate: {
            amount?: components["schemas"]["money"];
            balance?: components["schemas"]["money"];
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            /** @description The description of the gift certificate. */
            description?: string;
            /** @description The enabled flag of the gift certificate. */
            enabled?: boolean;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /**
             * @description The URL to get the gift certificate.
             *      This is a computed attribute and cannot be modified.
             */
            link?: string;
            /**
             * @description The masked gift certificate code with all but the
             *      last 4 characters replaced with a '*' character.
             *      This is a computed attribute and cannot be modified.
             */
            masked_gift_certificate_code?: string;
            /**
             * @description The merchant ID of the gift certificate.
             *      This is a unique attribute.
             *      This is a computed attribute and cannot be modified.
             *      This is used to get, update and the delete gift certificates.
             */
            merchant_id?: string;
            /** @description The message to the recipient of the gift certificate. */
            message?: string;
            /** @description The order number of the gift certificate. */
            order_no?: string;
            /** @description The email address of the recipient of the gift certificate. */
            recipient_email?: string;
            /** @description The recipient of the gift certificate. */
            recipient_name?: string;
            /** @description The sender of the gift certificate. */
            sender_name?: string;
            /**
             * @description The status of the gift certificate.
             *      While creating a gift certificate, user can set the status
             *      to either "pending" or "issued" only.
             * @enum {string}
             */
            status?: "issued" | "partially_redeemed" | "pending" | "redeemed";
            /** @description The transactions of the gift certificate. This attribute is only available as part of the response. */
            transactions?: components["schemas"]["account_transaction"][];
        };
        /** @description <p>Document representing a gift certificate search result.</p> */
        gift_certificate_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["gift_certificate"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of gift certificates.</p> */
        gift_certificates: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["gift_certificate"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing an image group containing a list of images for a particular view type and an optional variation value.</p> */
        image_group: {
            /** @description The images of the image group. */
            images?: components["schemas"]["media_file"][];
            /** @description Returns a list of variation attributes applying to this image group. */
            variation_attributes?: components["schemas"]["variation_attribute"][];
            /** @description The image view type. */
            view_type?: string;
        };
        /** @description <p>Document representing a inventorylist</p> */
        inventory_list: {
            /**
             * @description The list of sites this inventory list is assigned to. The assigned sites is a computed attribute, and cannot be
             *      directly modified.
             */
            assigned_sites?: string[];
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            /** @description True if the default for the inventory list is to be in stock. THe default value is false if not specified. */
            default_in_stock?: boolean;
            /** @description The user supplied description of this instance. */
            description?: string;
            /** @description The id for the inventory list, which is required and must be unique. */
            id?: string;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /** @description URL that is used to get this instance. The URL is a computed attribute, and cannot be modified. */
            link?: string;
            /** @description True if the on order flag is enabled. The default value is false if not specified. */
            on_order_inventory_enabled?: boolean;
            /** @description True if the inventory list is used in bundle inventory only. The default value is false if not specified. */
            use_bundle_inventory_only?: boolean;
        };
        /** @description <p>Document representing a inventorylist search result.</p> */
        inventory_list_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["inventory_list"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of inventory lists.</p> */
        inventory_lists: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["inventory_list"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        job_execution: {
            /** @description When the execution was started by a client, this represents the client's id. */
            client_id?: string;
            continue_information?: components["schemas"]["job_execution_continue_information"];
            /** Format: date-time */
            creation_date?: string;
            /**
             * Format: int64
             * @description Time in milliseconds, the execution was or is running.
             */
            duration?: number;
            /**
             * Format: int64
             * @description Time in milliseconds, the job has done work. Paused times are evicted.
             */
            effective_duration?: number;
            /**
             * Format: date-time
             * @description Timestamp, when execution was finished.
             */
            end_time?: string;
            /** @description The ID of the server that executed the job. */
            executed_server_id?: string;
            /** @description Sorted set of all execution scopes, used by individual steps. */
            execution_scopes?: string[];
            /**
             * @description The current execution status.
             * @enum {string}
             */
            execution_status?: "pending" | "running" | "pausing" | "paused" | "resuming" | "resumed" | "restarting" | "restarted" | "retrying" | "retried" | "aborting" | "aborted" | "finished" | "unknown";
            exit_status?: components["schemas"]["status"];
            /** @description ID of the execution object. */
            id?: string;
            /** @description True if the log file exists, otherwise false. */
            is_log_file_existing?: boolean;
            /** @description True if this execution represents a job restart. */
            is_restart?: boolean;
            /** @description Description of the job, this execution belongs to. */
            job_description?: string;
            /** @description ID of the job, this execution belongs to. */
            job_id?: string;
            /** Format: date-time */
            last_modified?: string;
            /** @description Full WebDAV path of the log file, containing execution log. */
            log_file_path?: string;
            /**
             * Format: date-time
             * @description Timestamp of the last modification time for the execution.
             */
            modification_time?: string;
            /** @description List of all job execution parameters. */
            parameters?: components["schemas"]["job_execution_parameter"][];
            retry_information?: components["schemas"]["job_execution_retry_information"];
            /**
             * Format: date-time
             * @description Timestamp, when execution was started.
             */
            start_time?: string;
            /**
             * @description The current status. If the execution is currently executed the execution status is returned. If the execution is
             *      not executed currently anymore the exit status code of the execution.
             */
            status?: string;
            status_metadata?: components["schemas"]["status_metadata"];
            /** @description List of all steps, called for job execution. */
            step_executions?: components["schemas"]["job_step_execution"][];
            /** @description When the execution was started by a registered user, this represents the user's login. */
            user_login?: string;
        };
        /** @description <p>Information for a job execution continuation.</p> */
        job_execution_continue_information: {
            /**
             * @description Returns the status, this job execution will get on continuation if continuation is pending.
             * @enum {string}
             */
            continue_status?: "pending" | "running" | "pausing" | "paused" | "resuming" | "resumed" | "restarting" | "restarted" | "retrying" | "retried" | "aborting" | "aborted" | "aborting_for_restart" | "aborted_for_restart" | "finished" | "unknown";
            /**
             * @description Returns <code>true</code> if the continuation of this job execution is pending and will be started soon,
             *      <code>false</code> otherwise.
             */
            is_pending?: boolean;
        };
        /**
         * @description <p>Specification of a parameter for a job execution. <br/>
         *       <br/>
         *      Request example to execute the job in all storefront sites:
         *       <pre>
         *      POST /dw/data/v19_10/jobs/CustomerImportJob/executions
         *      Host: example.com
         *      Authorization: Bearer af7f5c90-ffc1-4ea4-9613-f5b375b7dc19
         *      Content-Type: application/json; charset=UTF-8
         *      {
         *         "parameters": [
         *            {
         *                "name": "SiteScope",
         *                "value": "{\"all_storefront_sites\":true}"
         *            }
         *         ]
         *      }
         *       </pre> <br/>
         *      Request example to execute the job in specified sites only:
         *       <pre>
         *      POST /dw/data/v19_10/jobs/CustomerImportJob/executions
         *      Host: example.com
         *      Authorization: Bearer af7f5c90-ffc1-4ea4-9613-f5b375b7dc19
         *      Content-Type: application/json; charset=UTF-8
         *      {
         *         "parameters": [
         *            {
         *                "name": "SiteScope",
         *                "value": "{\"named_sites\":[\"SiteGenesis\", \"SiteGenesisGlobal\"]}"
         *            }
         *         ]
         *      }
         *       </pre></p>
         */
        job_execution_parameter: {
            /** @description The name of the parameter. */
            name: string;
            /** @description The value of the parameter. */
            value: string;
        };
        /** @description <p>Retry information for a previous  <b> failed </b>  job execution.</p> */
        job_execution_retry_information: {
            /**
             * Format: int32
             * @description The current attempt to retry the previous <b>failed</b> job execution.
             */
            current_retry_attempt?: number;
            /**
             * Format: int32
             * @description The maximum number of retries.
             */
            max_retries?: number;
        };
        /** @description <p>Document representing a job execution search result.</p> */
        job_execution_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. May be empty. */
            hits?: components["schemas"]["job_execution"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        job_step_execution: {
            /**
             * Format: int32
             * @description The chunk size for a chunk oriented step execution, otherwise null.
             */
            chunk_size?: number;
            /**
             * Format: int64
             * @description Time in milliseconds, the execution was or is running.
             */
            duration?: number;
            /**
             * Format: date-time
             * @description Timestamp, when execution was finished.
             */
            end_time?: string;
            /** @description The ID of the scope this step is or was executed for. */
            execution_scope?: string;
            /**
             * @description Current execution status of the step.
             *      <ul>
             *      <li>'pending': Execution of the step been initiated but the step is not executing yet. Possible next status:
             *      'running'.</li>
             *      <li>'running': The step is currently actively executed. Possible next status: 'finished', 'pausing' or
             *      'aborted'.</li>
             *      <li>'finished': The step execution is finished and is not actively executed currently. Possible next status:
             *      none.</li>
             *      <li>'pausing': Pausing of a running step execution has been initiated but the step is not paused yet. Possible
             *      next status: 'paused' or 'aborted'.</li>
             *      <li>'paused': The step execution is paused and is not actively executed currently. Possible next status:
             *      'pending'.</li>
             *      <li>'aborted': A running step execution has been aborted and is not actively executed currently. Possible next
             *      status: none.</li>
             *      </ul>
             * @enum {string}
             */
            execution_status?: "pending" | "running" | "pausing" | "paused" | "resuming" | "resumed" | "restarting" | "restarted" | "retrying" | "retried" | "aborting" | "aborted" | "finished" | "unknown";
            exit_status?: components["schemas"]["status"];
            /** @description ID of the execution object. */
            id?: string;
            /** @description ID of the job the step of this step execution was included from, if the step was included from another job. */
            include_steps_from_job_id?: string;
            /** @description True if this execution represents a chunk oriented step execution. */
            is_chunk_oriented?: boolean;
            /**
             * Format: int32
             * @description The current number of items that have been filtered for a chunk oriented step execution, otherwise null.
             */
            item_filter_count?: number;
            /**
             * Format: int32
             * @description The current number of items that have been written for a chunk oriented step execution, otherwise null.
             */
            item_write_count?: number;
            /**
             * Format: date-time
             * @description Timestamp of the last modification time for the execution.
             */
            modification_time?: string;
            /**
             * Format: date-time
             * @description Timestamp, when execution was started.
             */
            start_time?: string;
            /**
             * @description The current status. If the step execution is currently executed (execution status is one of 'pending', 'running',
             *      'pausing') the execution status is returned. If the step execution is not executed currently anymore (execution
             *      status is one one 'finished', 'paused' or 'aborted') the exit status code of the step execution is returned.
             */
            status?: string;
            status_metadata?: components["schemas"]["status_metadata"];
            /** @description Description of the step, this execution belongs to.ID of the step */
            step_description?: string;
            /** @description ID of the step, this execution belongs to.ID of the step */
            step_id?: string;
            /** @description ID of the step's type at the time it is or was executed. */
            step_type_id?: string;
            /**
             * @description Additional information regarding the step's type at the time it is or was executed (e.g. name of a script module
             *      and function).
             */
            step_type_info?: string;
            /**
             * Format: int64
             * @description The total number of items that will be processed for a chunk oriented step execution (null if unknown), otherwise
             *      null.
             */
            total_item_count?: number;
        };
        /** @description <p>Document that describes a single locale.</p> */
        locale: {
            /** @description Flag that is true if the locale is the default one to use if an explicit locale is not specified. */
            200?: boolean;
            /** @description Flag that is true if the locale is currently active in the system. */
            active?: boolean;
            /**
             * @description The uppercase ISO 3166 2-letter country/region code for this Locale.
             *      If no country has been specified for this Locale, this value is an empty string.
             */
            country?: string;
            /**
             * @description The display name of this Locale's country, in this Locale's language,
             *      not in the session locale's language.
             *      If no country has been specified for this Locale, this value is an empty string.
             */
            display_country?: string;
            /**
             * @description The display name of this Locale's language, in this Locale's language,
             *      not in the session locale's language.
             *      If no country has been specified for this Locale, this value is an empty string.
             */
            display_language?: string;
            /**
             * @description The display name of this Locale, in this Locale's language,
             *      not in the session locale's language.
             *      If no display name has been specified for this Locale, this value is an empty string.
             */
            display_name?: string;
            /**
             * @description Returns the String representation of the localeID.
             *
             *      <p>Combines the language and the country key, concatenated with "-".
             *      For example: "en-US". This attribute is the primary key of the class.</p>
             */
            id?: string;
            /**
             * @description The uppercase ISO 3166 3-letter country/region code for this Locale.
             *      If no country has been specified for this Locale, this value is an empty string.
             */
            iso3_country?: string;
            /**
             * @description The 3-letter ISO 639 language code for this Locale.
             *      If no language has been specified for this Locale, this value is an empty string.
             */
            iso3_language?: string;
            /**
             * @description The lowercase ISO 639 language code for this Locale.
             *      If no language has been specified for this Locale, this value is an empty string.
             */
            language?: string;
            /**
             * @description The display name of the Locale. Uses the current
             *      request locale to localize the value.
             */
            name?: string;
        };
        /** @description <p>Document representing a locale permission.</p> */
        locale_permission: {
            /**
             * Format: localized
             * @description The display name of the locale.
             */
            display_name?: {
                [key: string]: string;
            };
            /** @description The id of the locale. */
            locale_id?: string;
            /** @description The permission type. */
            type?: string;
            /** @description The list of possible values for the locale permission, e.g. ACCESS or READONLY. */
            values?: string[];
        };
        /** @description <p>Document representing the available locale permissions.</p> */
        locale_permissions: {
            /** @description The available Locale permission scopes (e.g. unscoped). */
            scopes?: string[];
            /** @description The collection of available unscoped Locale permissions. */
            unscoped?: components["schemas"]["locale_permission"][];
        };
        /** @description <p>Contains the result of getting the system locales.</p> */
        locale_result: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: Record<string, never>[];
            /** @description The locales found by the request */
            hits?: components["schemas"]["locale"][];
            /** @description The input locale (none specifies get all locales) */
            id?: string;
            /** @description True to get the all the hits for all the locales, not just the active allowed ones */
            include_all?: boolean;
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The string describing the set of fields to return in the result. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing log category settings.</p> */
        log_category: {
            /** @description Returns true if the log category is enabled. */
            enabled?: boolean;
            /** @description Level of the log category. */
            level?: string;
            /** @description Log category name. */
            name?: string;
        };
        markup_text: {
            /** @description The rendered HTML (read only) */
            markup?: string;
            /**
             * @description The raw markup text
             *      (only this needs to be provided in update request)
             */
            source?: string;
        };
        /** @description <p>Document representing a variation master.</p> */
        master: {
            /** @description The URL addressing the master product. */
            link?: string;
            /** @description The id (SKU) of the master product. */
            master_id: string;
            /** @description A flag indicating whether at least one of the variants is orderable. */
            orderable?: boolean;
            /**
             * Format: double
             * @description The minimum sales price of the related variants.
             */
            price?: number;
            /**
             * Format: double
             * @description The maximum sales of related variants.
             */
            price_max?: number;
            /**
             * Format: double
             * @description The minimum sales price per unit of the related variants.
             */
            price_per_unit?: number;
            /**
             * Format: double
             * @description The maximum sales price per unit of the related variants.
             */
            price_per_unit_max?: number;
            prices?: {
                [key: string]: number;
            };
        };
        /**
         * @description <p>A match all query simply matches all documents (namespace and document type). This query comes in
         *      handy if you just want to filter a search result or really do not have any constraints.
         *
         *       <b> Example: </b>
         *       <pre>
         *         query: {
         *             match_all_query: {}
         *         }
         *       </pre></p>
         */
        match_all_query: unknown;
        media_file: {
            /** @description The absolute URL with request protocol (read only) */
            abs_url?: string;
            /**
             * Format: localized
             * @description The alternative image text
             */
            alt?: {
                [key: string]: string;
            };
            /** @description The DIS base URL only for product images */
            dis_base_url?: string;
            /**
             * @description The raw media file path
             *      (only this needs to be provided in update request)
             */
            path?: string;
            /**
             * Format: localized
             * @description The image title
             */
            title?: {
                [key: string]: string;
            };
        };
        /** @description <p>Document representing a menu action.</p> */
        menu_action: {
            /**
             * Format: localized
             * @description The description of the menu action.
             */
            description?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The display name of the menu action.
             */
            display_name?: {
                [key: string]: string;
            };
            /** @description The module type of the menu action (BM or CC). */
            module_type?: string;
            /** @description The name of the menu action. */
            name?: string;
            /**
             * @description {
             *      action.
             */
            system?: boolean;
            /** @description The permission type. */
            type?: string;
            /** @description The list of possible values for the menu action, e.g. ACCESS or READONLY. */
            values?: string[];
        };
        /** @description <p>Document representing a menu item.</p> */
        menu_item: {
            /**
             * Format: localized
             * @description The display name of the menu item.
             */
            display_name?: {
                [key: string]: string;
            };
            /** @description The collection of available menu actions. */
            menu_actions?: components["schemas"]["menu_action"][];
            /** @description The module type of the menu item (BM or CC). */
            module_type?: string;
            /** @description The name of the menu item. */
            name?: string;
            /** @description The permission type. */
            type?: string;
        };
        /** @description <p>Metrics in Prometheus Exposition Format wrapped as Json array of strings.</p> */
        metric_response: {
            /**
             * Format: int32
             * @description Page size of result page
             */
            limit?: number;
            /** @description Metrics in Prometheus Exposition Format. <p/> A single metric is represented by a single line. They have a name, labels (dimensions), a value and a time-stamp. <p/> Example:<p/> OCAPI request: <code>GET /v21.10/products/{Id}/prices</code><p/> total time metric: <code>products_Id_prices{method=\"GET\",version=\"v21.10\",path1=\"products\",path2=\"prices\",status=\"2xx\"} 112.718755 1620735785000</code> <p/> The individual elements of a metric line are the metric name, metric dimensions (denoted by label / value pairs in curly braces), the actual metric value (in milliseconds or in operations / second for metrics ending in <code>_m1rate</code>) and a time-stamp in milliseconds since 01/01/1970 UTC.<p/>    <p><b>name</b></p>   <p>The metric name will have both path segments and parameters separated by '&#x60;_&#x60;'.       Path segments in the metric name are in lower-case whereas path parameters are formatted in camel-case.<p/>   </p>    <p><b>method</b></p>   <p>the HTTP method of the OCAPI request, one of <code>GET, PUT, POST, DELETE</code><p/></p>    <p><b>version</b></p>   <p>the version of the OCAPI request, e.g. v20.8<p/></p>    <p><b>path1</b> .. <b>pathN</b></p>   <p>The path segments (not including the path-parameters) of the OCAPI request, from the example above, the path       segments will be mapped to labels as: <code>path1=\"products\", path2=\"prices\"</code><p/>   </p>    <p><b>breakdown</b></p>   <p>Sub-timings of the request, in particular:<p/>     <ul>       <li><b>total</b> (implicit): total timings of the request (sum of the three breakdowns below). This dimension is denoted with no label.</li>       <li><b>platform</b>: amount of time spent in platform code (including database-tier)</li>       <li><b>custom</b>: amount of time spent in custom code (including database-tier)</li>       <li><b>thirdParty</b>: amount of time spent invoking third party services through the service framework</li>     </ul>   </p>    <p><b>status</b></p>   <p>     <ul>       <li><b>2xx</b>: metrics for all requests with a status code between 200 and 299</li>       <li><b>3xx</b>: metrics for all requests with a status code between 300 and 399</li>       <li><b>4xx</b>: metrics for all requests with a status code between 400 and 499</li>       <li><b>5xx</b>: metrics for all requests with a status code between 500 and 599</li>     </ul>   </p>    <p><b>quantile</b></p>   <p>     <ul>       <li><b>p50</b>: median timings</li>       <li><b>p95</b>: timings for the 95th percentile of all requests</li>     </ul>   </p>    <p><b>serviceId</b> (only for metrics where breakdown = thirdParty)</p>   <p>the <code>id</code> of the third party service that was invoked during the request. If multiple services were invoked,       timings for each individual service are available<p/>   </p> */
            metrics?: string[];
            /**
             * Format: int32
             * @description Offset of result page
             */
            offset?: number;
            /**
             * Format: int32
             * @description Total number of metrics
             */
            total?: number;
        };
        /** @description <p>Document representing the available module permissions in shape of menu items and menu actions.</p> */
        module_permissions: {
            /** @description The collection of available organization menu items. */
            organization?: components["schemas"]["menu_item"][];
            /** @description The available menu item scopes (e.g. organization, site). */
            scopes?: string[];
            /** @description The list of available site menu items. */
            site?: components["schemas"]["menu_item"][];
        };
        money: {
            /** @description The mnemonic for the money. */
            currency_mnemonic?: string;
            /**
             * Format: double
             * @description The value for the money.
             */
            value?: number;
        };
        /**
         * @description <p>A nested query queries nested documents that are part of a larger document. The classical example is a
         *      product master with variants (in one big document) where you want to constrain a search to masters that have
         *      variants that match multiple constraints (like color = blue AND size = M).
         *      This query is not compatible with some search types.
         *       <b> Example: </b>  finds all the documents that has firstname = "John" and lastname = "Doe"
         *       <pre>
         *       {
         *        "query": {
         *          "bool_query": {
         *            "must": [
         *              {
         *                "nested_query": {
         *                  "path": "order.shipping_addresses",
         *                  "query": {
         *                    "bool_query": {
         *                      "must": [
         *                        {
         *                          "bool_query": {
         *                            "must": [
         *                              {
         *                                "term_query": {
         *                                  "fields": [ "order.shipping_addresses.first_name" ],
         *                                  "operator": "is",
         *                                  "values": [ "John" ]
         *                                }
         *                              }
         *                            ]
         *                          }
         *                        },
         *                        {
         *                          "bool_query": {
         *                            "must": [
         *                              {
         *                                "term_query": {
         *                                  "fields": [ "order.shipping_addresses.last_name" ],
         *                                  "operator": "is",
         *                                  "values": [ "Doe" ]
         *                                }
         *                              }
         *                            ]
         *                          }
         *                        }
         *                      ]
         *                    }
         *                  },
         *                  "score_mode": "avg"
         *                }
         *              }
         *            ]
         *          }
         *        }
         *      }
         *       </pre></p>
         */
        nested_query: {
            path: string;
            query: components["schemas"]["query"];
            /** @enum {string} */
            score_mode?: "avg" | "total" | "max" | "none";
        };
        /** @description <p>Document representing a attribute definition</p> */
        object_attribute_definition: {
            /** Format: date-time */
            creation_date?: string;
            default_value?: components["schemas"]["object_attribute_value_definition"];
            /**
             * Format: localized
             * @description The localized description of the attribute.
             */
            description?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The localized name presented to the user in forms.
             */
            display_name?: {
                [key: string]: string;
            };
            /** @description The effective ID, which is c_id if the attribute is custom, and just the id otherwise. It is read only. */
            effective_id?: string;
            /** @description Flag indicating if this attribute is externally defined. */
            externally_defined?: boolean;
            /** @description Flag indicating if this attribute is externally managed. */
            externally_managed?: boolean;
            /**
             * Format: int32
             * @description The height of the field for this attribute in the editor.
             */
            field_height?: number;
            /**
             * Format: int32
             * @description The length of the field for this attribute in the editor.
             */
            field_length?: number;
            /** @description The user supplied ID of the attribute. */
            id?: string;
            /** @description Flag indicating if this is a key attribute. */
            key?: boolean;
            /** Format: date-time */
            last_modified?: string;
            /** @description The URL that is used to get this instance.  Value is computed and read-only. */
            link?: string;
            /** @description Flag indicating if this attribute can be localized. */
            localizable?: boolean;
            /** @description Flag indicating if a value is mandatory for the attribute. */
            mandatory?: boolean;
            /**
             * Format: double
             * @description The maximum possible value for this attribute.
             */
            max_value?: number;
            /**
             * Format: int32
             * @description The minimum length of the field for this attribute.
             */
            min_length?: number;
            /**
             * Format: double
             * @description The minimum possible value for this attribute.
             */
            min_value?: number;
            /**
             * @description <p>True if the attribute can have multiple values.</p>
             *      <p>Attributes of the following types are multi-value capable:</p>
             *      <ul>
             *      <li>set_of_int</li>
             *      <li>set_of_number</li>
             *      <li>set_of_string</li>
             *      </ul>
             *      <p>Additionally, attributes of the following types can be multi-value
             *      enabled:</p>
             *      <ul>
             *      <li>enum_of_int</li>
             *      <li>enum_of_string</li>
             *      </ul>
             */
            multi_value_type?: boolean;
            /**
             * @description Flag indicating if this attribute is required for order of the attribute model's product. The set of these can be used
             *      in order line items.
             */
            order_required?: boolean;
            /**
             * @description Returns true if the attribute definition is explicitly marked queryable. If no explicit queryable is found
             *      and the attribute value type belongs to a queryable type, true is returned too. In all other cases false is returned.
             *      Value is computed and read-only.
             */
            queryable?: boolean;
            /** @description Flag indicating if this attribute is read-only. It is read only. */
            read_only?: boolean;
            /** @description A regular expression that defines the legal values for this attribute. */
            regular_expression?: string;
            /** @description Flag indicating if this attribute can be encoded using the encoding="off" flag in ISML templates. It is read only. */
            requires_encoding?: boolean;
            /**
             * Format: int32
             * @description The minimum number of fraction digits for a value of this attribute.
             */
            scale?: number;
            /** @description Flag indicating if this attribute is searchable. */
            searchable?: boolean;
            /** @description Flag indicating if this attribute is of type 'Set of'. It is read only. */
            set_value_type?: boolean;
            /** @description Flag indicating if this attribute is site-specific. */
            site_specific?: boolean;
            /** @description Flag indicating if this attribute is a system attribute. */
            system?: boolean;
            /**
             * Format: localized
             * @description The unit of measure for this attribute.
             */
            unit?: {
                [key: string]: string;
            };
            /** @description A set of values that are possible for this attribute. It is read only. */
            value_definitions?: components["schemas"]["object_attribute_value_definition"][];
            /**
             * @description The type of this attribute.
             * @enum {string}
             */
            value_type?: "string" | "int" | "double" | "text" | "html" | "date" | "image" | "boolean" | "money" | "quantity" | "datetime" | "email" | "password" | "set_of_string" | "set_of_int" | "set_of_double" | "enum_of_string" | "enum_of_int" | "unknown";
            /** @description Flag indicating if this attribute is visible. */
            visible?: boolean;
        };
        /** @description <p>Document representing an attributedefinition search result.</p> */
        object_attribute_definition_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["object_attribute_definition"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of object attribute definitions.</p> */
        object_attribute_definitions: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["object_attribute_definition"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a attribute group</p> */
        object_attribute_group: {
            /** @description Attributes with the group displayed when expand=definition */
            attribute_definitions?: components["schemas"]["object_attribute_definition"][];
            /**
             * Format: int32
             * @description The count of the attributes within the group.  This is a computed attribute and is read-only
             */
            attribute_definitions_count?: number;
            /** Format: date-time */
            creation_date?: string;
            /**
             * Format: localized
             * @description The free-form text description of the group by locale
             */
            description?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The name used to display the group by locale.
             */
            display_name?: {
                [key: string]: string;
            };
            /** @description The group's user specified identifier, used to retrieve the group */
            id?: string;
            /** @description True if the group is meant only for internal use, false otherwise.  This property is read-only. */
            internal?: boolean;
            /** Format: date-time */
            last_modified?: string;
            /** @description URL that is used to get this instance.  This is a computed attribute and is read-only */
            link?: string;
            /**
             * Format: double
             * @description The position of the group relative to other groups.
             */
            position?: number;
        };
        /** @description <p>Document representing a attributegroup search result.</p> */
        object_attribute_group_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["object_attribute_group"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of object group definitions.</p> */
        object_attribute_groups: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["object_attribute_group"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a attribute definition</p> */
        object_attribute_value_definition: {
            /**
             * Format: localized
             * @description A description of the attribute value.
             */
            description?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description A display name that can be used to present this value in
             *      the user interface. For example, the value might be '1' but the display
             *      name might be 'Order Exported'.
             */
            display_value?: {
                [key: string]: string;
            };
            /** @description The ID of the attribute value. */
            id?: string;
            /**
             * Format: double
             * @description The position of the attribute value within the set of attribute values.
             */
            position?: number;
            /** @description The value of the attribute. */
            value?: Record<string, never>;
        };
        /** @description <p>Document representing a object type definition</p> */
        object_type_definition: {
            /**
             * Format: int32
             * @description Returns the number of attribute definitions contained by the type.  This is a computed attribute and cannot be changed.
             */
            attribute_definition_count?: number;
            /**
             * Format: int32
             * @description Returns the number of attribute groups contained by the type.  This is a computed attribute and cannot be changed.
             */
            attribute_group_count?: number;
            /** @description True if the object type definition is marked as a content object */
            content_object?: boolean;
            /** Format: date-time */
            creation_date?: string;
            /**
             * Format: localized
             * @description The user entered description for the type (localizable)
             */
            description?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The user entered display name (localizable)
             */
            display_name?: {
                [key: string]: string;
            };
            /** Format: date-time */
            last_modified?: string;
            /** @description URL that is used to get this instance.  This is a computed attribute and cannot be changed. */
            link?: string;
            /** @description The object type identifier */
            object_type?: string;
            /** @description True if the system object type is queryable, false otherwise.  Default is true. */
            queryable?: boolean;
            /** @description True if the system object is read-only, false otherwise.  This is a computed attribute and cannot be changed. */
            read_only?: boolean;
        };
        /** @description <p>Document representing a systemobject search result.</p> */
        object_type_definition_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["object_type_definition"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of system object types.</p> */
        object_type_definitions: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["object_type_definition"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>OCAPI configuration APIs request</p> */
        ocapi_configs_api_request: {
            resource_info: components["schemas"]["resource_info"];
            /** @description Sites to be updated */
            sites: string[];
        };
        /** @description <p>OCAPI configuration APIs response. It contains all available resources for a client</p> */
        ocapi_configs_api_response: {
            /** @description Global configuration */
            global?: components["schemas"]["site_resource_info"][];
            /** @description Site configurations */
            sites?: components["schemas"]["site_resource_info"][];
        };
        /** @description <p>Request body to update the order confirmation status.</p> */
        order_confirmation_status_update_request: {
            /**
             * @description The new confirmation status for an order.
             * @enum {string}
             */
            status: "confirmed" | "not_confirmed";
        };
        /** @description <p>Request body to update the order export status.</p> */
        order_export_status_update_request: {
            /**
             * @description The new export status for an order.
             * @enum {string}
             */
            status: "exported" | "not_exported" | "ready" | "failed";
        };
        /** @description <p>Request body to update the order external status.</p> */
        order_external_status_update_request: {
            /** @description The new external status for an order. */
            status: string;
        };
        /** @description <p>Request body to update the order payment status.</p> */
        order_payment_status_update_request: {
            /**
             * @description The new payment status for an order.
             * @enum {string}
             */
            status: "paid" | "part_paid" | "not_paid";
        };
        /** @description <p>Request body to update the order shipping status.</p> */
        order_shipping_status_update_request: {
            /**
             * @description The new shipping status for an order.
             * @enum {string}
             */
            status: "shipped" | "part_shipped" | "not_shipped";
        };
        /** @description <p>Request body to update the order status.</p> */
        order_status_update_request: {
            /**
             * @description The new status for an order.
             * @enum {string}
             */
            status: "created" | "new" | "open" | "completed" | "cancelled" | "failed" | "failed_with_reopen";
        };
        /** @description <p>Request body to update an order.</p> */
        order_update_request: unknown;
        /** @description <p>Represents a set of preferences attached at the organization level.</p> */
        organization_preferences: {
            /** @description A URL that returns the full details for a custom preference */
            link?: string;
            /** @description The list of site preferences, returned with expand=sites */
            site_preferences?: components["schemas"]["site_preferences"][];
        };
        password_change_request: {
            /** @description The current user password */
            current_password: string;
            /** @description The new user password */
            password: string;
        };
        /** @description <p>Document representing most basic info (id and name) of a category or catalog.</p> */
        path_record: {
            /** @description The id of the category path. */
            id?: string;
            /**
             * Format: localized
             * @description The name of the category path.
             */
            name?: {
                [key: string]: string;
            };
        };
        /** @description <p>Request body to update an order payment instrument.</p> */
        payment_instrument_update_request: unknown;
        /** @description <p>Request body to update an order payment transaction.</p> */
        payment_transaction_update_request: unknown;
        /** @description <p>Represents a single preference value</p> */
        preference_value: {
            attribute_definition?: components["schemas"]["object_attribute_definition"];
            /**
             * Format: localized
             * @description Description of the attribute
             */
            description?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description Display name for the attribute
             */
            display_name?: {
                [key: string]: string;
            };
            /** @description The id of the attribute */
            id?: string;
            /** @description The value of this attribute */
            site_values?: {
                [key: string]: Record<string, never>;
            };
            /**
             * @description The type of this attribute.
             * @enum {string}
             */
            value_type?: "string" | "int" | "double" | "text" | "html" | "date" | "image" | "boolean" | "money" | "quantity" | "datetime" | "email" | "password" | "set_of_string" | "set_of_int" | "set_of_double" | "enum_of_string" | "enum_of_int" | "unknown";
        };
        /** @description <p>Document representing a preference value search result.</p> */
        preference_value_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["preference_value"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing a product</p> */
        product: {
            /** @description The catalog categories that the product is assigned to */
            assigned_categories?: components["schemas"]["catalog_category_id"][];
            /**
             * Format: double
             * @description The ATS(Available To Sell) inventory value of the product. This is a calculated value.
             */
            ats?: number;
            /** @description The brand of the product. */
            brand?: string;
            /** @description The array of bundled products which the product includes. */
            bundled_products?: components["schemas"]["product"][];
            /** @description Signals if there are inventory lists for brick-and-mortar stores associated with this product. */
            c_availableForInStorePickup?: boolean;
            c_batteryLife?: string;
            c_batteryType?: string;
            /** @description Type of Boot for search refinement. */
            c_bootType?: ("0010" | "0020" | "0030" | "0040" | "0050" | "0060" | "0070")[];
            /** @description Bottom type for search refinement */
            c_bottomType?: ("0010" | "0020" | "0030" | "0040" | "0050" | "0060" | "0070" | "0080")[];
            /** @description Product color used for variation attribute */
            c_color?: string;
            c_consoleWarranty?: string;
            c_customCSSFile?: components["schemas"]["media_file"];
            c_digitalCameraFeatures?: ("0010" | "0020" | "0030" | "0040" | "0050" | "0060" | "0070" | "0080" | "0090" | "0100" | "0110" | "0120" | "0130" | "0140" | "0150" | "0160" | "0170" | "0180" | "0190" | "0200" | "0210" | "0220" | "0230" | "0240" | "0250" | "0260" | "0270" | "0280")[];
            c_digitalCameraPixels?: string;
            c_digitalCameraType?: string;
            c_digitalCameraWarranty?: string;
            c_dimDepth?: string;
            c_dimHeight?: string;
            c_dimWeight?: string;
            c_dimWidth?: string;
            c_displaySize?: string;
            c_gameGenre?: ("Action" | "Educational" | "Kids" | "Racing" | "Role-Playing" | "Sports" | "Strategy")[];
            c_gameRating?: string;
            c_gameSystemType?: string;
            c_gpsFeatures?: ("0010" | "0020" | "0030" | "0040" | "0050" | "0060" | "0070" | "0080" | "0090" | "0100" | "0110" | "0120" | "0130" | "0140" | "0150" | "0160" | "0170" | "0180" | "0190" | "0200" | "0210" | "0230")[];
            c_gpsType?: ("0010" | "0020" | "0030" | "0040")[];
            c_gpsWarranty?: string;
            c_imageAspectRatio?: string;
            c_isNew?: boolean;
            /** @description This indiciates if the product is a new arrival. */
            c_isNewtest?: boolean;
            /** @description This is the help text. It is used for sorting rules. */
            c_isSale?: boolean;
            /**
             * @description Kids Age used for search refinements
             * @enum {string}
             */
            c_kidsAge?: "0010" | "0020" | "0030" | "0040" | "0050" | "0060" | "0070";
            /** @description This attribute is used for mens and womens pants lengths. */
            c_length?: string;
            c_lensAperture?: string;
            c_materialTest?: ("cotton" | "polyester" | "wool")[];
            /** @description Media Format */
            c_mediaFormat?: ("0010" | "0020" | "0030" | "0040" | "0050" | "0060" | "0070" | "0080" | "0090" | "0100")[];
            /** @description Memory Size */
            c_memorySize?: string;
            c_memoryType?: ("0010" | "0020" | "0030" | "0040" | "0050" | "0060" | "0070" | "0080" | "0090")[];
            c_musicStorage?: string;
            c_opticalZoom?: string;
            /**
             * @description Type of Outerwear for search refinement
             * @enum {string}
             */
            c_outerwearType?: "0010" | "0020" | "0030" | "0040" | "0050" | "0060" | "0070" | "0080";
            c_portableAudioType?: ("0010" | "0020" | "0030")[];
            /** @enum {string} */
            c_refinementColor?: "beige" | "black" | "blue" | "brown" | "green" | "grey" | "miscellaneous" | "navy" | "orange" | "pink" | "purple" | "red" | "white" | "yellow";
            c_resolution?: string;
            /**
             * @description Type of Sandal for search refinement
             * @enum {string}
             */
            c_sandalType?: "0010" | "0020" | "0030";
            /** @description test attribute */
            c_sheets?: ("value1" | "value2" | "value3")[];
            /**
             * @description Type of Shoe for search refinements
             * @enum {string}
             */
            c_shoeType?: "0010" | "0020" | "0030" | "0040" | "0050" | "0060" | "0070" | "0080" | "0090" | "0100" | "0110";
            /** @description This attribute is used for all footwear, apparel and accessory sizing for men, women and kids products. */
            c_size?: string;
            c_skinConcern?: ("comprehensive" | "dryTight" | "liftingLossFirm")[];
            c_styleNumber?: string;
            c_tabDescription?: components["schemas"]["markup_text"];
            c_tabDetails?: components["schemas"]["markup_text"];
            /** @description Type of tops in clothing */
            c_topType?: string;
            c_tvSignalFormat?: string;
            c_tvSize?: string;
            /** @enum {string} */
            c_tvType?: "0010" | "0020" | "0030" | "0040";
            c_tvWarranty?: string;
            c_videoStorage?: string;
            /** @description Attribute used for apparel waist sizing. */
            c_waist?: string;
            /** @description This attribute is used for shoe widths for mens, womens and kids. */
            c_width?: string;
            classification_category?: components["schemas"]["catalog_category_id"];
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            /** @description The ID of the product's default variant. */
            default_variant_id?: string;
            /** @description The European Article Number of the product. */
            ean?: string;
            /** @description The ID (SKU) of the product. */
            id?: string;
            image?: components["schemas"]["media_file"];
            /** @description The array of product image groups. */
            image_groups?: components["schemas"]["image_group"][];
            /** @description The flag that indicates if the product is in stock, or not. This is a calculated value. */
            in_stock?: boolean;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /** @description A link to the product. */
            link?: string;
            /** Format: localized */
            localized_tax_class_id?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The localized long description of the product.
             */
            long_description?: {
                [key: string]: components["schemas"]["markup_text"];
            };
            /** @description The name of the product's manufacturer. */
            manufacturer_name?: string;
            /** @description The SKU of the product's manufacturer. */
            manufacturer_sku?: string;
            master?: components["schemas"]["master"];
            /**
             * Format: localized
             * @description The localized name of the product.
             */
            name?: {
                [key: string]: string;
            };
            /** @description The flag that indicates if the product is online, or not. This is a calculated value. */
            online?: boolean;
            /**
             * Format: site-specific
             * @description The site specific online status of the product.
             */
            online_flag?: {
                [key: string]: boolean;
            };
            /** @description The ID of the catalog that owns the product. */
            owning_catalog_id?: string;
            /**
             * Format: localized
             * @description The localized name of the catalog that owns the product.
             */
            owning_catalog_name?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The localized page description of the product.
             */
            page_description?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The localized page keywords of the product.
             */
            page_keywords?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The localized page title of the product.
             */
            page_title?: {
                [key: string]: string;
            };
            /**
             * Format: double
             * @description The price of the product.
             */
            price?: number;
            /** @description The currency code for product's price. */
            price_currency?: string;
            /**
             * Format: double
             * @description The price per unit of the product
             */
            price_per_unit?: number;
            /** @description The catalog categories that are primary for the product */
            primary_categories?: components["schemas"]["catalog_category_id"][];
            /** @description The id of the products primary category. */
            primary_category_id?: string;
            /** @description The array of product bundles which the product belongs to. */
            product_bundles?: components["schemas"]["product"][];
            /** @description The array of product options. This is applicable for products of type "option". */
            product_options?: components["schemas"]["product_option"][];
            /** @description The array of product sets which the product belongs to. */
            product_sets?: components["schemas"]["product"][];
            /**
             * Format: site-specific
             * @description The site specific searchable status of the product.
             */
            searchable?: {
                [key: string]: boolean;
            };
            /** @description The array of set products which the product includes. */
            set_products?: components["schemas"]["product"][];
            /**
             * Format: localized
             * @description The localized short description of the product.
             */
            short_description?: {
                [key: string]: components["schemas"]["markup_text"];
            };
            /** @description The catalog categories that the product is assigned to */
            tax_class_id?: string;
            type?: components["schemas"]["product_type"];
            /** @description The sales unit of the product. */
            unit?: string;
            /** @description The unitMeasure of the product. */
            unit_measure?: string;
            /**
             * Format: double
             * @description The unitQuantity of the product.
             */
            unit_quantity?: number;
            /** @description The Universal Product Code of the product. */
            upc?: string;
            /**
             * Format: site-specific
             * @description The time when product is valid from.
             */
            valid_from?: {
                [key: string]: string;
            };
            /**
             * Format: site-specific
             * @description The time when product is valid to.
             */
            valid_to?: {
                [key: string]: string;
            };
            /** @description The array of variants of the product. This is applicable for product types "master" and "variation_group" only. */
            variants?: components["schemas"]["variant"][];
            /**
             * @description The sorted array of variation attributes assigned to the product. This is applicable for product types "master",
             *      "variation_group" and "variant" only.
             */
            variation_attributes?: components["schemas"]["variation_attribute"][];
            /** @description The array of variation groups in the product. This is applicable for product type "master" only. */
            variation_groups?: components["schemas"]["variation_group"][];
            /**
             * @description The variation values selected for the product in variation attribute id and value pairs. This is applicable for product types "variant" and
             *      "variation_group" only.
             *
             *              Only for type variant and variation group.
             */
            variation_values?: {
                [key: string]: string;
            };
        };
        /** @description <p>Document representing a product inventory record.</p> */
        product_inventory_record: {
            allocation?: components["schemas"]["product_inventory_record_allocation"];
            /**
             * Format: double
             * @description The quantity of items available to sell (ATS). This is calculated as the allocation plus the
             *      preorderBackorderAllocation minus the turnover.
             */
            ats?: number;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            /**
             * Format: date-time
             * @description The date that the item is expected to be in stock.
             */
            in_stock_date?: string;
            /** @description The user supplied ID of the inventory list. */
            inventory_list_id?: string;
            /**
             * Format: double
             * @description The sum of all inventory transactions (decrements and increments) that have been recorded subsequent to the
             *      allocation was reset date. The quantity value can be negative due to higher quantity of inventory decrements than
             *      increments.
             */
            inventory_turnover?: number;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /** @description The URL that is used to get this instance. */
            link?: string;
            /** @description The flag that determines if the product is perpetually in stock. */
            perpetual_flag?: boolean;
            /**
             * Format: double
             * @description The quantity of items that are allocated for sale, beyond the initial stock allocation.
             */
            pre_order_back_order_allocation?: number;
            /**
             * @description The enum holding the records pre-backorder-handling configuration. Possible values are NONE, PREORDER and
             *      BACKORDER. Method returns NONE in case the record pre-backorder-handling-code is null or unknown.
             * @enum {string}
             */
            pre_order_back_order_handling?: "none" | "preorder" | "backorder";
            /** @description The user supplied ID of the product. */
            product_id?: string;
            /** @description The name of the product. */
            product_name?: string;
            /**
             * Format: double
             * @description The on order quantity, the quantity of all transactions for this record since the allocation reset date.
             */
            quantity_on_order?: number;
            /**
             * Format: double
             * @description The current stock level. This is calculated as the allocation minus the turnover.
             */
            stock_level?: number;
        };
        /** @description <p>Document representing a product inventory record allocation.</p> */
        product_inventory_record_allocation: {
            /**
             * Format: double
             * @description The allocation quantity that is currently set. The quantity unit is the same unit as the product itself.
             */
            amount?: number;
            /**
             * Format: date-time
             * @description The date the allocation quantity was initialized or reset.
             */
            reset_date?: string;
        };
        /** @description <p>Document representing an unfiltered list of inventory records.</p> */
        product_inventory_records: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            /** @description The collection of product inventory records. */
            data?: components["schemas"]["product_inventory_record"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a product option</p> */
        product_option: {
            /**
             * Format: localized
             * @description The localized custom name of the product option.
             */
            custom_name?: {
                [key: string]: string;
            };
            /** @description The default product option value. */
            default_product_option_value?: string;
            /**
             * Format: localized
             * @description The localized description of the product option.
             */
            description?: {
                [key: string]: string;
            };
            /** @description The object attribute definition id which is also the identifier for the product option. */
            id?: string;
            image?: components["schemas"]["media_file"];
            /** @description The URL link to the product option. */
            link?: string;
            /** @description The name of the object attribute definition. */
            name?: string;
            /** @description The selected option value of the product option. */
            selected_option_value?: string;
            /** @description The flag that indicates if the product option is shared or local. */
            shared?: boolean;
            /**
             * @description The sorting mode for the product option values.
             * @enum {string}
             */
            sorting_mode?: "byexplicitorder" | "byoptionprice";
            /** @description The sorted array of values of the product option. */
            values?: components["schemas"]["product_option_value"][];
        };
        /** @description <p>Document representing a product option Value</p> */
        product_option_value: {
            /** @description Flag indicating if the product option value is the default value for the product option. */
            default_product_option_value?: boolean;
            /** @description The id of the product option value. */
            id?: string;
            /** @description The URL link to the product option value. */
            link?: string;
            /** @description The list of prices in the product option value. */
            option_prices?: components["schemas"]["money"][];
            /** @description The sku extension of the product option value. */
            sku_extension?: string;
            /**
             * Format: localized
             * @description The localized value of the product option.
             */
            value?: {
                [key: string]: string;
            };
        };
        /** @description <p>Document representing an unfiltered list of product option values.</p> */
        product_option_values: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["product_option_value"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of product options.</p> */
        product_options: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["product_option"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a product search result.</p> */
        product_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["product"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing a product type.</p> */
        product_type: {
            /** @description A flag indicating whether the product is a bundle. */
            bundle?: boolean;
            /** @description A flag indicating whether the product is bundled. */
            bundled?: boolean;
            /** @description A flag indicating whether the product is a standard item. */
            item?: boolean;
            /** @description A flag indicating whether the product is a master. */
            master?: boolean;
            /** @description A flag indicating whether the product is an option. */
            option?: boolean;
            /** @description A flag indicating whether the product is part of product set. */
            part_of_product_set?: boolean;
            /** @description A flag indicating whether the product is part of retail set. */
            part_of_retail_set?: boolean;
            /** @description A flag indicating whether the product is a retail set. */
            retail_set?: boolean;
            /** @description A flag indicating whether the product is a set. */
            set?: boolean;
            /** @description A flag indicating whether the product is a variant. */
            variant?: boolean;
            /** @description A flag indicating whether the product is a variation group. */
            variation_group?: boolean;
        };
        /**
         * @description <p>Document representing a promotion. Unless otherwise stated, attributes of this document are not supported when using
         *      the Open Commerce API to update multiple promotions at once.</p>
         */
        promotion: {
            /**
             * @description Determines whether or not this promotion is archived. This attribute is allowed to be updated when using the Open
             *      Commerce API to update multiple promotions at once.
             */
            archived?: boolean;
            assignment_information?: components["schemas"]["promotion_assignment_information"];
            /**
             * Format: localized
             * @description The localized callout message of the promotion.
             */
            callout_msg?: {
                [key: string]: components["schemas"]["markup_text"];
            };
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            /**
             * @description The ISO 4217 mnemonic code of the currency this promotion is restricted to. If not populated, then there is no
             *      currency restriction on the promotion.
             */
            currency_code?: string;
            /**
             * @description Determines whether or not this promotion ignores the global product exclusions for promotions. This attribute is
             *      allowed to be updated when using the Open Commerce API to update multiple promotions at once.
             */
            disable_globally_excluded?: boolean;
            /**
             * @description Determines whether or not this promotion is enabled. This attribute is allowed to be updated when using the Open
             *      Commerce API to update multiple promotions at once.
             */
            enabled?: boolean;
            /**
             * @description Determines if the promotion can be combined with other promotions of the same promotion class or if it cannot be
             *      combined with any other promotions. This attribute is allowed to be updated when using the Open Commerce API to
             *      update multiple promotions at once.
             * @enum {string}
             */
            exclusivity?: "no" | "class" | "global";
            /** @description The id for the promotion. */
            id?: string;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /** @description A URL that is used to get the details of this promotion. */
            link?: string;
            /**
             * Format: localized
             * @description The user supplied name of this promotion, which can be localized
             */
            name?: {
                [key: string]: string;
            };
            /**
             * @description The class of the promotion. If the promotion class is modified, then the promotion rule and all of its values,
             *      such as whether or not to disable global product exclusions, will be reset.
             * @enum {string}
             */
            promotion_class?: "product" | "shipping" | "order";
            /**
             * @description Returns the list of tags assigned to this promotion. If used to set the tags on a promotion, the promotion will
             *      only have the tags passed in the input. Any existing tags will be removed.
             */
            tags?: components["schemas"]["tag"][];
        };
        promotion_abtest_group_assignment: {
            abtest_description?: string;
            abtest_id?: string;
            enabled?: boolean;
            schedule?: components["schemas"]["schedule"];
            segment_description?: string;
            segment_id?: string;
        };
        promotion_assignment_information: {
            /**
             * @description If there is only one assignment, and that assignment is an A/B test segment, the id of the A/B test the segment
             *      belongs to. Otherwise, empty.
             */
            abtest_id?: string;
            /**
             * @description If there is only one assignment, and that assignment is an A/B test segment, the id of the A/B test segment.
             *      Otherwise, empty.
             */
            abtest_segment_id?: string;
            /** @description true if the individual assignment or the multiple assignments are currently active (applicable only for non default schedule assignments i.e. either campaign or A/B test schedule). */
            active?: boolean;
            /** @description A list of currently active A/B tests this is assigned to. */
            active_abtest_assignments?: components["schemas"]["promotion_abtest_group_assignment"][];
            /** @description A list of currently active campaigns this is assigned to. */
            active_campaign_assignments?: components["schemas"]["promotion_campaign_assignment"][];
            /** @description If there is only one assignment, and that assignment is a campaign, the id of the campaign. Otherwise, empty. */
            campaign_id?: string;
            enabled?: boolean;
            /**
             * Format: date-time
             * @description The end date of the container of the assignment (a Campaign or ABTest). If schedule_type is
             *      schedule_type : "multiple" or schedule_type : "none", then then result will be null. Also, a null
             *      date will also return null.
             */
            end_date?: string;
            schedule?: components["schemas"]["schedule"];
            /**
             * @description If there is only one active assignment, or no active assignments and one upcoming assignment, this is that type
             *      of assignment (schedule_type : "campaign" or schedule_type : "abtest"). If there are no
             *      assignments, it will be schedule_type : "none", otherwise, schedule_type : "multiple".
             * @enum {string}
             */
            schedule_type?: "none" | "campaign" | "abtest" | "multiple";
            /**
             * Format: date-time
             * @description The start date of the container of the assignment (a Campaign or ABTest). If schedule_type is
             *      schedule_type : "multiple" or schedule_type : "none", then then result will be null. Also, a null
             *      date will also return null.
             */
            start_date?: string;
            /** @description A list of upcoming A/B tests this is assigned to. */
            upcoming_abtest_assignments?: components["schemas"]["promotion_abtest_group_assignment"][];
            /** @description A list of upcoming campaigns this is assigned to. */
            upcoming_campaign_assignments?: components["schemas"]["promotion_campaign_assignment"][];
        };
        /** @description <p>Document representing a promotion campaign assignment.</p> */
        promotion_campaign_assignment: {
            campaign?: components["schemas"]["campaign"];
            /** @description The id of the campaign. */
            campaign_id?: string;
            /** @description The sorted array of assigned coupon ids. */
            coupons?: string[];
            /**
             * @description True if the assigned promotion is coupon based. When set to false, Coupons in the campaign and on the
             *      PromotionCampaignAssignment are ignored. The default value is true.
             */
            coupons_based?: boolean;
            /** Format: date-time */
            creation_date?: string;
            /** @description The sorted array of assigned customer groups. */
            customer_groups?: string[];
            /**
             * @description True if the assigned promotion is customer group based. When set to false, Customer Groups in the campaign and on
             *      the PromotionCampaignAssignment are ignored. The default value is true.
             */
            customer_groups_based?: boolean;
            /** @description The description of the promotion campaign assignment. */
            description?: string;
            /** @description True if the assignment resource is enabled */
            enabled?: boolean;
            /** Format: date-time */
            last_modified?: string;
            /** @description link for convenience */
            link?: string;
            promotion?: components["schemas"]["promotion"];
            /** @description The id of the Promotion. */
            promotion_id?: string;
            /**
             * Format: int32
             * @description The rank of promotion campaign assignment
             */
            rank?: number;
            /**
             * @description A constant indicating that one or all qualifier conditions must be
             *      met in order for the promotion to apply for a given customer.
             *      Valid values are "any" and "all".
             * @enum {string}
             */
            required_qualifier?: "any" | "all";
            schedule?: components["schemas"]["schedule"];
            /**
             * @description True if the assigned promotion is source code group based. When set to false, Source Code Groups in the campaign and on
             *      the PromotionCampaignAssignment are ignored. The default value is true.
             */
            source_code_based?: boolean;
            /** @description The sorted array of assigned source code groups. */
            source_code_groups?: string[];
        };
        /** @description <p>Document representing a promotion campaign assignment search result.</p> */
        promotion_campaign_assignment_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["promotion_campaign_assignment"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing a promotion search result.</p> */
        promotion_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["promotion"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>A set of promotions</p> */
        promotions: {
            /** Format: int32 */
            count?: number;
            /** @description The set of promotions */
            data?: components["schemas"]["promotion"][];
            expand?: string[];
            next?: string;
            previous?: string;
            select?: string;
            /** Format: int32 */
            start?: number;
            /** Format: int32 */
            total?: number;
        };
        /**
         * @description <p>Document representing a query. A query contains a set of objects that define criteria
         *      used to select records. A query can contain one of the following:
         *      <ul>
         *      <li> match_all_query - returns all records. </li>
         *      <li> term_query - matches records where a field (or fields) exactly match some simple value (including null). </li>
         *      <li> text_query - matches records where a field (or fields) contain a search phrase. </li>
         *      <li> boolean_query - formulates a complex boolean expression using query objects as criteria. </li>
         *      <li> filtered_query - allows for filtering of records based on both a query and a filter. </li>
         *      </ul></p>
         */
        query: unknown;
        /**
         * @description <p>Document representing a query filter. A query filter wraps any query and allows it to be used as a filter.
         *
         *       <b> Example: </b>  (coupon_id contains "disabled" AND (enabled=false OR active=false))
         *       <pre>
         *      query : {
         *         filtered_query: {
         *             query: { text_query: { fields: ["coupon_id"], search_phrase: "disabled" } },
         *             filter: {
         *                 query_filter: {
         *                     query: {
         *                         term_query: { fields: ["enabled","active"], operator: "is", values: [ false ] }
         *                     }
         *                 }
         *             }
         *         }
         *      }
         *       </pre></p>
         */
        query_filter: {
            query: components["schemas"]["query"];
        };
        /**
         * @description <p> Document representing a range comparison with a range filter, named Range2Filter. </p>
         *
         *       <p> A Range2Filter allows you to restrict a search result to hits where a range defined by specified attributes has a certain relationship to a specified range. </p>
         *       <p> The first range (R1) is defined by a pair of attributes ("from_field" and "to_field") that specify the extent of a range, such as the attributes "valid_from" and "valid_to". </p>
         *       <p> The second range (R2) is defined by "from_value" and "to_value". </p>
         *       <p> The filter mode specifies the method used to compare the two ranges: </p>
         *       <ul>
         *         <li>  overlap: R1 overlaps fully or partially with R2 </li>
         *         <li>  containing: R1 contains R2 </li>
         *         <li>  contained: R1 is contained in R2 </li>
         *       </ul>
         *       <p> The range filter supports several value types, and relies on the natural sorting of the value type
         *      for range interpretation. Value ranges can be open-ended (at one end only). You can configure whether the
         *      lower and upper bounds are inclusive or exclusive. </p>
         *       <p> A range 2 filter is useful for general restrictions that can be shared between searches (like a static date range) because
         *      the filter result is cached in memory. Range filters are not appropriate if the range is expected to be different for
         *      every query (for example, if the user controls the date range down to the hour via a UI control).  Range filters
         *      are inclusive by default. </p>
         *
         *       <p> <b> Example: </b>  (valid dates overlap with the range January 1, 2007 through January 1, 2017)
         *       <pre>
         *      "query" : {
         *             "filtered_query": {
         *                "filter": {
         *                     "range2_filter": {
         *                         "from_field": "valid_from",
         *                         "to_field": "valid_to",
         *                         "filter_mode":"overlap",
         *                         "from_value": "2007-01-01T00:00:00.000Z",
         *                         "to_value": "2017-01-01T00:00:00.000Z"
         *                     }
         *                },
         *                "query": { "match_all_query": {} }
         *            }
         *        }
         *       </pre> </p>
         */
        range2_filter: {
            /**
             * @description Compare mode: overlap, containing, or contained. If not specified, the default is overlap.
             * @enum {string}
             */
            filter_mode?: "overlap" | "containing" | "contained";
            /** @description The field name of the field that starts the first range. */
            from_field: string;
            /** @description Indicates whether the lower bound of the second range is inclusive. If not specified, the default is true. Set to false to make the lower bound exclusive. */
            from_inclusive?: boolean;
            /** @description The lower bound of the second range. If not specified, the range is  open-ended with respect to the lower bound. You can't leave both the lower and upper bounds open-ended. */
            from_value?: Record<string, never>;
            /** @description The field name of the field that ends the first range. */
            to_field: string;
            /** @description Indicates whether the upper bound of the second range is inclusive. If not specified, the default is true. Set to false to make the lower bound exclusive. */
            to_inclusive?: boolean;
            /** @description The upper bound of the second range. If not specified, the range is  open-ended with respect to the upper bound. You can't leave both the upper and lower bounds open-ended. */
            to_value?: Record<string, never>;
        };
        /**
         * @description <p>Document representing a range filter.
         *
         *      A range filter allows you to restrict a search result to hits that have values for a given attribute that fall into a
         *      given value range. The range filter supports several value types, and relies on the natural sorting of the value type
         *      for range interpretation. Value ranges can be open-ended (at one end only). You can configure whether the
         *      lower and upper bounds are inclusive or exclusive.
         *
         *      A range filter is useful for general restrictions that can be shared between searches (like a static date range) because
         *      the filter result is cached in memory. Range filters are not appropriate if the range is expected to be different for
         *      every query (for example, if the user controls the date range down to the hour via a UI control).  Range filters
         *      are inclusive by default.
         *
         *       <b> Example: </b>  ( redemption_count BETWEEN (0,10] )
         *       <pre>
         *         query: {
         *             filtered_query: {
         *                 query: { match_all_query: {} },
         *                 filter: {
         *                     range_filter: {
         *                         field: "redemption_count",
         *                         from: 0,
         *                         to: 10,
         *                         from_inclusive: false
         *                     }
         *                 }
         *             }
         *         }
         *       </pre></p>
         */
        range_filter: {
            /** @description The search field. */
            field: string;
            /** @description The lower bound of the filter range. If not specified, the range is  open-ended with respect to the lower bound. You can't leave both the lower and upper bounds open-ended. */
            from?: Record<string, never>;
            /** @description Indicates whether the lower bound of the range is inclusive. If not specified, the default is true. Set to false to make the lower bound exclusive. */
            from_inclusive?: boolean;
            /** @description The upper bound of the filter range. If not specified, the range is  open-ended with respect to the upper bound. You can't leave both the upper and lower bounds open-ended. */
            to?: Record<string, never>;
            /** @description Indicates whether the upper bound of the range is inclusive. If not specified, the default is true. Set to false to made the upper bound  exclusive. */
            to_inclusive?: boolean;
        };
        /** @description <p>The recommender object</p> */
        recommender: {
            /** @description The description of the recommender */
            description?: string;
            /** @description The name of the recommender */
            name?: string;
        };
        /** @description <p>A list of recommenders available for use in recommendation requests.</p> */
        recommenders_result: {
            /** @description The recommender objects */
            recommenders?: components["schemas"]["recommender"][];
        };
        /** @description <p>Document representing a schedule recurrence.</p> */
        recurrence: {
            /**
             * @description The days of week for recurrence.
             * @enum {array}
             */
            day_of_week?: "monday" | "tuesday" | "wednesday" | "thursday" | "friday" | "saturday" | "sunday";
            time_of_day?: components["schemas"]["time_of_day"];
        };
        /** @description <p>Document representing a coupon redemption limit.</p> */
        redemption_limit_per_period: {
            /**
             * Format: int32
             * @description The limit on the number of times a coupon can be redeemed for a specified redemption time period.
             */
            limit?: number;
            /**
             * Format: int32
             * @description The redemption time period.
             */
            redemption_time_frame?: number;
        };
        /** @description <p>Document representing a coupon.</p> */
        redemption_limits: {
            /**
             * Format: int32
             * @description The redemption limit per code
             */
            limit_per_code?: number;
            /**
             * Format: int32
             * @description The redemption limit per customer
             */
            limit_per_customer?: number;
            limit_per_time_frame?: components["schemas"]["redemption_limit_per_period"];
        };
        resource_info: {
            /** @description Allowed Origins */
            allowed_origins?: string[];
            /**
             * @description API Type
             * @enum {string}
             */
            api_type: "data" | "shop";
            /** @description An array of resources */
            resources: components["schemas"]["resource_object"][];
            /** @description Response Header */
            response_headers?: {
                [key: string]: string;
            };
        };
        /** @description <p>Object to represent a resource in ocapi_config_api_request</p> */
        resource_object: {
            /**
             * Format: int32
             * @description Resource Cache time
             */
            cache_time?: number;
            /** @description Configuration of the resource */
            config?: {
                [key: string]: string;
            };
            /** @description Allowed methods of the resource */
            methods: string[];
            /** @description Indicate if the personalized caching is enabled for the resource */
            personalized_caching_enabled?: boolean;
            /** @description Read attributes of the resource */
            read_attributes?: string;
            /** @description Resource ID */
            resource_id: string;
            version_range?: components["schemas"]["version_range_object"];
            /** @description Write attributes of the resource */
            write_attributes?: string;
        };
        /** @description <p>Data that can be used to get the next and previous page of a Data API results object.</p> */
        result_page: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
        };
        /** @description <p>Document representing an access role.</p> */
        role: {
            /** Format: date-time */
            creation_date?: string;
            /** @description The role description. */
            description?: string;
            /** @description The role ID. */
            id?: string;
            /** Format: date-time */
            last_modified?: string;
            /** @description URL that is used to get this instance.  This property is computed and cannot be modified. */
            link?: string;
            permissions?: components["schemas"]["role_permissions"];
            /**
             * Format: int32
             * @description Number of users assigned to the role.
             */
            user_count?: number;
            /** @description Flag whether this role is allowed to manage users or other access roles. */
            user_manager?: boolean;
            /** @description The users assigned to the access role. Available through expands. */
            users?: components["schemas"]["user"][];
        };
        /** @description <p>Document representing a functional permission.</p> */
        role_functional_permission: {
            /** @description The name of the functional permission. */
            name: string;
            /** @description The permission type ("functional"). */
            type: string;
            /** @description The non domain specific value for the functional permission, e.g. ACCESS or READONLY. */
            value?: string;
            /** @description The map of value per domain for the functional permission, e.g. ACCESS or READONLY per domain name. */
            values?: {
                [key: string]: string;
            };
        };
        /** @description <p>Document listing the functional permissions assigned to a certain role.</p> */
        role_functional_permissions: {
            /** @description The list of organization functional permissions. */
            organization?: components["schemas"]["role_functional_permission"][];
            /** @description The list of site functional permissions. */
            site?: components["schemas"]["role_functional_permission"][];
        };
        /** @description <p>Document representing a locale permission.</p> */
        role_locale_permission: {
            /** @description The related locale id of the locale permission. */
            locale_id: string;
            /** @description The permission type ("locale"). */
            type: string;
            /** @description The non domain specific value for the locale permission, e.g. ACCESS or READONLY. */
            value?: string;
            /** @description The map of value per domain for the locale permission, e.g. ACCESS or READONLY per domain name. */
            values?: {
                [key: string]: string;
            };
        };
        /** @description <p>Document listing the locale permissions assigned to a certain role.</p> */
        role_locale_permissions: {
            /** @description The list of unscoped locale permissions. */
            unscoped?: components["schemas"]["role_locale_permission"][];
        };
        /** @description <p>Document representing a module permission.</p> */
        role_module_permission: {
            /** @description The permission application (e.g. "bm", "csc"). */
            application: string;
            /** @description The related menu action name of the module permission. */
            name: string;
            /** @description Flag to indicate a system menu action. This is <code>false</code> for custom menu actions. */
            system?: boolean;
            /** @description The permission type ("module"). */
            type: string;
            /** @description The non domain specific value for the module permission, e.g. ACCESS or READONLY. */
            value?: string;
            /** @description The map of value per domain for the module permission, e.g. ACCESS or READONLY per domain name. */
            values?: {
                [key: string]: string;
            };
        };
        /** @description <p>Document listing the module permissions assigned to a certain role.</p> */
        role_module_permissions: {
            /** @description The list of organization module permissions. */
            organization?: components["schemas"]["role_module_permission"][];
            /** @description The list of site module permissions. */
            site?: components["schemas"]["role_module_permission"][];
        };
        /** @description <p>Document listing the permissions assigned to a certain role (accessible by type).</p> */
        role_permissions: {
            functional?: components["schemas"]["role_functional_permissions"];
            locale?: components["schemas"]["role_locale_permissions"];
            module?: components["schemas"]["role_module_permissions"];
            webdav?: components["schemas"]["role_webdav_permissions"];
        };
        /**
         * @description <p>Document representing an role search.
         *
         *      Note that only either an user ID or a permission can be provided (or none), but not both. When one of them is provided,
         *      the further query elements will filter the respective role set (meaning the user ID / permission is AND-connected to the query definition).
         *
         *      When a permission definition is using a site scope, it can contain only one site.
         *
         *      When optional fields in the permission definitions are not provided, they will be treated as 'don't care' (so its e.g. possible so search for
         *      permission to site-specific BM modules without providing a site, and the search will return all roles having that permission for any site).</p>
         */
        role_search_request: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            permissions?: components["schemas"]["role_permissions"];
            query: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /** @description The id of the user whose roles are to be searched. */
            user_id?: string;
        };
        /** @description <p>Document representing an access role search result.</p> */
        role_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["role"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing a WebDAV permission.</p> */
        role_webdav_permission: {
            /** @description The related folder of the WebDAV permission. */
            folder: string;
            /** @description The permission type ("webdav"). */
            type: string;
            /** @description The non domain specific value for the WebDAV permission, e.g. ACCESS or READONLY. */
            value?: string;
            /** @description The map of value per domain for the WebDAV permission, e.g. ACCESS or READONLY per domain name. */
            values?: {
                [key: string]: string;
            };
        };
        /** @description <p>Document listing the WebDAV permissions assigned to a certain role.</p> */
        role_webdav_permissions: {
            /** @description The list of unscoped WebDAV permissions. */
            unscoped?: components["schemas"]["role_webdav_permission"][];
        };
        /** @description <p>Document representing a list of access roles.</p> */
        roles: {
            /** Format: int32 */
            count?: number;
            /** @description The list of access roles. */
            data?: components["schemas"]["role"][];
            expand?: string[];
            next?: string;
            previous?: string;
            select?: string;
            /** Format: int32 */
            start?: number;
            /** Format: int32 */
            total?: number;
        };
        /** @description <p>Document representing a customer group rule</p> */
        rule: {
            /** @description The description of the rule, describing its conditions in natural language. Property is read-only. */
            description?: string;
        };
        /** @description <p>Document representing a time schedule for slots.</p> */
        schedule: {
            /**
             * Format: date-time
             * @description The date to end of validity. ISO8601 date time format: yyyy-MM-dd'T'HH:mm:ssZ.
             */
            end_date?: string;
            recurrence?: components["schemas"]["recurrence"];
            /**
             * Format: date-time
             * @description The date to start validity. ISO8601 date time format: yyyy-MM-dd'T'HH:mm:ssZ.
             */
            start_date?: string;
        };
        /** @description <p>Document representing a search request for retrieving items within the Data API. The query is a potentially complex set of expressions. The fields that each query supports are defined within the search resource.</p> */
        search_request: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            query: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
        };
        /** @description <p>Request body to update the order shipping address.</p> */
        shipping_address_update_request: {
            address1?: string;
            address2?: string;
            city?: string;
            company_name?: string;
            country_code?: string;
            first_name?: string;
            full_name?: string;
            id?: string;
            job_title?: string;
            last_name?: string;
            phone?: string;
            post_box?: string;
            postal_code?: string;
            salutation?: string;
            second_name?: string;
            state_code?: string;
            suffix?: string;
            suite?: string;
            title?: string;
        };
        /** @description <p>Document representing a site.</p> */
        site: {
            /** @description The cartridge Path of the site */
            cartridges?: string;
            /** Format: date-time */
            creation_date?: string;
            customer_list_link?: components["schemas"]["customer_list_link"];
            /**
             * Format: localized
             * @description The description of this site.
             */
            description?: {
                [key: string]: string;
            };
            /**
             * Format: localized
             * @description The display name entered by the user.
             */
            display_name?: {
                [key: string]: string;
            };
            /** @description The id of this site. */
            id: string;
            /** @description The deletion status of this site, true if in deletion */
            in_deletion?: boolean;
            /** Format: date-time */
            last_modified?: string;
            /** @description A link directly to the site */
            link?: string;
            /** @enum {string} */
            storefront_status?: "online" | "maintenance" | "to_be_deleted" | "protected";
        };
        /** @description <p>Represents a set of preferences attached at the organization level.</p> */
        site_preferences: {
            /** @description A URL that returns the full details for a custom preference */
            link?: string;
            site?: components["schemas"]["site"];
        };
        /** @description <p>Object to represent a site configuration and available resources in the site configuration.</p> */
        site_resource_info: {
            /** @description Site configuration */
            site_configs: components["schemas"]["resource_info"][];
            /** @description Site ID */
            site_id?: string;
        };
        /** @description <p>Document representing a site search result.</p> */
        site_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["site"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of sites.</p> */
        sites: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["site"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a slot</p> */
        slot: {
            /**
             * @description A slot context
             * @enum {string}
             */
            context_type?: "global" | "category" | "folder";
            /** Format: date-time */
            creation_date?: string;
            /** @description The user supplied description of the slot */
            description?: string;
            /** Format: date-time */
            last_modified?: string;
            /** @description A link to the slot */
            link?: string;
            /** @description A preview URL the slot */
            preview_url?: string;
            /** @description A list of slotconfigurations this slot has */
            slot_configurations?: components["schemas"]["slot_configuration"][];
            /** @description The id for the slot */
            slot_id: string;
        };
        /** @description <p>Document representing a slot configuration.</p> */
        slot_configuration: {
            /** @description A flag indicating whether the configuration is the default one for the slot. */
            200?: boolean;
            assignment_information?: components["schemas"]["slot_configuration_assignment_information"];
            /**
             * Format: localized
             * @description The call out message.
             */
            callout_msg?: {
                [key: string]: components["schemas"]["markup_text"];
            };
            /** @description The id of this configuration. */
            configuration_id?: string;
            /**
             * @description The context of the slot. Ignored in input documents.
             * @enum {string}
             */
            context?: "global" | "category" | "folder";
            /**
             * @description When the context is <i>category</i>, this is a <i>category_id</i>; when
             *      the context is <i>folder</i>, this is a <i>folder_id</i>; and when the
             *      context is <i>global</i>, this is obsolete. This is ignored in input documents.
             */
            context_id?: string;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            /** @description The customer groups ids. */
            customer_groups?: string[];
            /** @description The configuration description. */
            description?: string;
            /** @description A flag indicating whether the slot is enabled. */
            enabled?: boolean;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /** @description The link. */
            link?: string;
            /**
             * Format: int32
             * @description The rank of the slot configuration on its slot. This rank has nothing to do with the rank
             *      on any campaign-assignment, because these are completely different objects. These must be
             *      updated separately.
             * @enum {integer}
             */
            rank?: 10 | 20 | 30 | 40 | 50 | 60 | 70 | 80 | 90 | 100;
            schedule?: components["schemas"]["schedule"];
            slot_content: components["schemas"]["slot_content"];
            /** @description The ID of the slot. Ignored in input documents. */
            slot_id?: string;
            /** @description The template. */
            template?: string;
            /**
             * @description The uuid of the slot configuration. This property cannot be written
             *      and is ignored in input documents.
             */
            readonly uuid?: string;
        };
        slot_configuration_abtest_group_assignment: {
            abtest_description?: string;
            abtest_id?: string;
            enabled?: boolean;
            schedule?: components["schemas"]["schedule"];
            segment_description?: string;
            segment_id?: string;
        };
        slot_configuration_assignment_information: {
            /**
             * @description If there is only one assignment, and that assignment is an A/B test segment, the id of the A/B test the segment
             *      belongs to. Otherwise, empty.
             */
            abtest_id?: string;
            /**
             * @description If there is only one assignment, and that assignment is an A/B test segment, the id of the A/B test segment.
             *      Otherwise, empty.
             */
            abtest_segment_id?: string;
            /** @description true if the individual assignment or the multiple assignments are currently active (applicable only for non default schedule assignments i.e. either campaign or A/B test schedule). */
            active?: boolean;
            /** @description A list of currently active A/B tests this is assigned to. */
            active_abtest_assignments?: components["schemas"]["slot_configuration_abtest_group_assignment"][];
            /** @description A list of currently active campaigns this is assigned to. */
            active_campaign_assignments?: components["schemas"]["slot_configuration_campaign_assignment"][];
            /** @description If there is only one assignment, and that assignment is a campaign, the id of the campaign. Otherwise, empty. */
            campaign_id?: string;
            enabled?: boolean;
            /**
             * Format: date-time
             * @description The end date of the container of the assignment (a Campaign or ABTest). If schedule_type is
             *      schedule_type : "multiple" or schedule_type : "none", then then result will be null. Also, a null
             *      date will also return null.
             */
            end_date?: string;
            schedule?: components["schemas"]["schedule"];
            /**
             * @description If there is only one active assignment, or no active assignments and one upcoming assignment, this is that type
             *      of assignment (schedule_type : "campaign" or schedule_type : "abtest"). If there are no
             *      assignments, it will be schedule_type : "none", otherwise, schedule_type : "multiple".
             * @enum {string}
             */
            schedule_type?: "none" | "campaign" | "abtest" | "multiple";
            /**
             * Format: date-time
             * @description The start date of the container of the assignment (a Campaign or ABTest). If schedule_type is
             *      schedule_type : "multiple" or schedule_type : "none", then then result will be null. Also, a null
             *      date will also return null.
             */
            start_date?: string;
            /** @description A list of upcoming A/B tests this is assigned to. */
            upcoming_abtest_assignments?: components["schemas"]["slot_configuration_abtest_group_assignment"][];
            /** @description A list of upcoming campaigns this is assigned to. */
            upcoming_campaign_assignments?: components["schemas"]["slot_configuration_campaign_assignment"][];
        };
        /** @description <p>Document representing a slot_configuration_campaign_assignment</p> */
        slot_configuration_campaign_assignment: {
            campaign?: components["schemas"]["campaign"];
            /** @description The id of the campaign that has the slot configuration assigned to it. */
            campaign_id?: string;
            /**
             * @description The slot context.
             * @enum {string}
             */
            context: "global" | "category" | "folder";
            /** Format: date-time */
            creation_date?: string;
            /** @description The list of customer groups. */
            customer_groups?: string[];
            /** @description The description of the slot configuration. */
            description?: string;
            /** @description True if the assignment resource is enabled */
            enabled?: boolean;
            /** Format: date-time */
            last_modified?: string;
            /** @description The URL to the slot configuration-campaign assignment. */
            link?: string;
            /**
             * Format: int32
             * @description The rank of the slot confiuration-campaign assignment.
             *      This is different than the rank of the slot configuration.
             */
            rank?: number;
            schedule?: components["schemas"]["schedule"];
            slot_configuration?: components["schemas"]["slot_configuration"];
            /** @description The ID of the slot configuration. */
            slot_configuration_id: string;
            /** @description The UUID of the slot configuration. */
            slot_configuration_uuid?: string;
            /** @description The ID of the slot's context, for example, the category ID for a slot with category context. */
            slot_context_id?: string;
            /** @description The ID of the slot. */
            slot_id: string;
        };
        slot_configuration_campaign_assignment_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["slot_configuration_campaign_assignment"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing a slot configuration search result.</p> */
        slot_configuration_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. This array can be empty. */
            hits?: components["schemas"]["slot_configuration"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of slot configurations.</p> */
        slot_configurations: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["slot_configuration"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing the content type for a slot.</p> */
        slot_content: {
            /**
             * Format: localized
             * @description The HTML body (valid only for type 'html').
             */
            body?: {
                [key: string]: components["schemas"]["markup_text"];
            };
            /** @description The category ids (valid only for type 'categories'). */
            category_ids?: string[];
            /** @description The content asset ids (valid only for type 'content_assets'). */
            content_asset_ids?: string[];
            /** @description The product ids (valid only for type 'products'). */
            product_ids?: string[];
            /**
             * @description The type of content in the slot.
             * @enum {string}
             */
            type: "products" | "categories" | "content_assets" | "html" | "recommended_products";
        };
        /** @description <p>Document representing a slot search result.</p> */
        slot_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["slot"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of slots.</p> */
        slots: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["slot"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a sort request.</p> */
        sort: {
            /** @description The name of the field to sort on. */
            field: string;
            /**
             * @description The sort order to be applied when sorting. When omitted, the default sort order (ASC) is used.
             * @enum {string}
             */
            sort_order?: "asc" | "desc";
        };
        /** @description <p>Document representing a product sorting rule</p> */
        sorting_rule: {
            /** Format: date-time */
            creation_date?: string;
            /** @description The description of the product sorting rule. */
            description?: string;
            /** @description the id of product sorting rule. */
            id?: string;
            /** Format: date-time */
            last_modified?: string;
            /** @description the steps involved in sorting by this rule. */
            product_sorting_rule_steps?: components["schemas"]["sorting_rule_step"][];
            /** @description The context of the rule, either site or global */
            rule_context?: string;
            site?: string;
        };
        /** @description <p>Document representing a source code group search result.</p> */
        sorting_rule_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["sorting_rule"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing a product sorting rule step</p> */
        sorting_rule_step: {
            /** @description the id for sorting attribute. */
            attribute_id?: string;
            /**
             * @description the direction of the sorting attribute
             * @enum {string}
             */
            direction?: "asc" | "desc";
            /** @description whether or not the attribute is a system attribute. */
            is_system?: boolean;
            /**
             * Format: int32
             * @description the position of product sorting rule step.
             */
            position?: number;
            /** @description The text relevance included. */
            text_relevance_included?: boolean;
            /** @description the sorting type for sorting attribute. */
            type_id?: string;
        };
        /** @description <p>Document representing a source code group</p> */
        source_code_group: {
            /** @description The active flag, a computed value based on start and end time */
            active?: boolean;
            active_redirect?: components["schemas"]["source_code_redirect_info"];
            /**
             * Format: int32
             * @description The cookie duration in days
             */
            cookie_duration?: number;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            /** @description The description */
            description?: string;
            /** @description The enabled flag for storefront to consider the source code group, default to false. */
            enabled?: boolean;
            /**
             * Format: date-time
             * @description The end time
             */
            end_time?: string;
            /** @description The id of source code group */
            id?: string;
            inactive_redirect?: components["schemas"]["source_code_redirect_info"];
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /** @description URL that is used to get this instance, read only */
            link?: string;
            /** @description Source Code specifications */
            specifications?: components["schemas"]["source_code_specification"][];
            /**
             * Format: date-time
             * @description The start time
             */
            start_time?: string;
        };
        /** @description <p>Document representing a source code group search result.</p> */
        source_code_group_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["source_code_group"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of source code groups.</p> */
        source_code_groups: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["source_code_group"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a source code redirect info</p> */
        source_code_redirect_info: {
            /** @description The location of redirect, based on the type, this can be a product location, category location, home page, content page, or just a URL */
            location?: string;
            /**
             * @description The type of redirect location, e.g. product (for a product page), category (a category page), home (for home page), page (for content), url (for a URL location)
             * @enum {string}
             */
            location_type?: "default" | "home" | "product" | "category" | "page" | "url";
        };
        /** @description <p>Document representing a source code specification</p> */
        source_code_specification: {
            /**
             * @description <p>Expression is a value for the "Source Code Specification" may be a literal source code, or it may contain wildcards.</p>
             *      <p>A literal code is simply the literal code. Valid characters are letters and numbers (no spaces).</p>
             *      <p>A wildcard allows a single source code specification to match multiple source codes. The following wildcards are supported:</p>
             *      <ul><li>? - Matches any single alpha-numeric character. For example: the source code specification 'ABC?' would match 'ABCD' or 'ABC3', but not 'ABCDE'.</li>
             *      <li>* - Matches any sequence of alpha-numeric characters. For example: the source code specification 'ABC*' would match 'ABCD', 'ABCDE', or 'ABC123'.</li>
             *      <li>[n1..n2] - Matches any number from n1 through and including n2.
             *      For example: the source code specification 'ABC[3..22]' would match 'ABC3', 'ABC4' or 'ABC22', but not 'ABC33' or 'ABCD'.</li></ul>
             */
            expression?: string;
        };
        status: {
            /** @description Status code. */
            code?: string;
            /** @description Status message. */
            message?: string;
            /**
             * @description Status shows successful operation end.
             * @enum {string}
             */
            status?: "ok" | "error";
        };
        status_metadata: {
            /** @description The client ID that is responsible for the status. */
            client_id?: string;
            /** @description The reason of the status. */
            reason?: string;
            /** @description The user login that is responsible for the status. */
            user_login?: string;
        };
        /** @description <p>Document representing a store</p> */
        store: {
            /** @description Returns the first address. */
            address1?: string;
            /** @description Returns the second address value. */
            address2?: string;
            /** @description Country Code Value - for the form values */
            c_countryCodeValue?: string;
            /** @description Store Inventory List ID */
            c_inventoryListId?: string;
            /** @description Returns the city. */
            city?: string;
            /**
             * @description The two-character country code per ISO 3166-1 alpha-2.
             * @enum {string}
             */
            country_code?: "CA" | "DE" | "US";
            /**
             * Format: date-time
             * @description Returns the value of attribute 'creationDate'.
             */
            readonly creation_date?: string;
            /** @description Email address to contact the store */
            email?: string;
            /** @description Returns the fax number . */
            fax?: string;
            /** @description The id for the store */
            id?: string;
            image?: components["schemas"]["media_file"];
            /** @description The inventory list associated with the store */
            inventory_id?: string;
            /**
             * Format: date-time
             * @description Returns the value of attribute 'lastModified'.
             */
            readonly last_modified?: string;
            /**
             * Format: double
             * @description The latitude of the store
             */
            latitude?: number;
            /** @description a URL that is used to get this instance.  The property is computed and cannot be changed. */
            link?: string;
            /**
             * Format: double
             * @description The longitude of the store
             */
            longitude?: number;
            /** @description The name of the store */
            name?: string;
            /** @description Returns the phone number. */
            phone?: string;
            /** @description Whether this store uses our Store product for Point-of-Sale */
            pos_enabled?: boolean;
            /** @description The postal code for the store */
            postal_code?: string;
            /** @description Returns the customer's state. */
            state_code?: string;
            /**
             * Format: localized
             * @description The store events (localized)
             */
            store_events?: {
                [key: string]: components["schemas"]["markup_text"];
            };
            /**
             * Format: localized
             * @description The store opening hours (localized)
             */
            store_hours?: {
                [key: string]: components["schemas"]["markup_text"];
            };
            /** @description Whether this store should appear in store locator searches */
            store_locator_enabled?: boolean;
        };
        /** @description <p>Document representing a store search result.</p> */
        store_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["store"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of stores.</p> */
        stores: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["store"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a tag</p> */
        tag: {
            /** @description The id of the tag. */
            tag_id?: string;
        };
        /**
         * @description <p>Document representing a term filter.
         *
         *      A term filter allows you to restrict a search result to hits that match (exactly) one of the values configured for the
         *      filter. A term filter is useful for general restrictions that can be shared between searches. Use term filters
         *      whenever the criterion you filter on is a shared property of multiple searches (for example, like filtering by an
         *      order status). Use term filters for fields that have a discrete and small set of values only.
         *
         *       <b> Example: </b>  (id="my_id")
         *       <pre>
         *         query: {
         *             filtered_query: {
         *                 query: { match_all_query: {} },
         *                 filter: {
         *                     term_filter: {
         *                         field: "id",
         *                         operator: "is",
         *                         values: ["my_id"]
         *                     }
         *                 }
         *             }
         *         }
         *       </pre>
         *
         *       <b> Example: </b>  (id IN ("my_id","other_id"))
         *       <pre>
         *         query: {
         *             filtered_query: {
         *                 query: { match_all_query: {} },
         *                 filter: {
         *                     term_filter: {
         *                         field: "id",
         *                         operator: "one_of",
         *                         values: ["my_id","other_id"]
         *                     }
         *                 }
         *             }
         *         }
         *       </pre>
         *
         *       <b> Example: </b>  (description=NULL)
         *       <pre>
         *         query: {
         *             filtered_query: {
         *                 query: { match_all_query: {} },
         *                 filter: {
         *                     term_filter: {
         *                         field: "description",
         *                         operator: "is_null"
         *                     }
         *                 }
         *             }
         *         }
         *       </pre></p>
         */
        term_filter: {
            /** @description The filter field. */
            field: string;
            /**
             * @description The operator to compare the field's values with the given ones.
             * @enum {string}
             */
            operator: "is" | "one_of" | "is_null" | "is_not_null" | "less" | "greater" | "not_in" | "neq";
            /** @description The filter values. */
            values?: Record<string, never>[];
        };
        /**
         * @description <p>A term query matches one (or more) value(s) against one (or more) document field(s). A document is considered a hit
         *      if one of the values matches (exactly) with at least one of the given fields.  The operator "is" can only take
         *      one value, while "one_of" can take multiple values. If multiple fields are specified, they are combined using the OR operator.
         *      The  <code> less </code>  and  <code> greater </code>  operators are not compatible with some search types.
         *      To query based on numeric bounds in those cases, you can use a  <u> range filter </u>  on a
         *       <u> filtered query </u> .
         *
         *       <b> Elastic only </b> : If used with multiple fields, the query is internally handled as a boolean OR of DisjointMaxQueries (with the dismax
         *      matching a value against all fields). The dismax makes sure that a document carrying a single term in
         *      multiple fields does not get higher scores than a document matching multiple terms in multiple fields.
         *
         *       <b> Example: </b>  (id="my_id")
         *       <pre>
         *      query: {
         *          term_query: {
         *              fields: ["id"],
         *              operator: "is",
         *              values: ["my_id"]
         *          }
         *      }
         *       </pre>
         *
         *       <b> Example: </b>  (id IN ("my_id","other_id"))
         *       <pre>
         *      query: {
         *          term_query: {
         *              fields: ["id"],
         *              operator: "one_of",
         *              values: ["my_id","other_id"]
         *          }
         *      }
         *       </pre>
         *
         *       <b> Example: </b>  (id=null)
         *       <pre>
         *      query: {
         *          term_query: {
         *             fields: ["description"],
         *             operator: "is_null"
         *         }
         *      }
         *       </pre>
         *
         *       <b> Example: </b>  ((id IN ('generic', 'keyword')) OR (description IN ('generic', 'keyword'))
         *       <pre>
         *      query: {
         *         term_query: {
         *             fields: ["id", "description"],
         *             operator: "one_of",
         *             values: ["generic","keyword"]
         *         }
         *      }
         *       </pre></p>
         */
        term_query: {
            /** @description The document field(s) the value(s) are matched against, combined with the operator. */
            fields: string[];
            /**
             * @description Returns the operator to use for the term query.
             * @enum {string}
             */
            operator: "is" | "one_of" | "is_null" | "is_not_null" | "less" | "greater" | "not_in" | "neq";
            /** @description The values the field(s) are compared against, combined with the operator. */
            values?: Record<string, never>[];
        };
        /**
         * @description <p>A text query is used to match some text (i.e. a search phrase possibly consisting of multiple terms) against one or
         *      multiple fields. In case multiple fields are provided, the phrase conceptually forms a logical OR over the fields. In
         *      this case, the terms of the phrase basically have to match the text that would result from concatenating all
         *      given fields.
         *
         *       <b> Example: </b>  (coupon_id contains "xmas" )
         *       <pre>
         *         query: {
         *             text_query: {
         *                 fields: ["coupon_id"],
         *                 search_phrase: "xmas"
         *             }
         *         }
         *       </pre>
         *
         *       <b> Example: </b>  (coupon_id contains "xmas" OR description contains "xmas")
         *       <pre>
         *         query: {
         *             text_query: {
         *                 fields: ["description", "coupon_id"],
         *                 search_phrase: "xmas"
         *             }
         *         }
         *       </pre>
         *
         *       <b> Example: </b>  (description contains "holiday" AND description contains "bojo")
         *       <pre>
         *         query: {
         *             text_query: {
         *                 fields: ["description"],
         *                 search_phrase: "holiday bogo"
         *             }
         *         }
         *       </pre></p>
         */
        text_query: {
            /** @description The document fields the search phrase has to match. */
            fields: string[];
            /** @description A search phrase which may consist of multiple terms. */
            search_phrase: string;
        };
        /** @description <p>Document representing a time schedule within a single day.</p> */
        time_of_day: {
            /**
             * Format: time
             * @description The time to start from. Time format: HH:mm:ss. Seconds
             *      are ignored and set to 0.
             */
            time_from?: string;
            /**
             * Format: time
             * @description The time to end on. Time format: HH:mm:ss. Seconds
             *      are ignored and set to 0.
             */
            time_to?: string;
        };
        /** @description <p>Document representing a user.</p> */
        user: {
            /** Format: date-time */
            creation_date?: string;
            /** @description Flag whether the user is disabled. */
            disabled?: boolean;
            /** @description The email address. */
            email: string;
            /** @description The external id. This attribute is only valid when the user uses centralized authentication. */
            external_id?: string;
            /** @description The first name. */
            first_name?: string;
            /**
             * Format: date
             * @description Last login of the user.
             */
            last_login_date?: string;
            /** Format: date-time */
            last_modified?: string;
            /** @description The last name. */
            last_name: string;
            /** @description URL that is used to get this instance.  This property is computed and cannot be modified. */
            link?: string;
            /** @description Flag whether the user is locked. */
            locked?: boolean;
            /** @description The user login. */
            login?: string;
            /**
             * @description The password. This attribute is only used to set the password upon user creation.
             *      This attribute is only valid when the user does not use centralized authentication.
             */
            password?: string;
            /**
             * Format: date-time
             * @description The user password expiration time
             */
            password_expiration_date?: string;
            /**
             * Format: date-time
             * @description The time, where the password was last modified
             */
            password_modification_date?: string;
            /**
             * @description The effective preferred data locale of the user. A locale is only considered if the user has at least read
             *      permission on the locale.
             */
            preferred_data_locale?: string;
            /** @description The preferred UI locale of the user. */
            preferred_ui_locale?: string;
            /** @description List of role ids the user is assigned to. */
            roles?: string[];
        };
        /** @description <p>Document representing an user search result.</p> */
        user_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The sorted array of search hits. Can be empty. */
            hits?: components["schemas"]["user"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing a list of users.</p> */
        users: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            /** @description The list of users. */
            data?: components["schemas"]["user"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a product variation.</p> */
        variant: {
            /**
             * Format: double
             * @description Inventory "Available to Sell" of the product.
             */
            ats?: number;
            default_product_variation?: boolean;
            image?: components["schemas"]["media_file"];
            /** @description <code>true</code> if the product is in stock, or <code>false</code> if not. */
            in_stock?: boolean;
            /** @description The URL addressing the product. */
            link?: string;
            /**
             * @description If the product is currently online.
             *      <code>true</code> if online
             *      <code>false</code> if not
             */
            online?: boolean;
            /** @description A flag indicating whether the variant is orderable. */
            orderable?: boolean;
            /**
             * Format: double
             * @description The sales price of the variant.
             */
            price?: number;
            /** @description Currency code for the price of the product. */
            price_currency?: string;
            /**
             * Format: double
             * @description The sales price of the variant.
             */
            price_per_unit?: number;
            /** @description The id (SKU) of the variant. */
            product_id: string;
            /** Format: site-specific */
            searchable?: {
                [key: string]: boolean;
            };
            /** @description variation attributes */
            variation_attributes?: components["schemas"]["variation_attribute"][];
            /** @description The actual variation attribute id - value pairs. */
            variation_values?: {
                [key: string]: string;
            };
        };
        /** @description <p>Document that represents a search on certificates and keys.</p> */
        variant_search_result: {
            /**
             * Format: int32
             * @description The number of returned documents
             */
            count?: number;
            data?: Record<string, never>[];
            /**
             * Format: int32
             * @description The zero-based index of the record that we want to start with, used to optimize special handling
             */
            db_start_record_?: number;
            /** @description List of expansions to be applied to each search results. Expands are optional */
            expand?: string[];
            /** @description The hits from the search */
            hits?: components["schemas"]["variant"][];
            next?: components["schemas"]["result_page"];
            previous?: components["schemas"]["result_page"];
            query?: components["schemas"]["query"];
            /** @description The field to be selected. */
            select?: string;
            /** @description The list of sort clauses configured for the search request. Sort clauses are optional. */
            sorts?: components["schemas"]["sort"][];
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The number of returned documents
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of variants.</p> */
        variants: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["variant"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a variation attribute.</p> */
        variation_attribute: {
            /** @description The id of the requested attribute definition. */
            attribute_definition_id: string;
            /**
             * Format: localized
             * @description The localized display name of the variation attribute definition.
             */
            attribute_definition_name?: {
                [key: string]: string;
            };
            /** @description default variation attribute value */
            default_value?: string;
            /** @description The id of the variation attribute. */
            id?: string;
            /** @description URL that is used to get this instance */
            link?: string;
            /**
             * Format: localized
             * @description The localized display name of the variation attribute.
             */
            name?: {
                [key: string]: string;
            };
            /** @description Returns the value of attribute 'shared' if attribute is local or shared */
            shared?: boolean;
            /** @description Returns the value of attribute 'slicing'. */
            slicing?: boolean;
            /** @description The sorted array of variation values. This array can be empty. */
            values?: components["schemas"]["variation_attribute_value"][];
            /**
             * @description variation attribute type
             * @enum {string}
             */
            variation_attribute_type?: "string" | "int" | "unknown";
        };
        /** @description <p>Document representing a variation attribute value.</p> */
        variation_attribute_value: {
            /**
             * Format: localized
             * @description The localized description of the variation value.
             */
            description?: {
                [key: string]: string;
            };
            image?: components["schemas"]["media_file"];
            image_swatch?: components["schemas"]["media_file"];
            link?: string;
            /**
             * Format: localized
             * @description The localized display name of the variation value.
             */
            name?: {
                [key: string]: string;
            };
            /** @description A flag indicating whether at least one variant with this variation attribute value is available to sell. */
            orderable?: boolean;
            /**
             * Format: double
             * @description The position of the value among all values of a variation attribute.
             */
            position?: number;
            /** @description The actual variation value. */
            value: string;
        };
        /** @description <p>Document representing an unfiltered list of variation attribute values.</p> */
        variation_attribute_values: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["variation_attribute_value"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing an unfiltered list of variation attributes.</p> */
        variation_attributes: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["variation_attribute"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Document representing a variation group.</p> */
        variation_group: {
            /** @description The URL addressing the product. */
            link?: string;
            /** @description A flag indicating whether the variation group is orderable. */
            orderable?: boolean;
            /**
             * Format: double
             * @description The sales price of the variation group.
             */
            price?: number;
            /**
             * Format: double
             * @description The sales price per unit of the variation group.
             */
            price_per_unit?: number;
            /** @description The id (SKU) of the variation group. */
            product_id?: string;
            /** @description The actual variation attribute id - value pairs. */
            variation_values?: {
                [key: string]: string;
            };
        };
        /** @description <p>Document representing an unfiltered list of variation groups.</p> */
        variation_groups: {
            /**
             * Format: int32
             * @description The number of returned documents.
             */
            count?: number;
            data?: components["schemas"]["variation_group"][];
            /** @description The list of expands set for the search request. Expands are optional. */
            expand?: string[];
            /** @description The URL of the next result page. */
            next?: string;
            /** @description The URL of the previous result page. */
            previous?: string;
            /** @description The fields that you want to select. */
            select?: string;
            /**
             * Format: int32
             * @description The zero-based index of the first search hit to include in the result.
             */
            start?: number;
            /**
             * Format: int32
             * @description The total number of documents.
             */
            total?: number;
        };
        /** @description <p>Object to represent the Version Range. Used in resources_object.</p> */
        version_range_object: {
            /** @description Starting version */
            from?: string;
            /** @description Ending version */
            until?: string;
        };
        /** @description <p>Document representing a WebDAV permission.</p> */
        webdav_permission: {
            /**
             * Format: localized
             * @description The description of the WebDAV permission.
             */
            description?: {
                [key: string]: string;
            };
            /** @description The folder of the WebDAV permission. */
            folder?: string;
            /** @description The permission type. */
            type?: string;
            /** @description The list of possible values for the WebDAV permission, e.g. ACCESS or READONLY. */
            values?: string[];
        };
        /** @description <p>Document representing the available WebDAV permissions.</p> */
        webdav_permissions: {
            /** @description The available WebDAV permission scopes (e.g. unscoped). */
            scopes?: string[];
            /** @description The collection of available unscoped WebDAV permissions. */
            unscoped?: components["schemas"]["webdav_permission"][];
        };
        /** @description OCAPI error/fault response returned for 4xx/5xx status codes */
        fault: {
            /** @description API version */
            _v?: string;
            fault?: {
                /** @description Error type identifier (e.g., NotFoundException, CodeVersionIdNotFoundException) */
                type: string;
                /** @description Human-readable error message */
                message: string;
                /** @description Map of argument values integrated into the message */
                arguments?: {
                    [key: string]: {
                        /** @enum {string} */
                        type?: "boolean" | "date" | "datetime" | "decimal" | "integer" | "string" | "time";
                        value?: unknown;
                    };
                };
            };
        };
    };
    responses: never;
    parameters: never;
    requestBodies: {
        variation_attribute: {
            content: {
                "application/json": components["schemas"]["variation_attribute"];
                "text/xml": components["schemas"]["variation_attribute"];
                "application/xml": components["schemas"]["variation_attribute"];
            };
        };
        variation_attribute_value: {
            content: {
                "application/json": components["schemas"]["variation_attribute_value"];
                "text/xml": components["schemas"]["variation_attribute_value"];
                "application/xml": components["schemas"]["variation_attribute_value"];
            };
        };
        variant: {
            content: {
                "application/json": components["schemas"]["variant"];
                "text/xml": components["schemas"]["variant"];
                "application/xml": components["schemas"]["variant"];
            };
        };
        coupon: {
            content: {
                "application/json": components["schemas"]["coupon"];
                "text/xml": components["schemas"]["coupon"];
                "application/xml": components["schemas"]["coupon"];
            };
        };
        store: {
            content: {
                "application/json": components["schemas"]["store"];
                "text/xml": components["schemas"]["store"];
                "application/xml": components["schemas"]["store"];
            };
        };
        customer: {
            content: {
                "application/json": components["schemas"]["customer"];
                "text/xml": components["schemas"]["customer"];
                "application/xml": components["schemas"]["customer"];
            };
        };
        object_attribute_definition: {
            content: {
                "application/json": components["schemas"]["object_attribute_definition"];
                "text/xml": components["schemas"]["object_attribute_definition"];
                "application/xml": components["schemas"]["object_attribute_definition"];
            };
        };
        product_inventory_record: {
            content: {
                "application/json": components["schemas"]["product_inventory_record"];
                "text/xml": components["schemas"]["product_inventory_record"];
                "application/xml": components["schemas"]["product_inventory_record"];
            };
        };
        variation_group: {
            content: {
                "application/json": components["schemas"]["variation_group"];
                "text/xml": components["schemas"]["variation_group"];
                "application/xml": components["schemas"]["variation_group"];
            };
        };
        content_asset: {
            content: {
                "application/json": components["schemas"]["content_asset"];
                "text/xml": components["schemas"]["content_asset"];
                "application/xml": components["schemas"]["content_asset"];
            };
        };
        source_code_group: {
            content: {
                "application/json": components["schemas"]["source_code_group"];
                "text/xml": components["schemas"]["source_code_group"];
                "application/xml": components["schemas"]["source_code_group"];
            };
        };
        gift_certificate: {
            content: {
                "application/json": components["schemas"]["gift_certificate"];
                "text/xml": components["schemas"]["gift_certificate"];
                "application/xml": components["schemas"]["gift_certificate"];
            };
        };
        search_request: {
            content: {
                "application/json": components["schemas"]["search_request"];
                "text/xml": components["schemas"]["search_request"];
                "application/xml": components["schemas"]["search_request"];
            };
        };
        product_option: {
            content: {
                "application/json": components["schemas"]["product_option"];
                "text/xml": components["schemas"]["product_option"];
                "application/xml": components["schemas"]["product_option"];
            };
        };
        inventory_list: {
            content: {
                "application/json": components["schemas"]["inventory_list"];
                "text/xml": components["schemas"]["inventory_list"];
                "application/xml": components["schemas"]["inventory_list"];
            };
        };
        ocapi_configs_api_request: {
            content: {
                "application/json": components["schemas"]["ocapi_configs_api_request"];
                "text/xml": components["schemas"]["ocapi_configs_api_request"];
                "application/xml": components["schemas"]["ocapi_configs_api_request"];
            };
        };
        user: {
            content: {
                "application/json": components["schemas"]["user"];
                "text/xml": components["schemas"]["user"];
                "application/xml": components["schemas"]["user"];
            };
        };
        product: {
            content: {
                "application/json": components["schemas"]["product"];
                "text/xml": components["schemas"]["product"];
                "application/xml": components["schemas"]["product"];
            };
        };
        category: {
            content: {
                "application/json": components["schemas"]["category"];
                "text/xml": components["schemas"]["category"];
                "application/xml": components["schemas"]["category"];
            };
        };
        category_link: {
            content: {
                "application/json": components["schemas"]["category_link"];
                "text/xml": components["schemas"]["category_link"];
                "application/xml": components["schemas"]["category_link"];
            };
        };
        product_option_value: {
            content: {
                "application/json": components["schemas"]["product_option_value"];
                "text/xml": components["schemas"]["product_option_value"];
                "application/xml": components["schemas"]["product_option_value"];
            };
        };
        object_attribute_group: {
            content: {
                "application/json": components["schemas"]["object_attribute_group"];
                "text/xml": components["schemas"]["object_attribute_group"];
                "application/xml": components["schemas"]["object_attribute_group"];
            };
        };
        custom_object: {
            content: {
                "application/json": components["schemas"]["custom_object"];
                "text/xml": components["schemas"]["custom_object"];
                "application/xml": components["schemas"]["custom_object"];
            };
        };
        custom_object2: {
            content: {
                "application/json": components["schemas"]["custom_object"];
                "text/xml": components["schemas"]["custom_object"];
                "application/xml": components["schemas"]["custom_object"];
            };
        };
        customer_address: {
            content: {
                "application/json": components["schemas"]["customer_address"];
                "text/xml": components["schemas"]["customer_address"];
                "application/xml": components["schemas"]["customer_address"];
            };
        };
        content_folder: {
            content: {
                "application/json": components["schemas"]["content_folder"];
                "text/xml": components["schemas"]["content_folder"];
                "application/xml": components["schemas"]["content_folder"];
            };
        };
        ab_test: {
            content: {
                "application/json": components["schemas"]["ab_test"];
                "text/xml": components["schemas"]["ab_test"];
                "application/xml": components["schemas"]["ab_test"];
            };
        };
        ab_test_segment: {
            content: {
                "application/json": components["schemas"]["ab_test_segment"];
                "text/xml": components["schemas"]["ab_test_segment"];
                "application/xml": components["schemas"]["ab_test_segment"];
            };
        };
        campaign: {
            content: {
                "application/json": components["schemas"]["campaign"];
                "text/xml": components["schemas"]["campaign"];
                "application/xml": components["schemas"]["campaign"];
            };
        };
        customer_group: {
            content: {
                "application/json": components["schemas"]["customer_group"];
                "text/xml": components["schemas"]["customer_group"];
                "application/xml": components["schemas"]["customer_group"];
            };
        };
        promotion: {
            content: {
                "application/json": components["schemas"]["promotion"];
                "text/xml": components["schemas"]["promotion"];
                "application/xml": components["schemas"]["promotion"];
            };
        };
        slot_configuration: {
            content: {
                "application/json": components["schemas"]["slot_configuration"];
                "text/xml": components["schemas"]["slot_configuration"];
                "application/xml": components["schemas"]["slot_configuration"];
            };
        };
    };
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    getAlertsDescriptors: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["alert_descriptors"];
                    "text/xml": components["schemas"]["alert_descriptors"];
                    "application/xml": components["schemas"]["alert_descriptors"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getAlertsDescriptorsByID: {
        parameters: {
            query?: {
                /** @description The application context path (optional). */
                application_context_path?: string;
            };
            header?: never;
            path: {
                /** @description The application ID. */
                application_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["alert_descriptors"];
                    "text/xml": components["schemas"]["alert_descriptors"];
                    "application/xml": components["schemas"]["alert_descriptors"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getAlertsDescriptorsByIDByIDByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The application ID. */
                application_id: string;
                /** @description The application context path. */
                application_context_path: string;
                /** @description The message ID. */
                message_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["alert_descriptor"];
                    "text/xml": components["schemas"]["alert_descriptor"];
                    "application/xml": components["schemas"]["alert_descriptor"];
                };
            };
            /** @description `AlertDescriptorNotFoundException` - If no alert descriptor was found for the given path. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchAlertsDescriptorsByIDByIDByIDRevalidate: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The application ID. */
                application_id: string;
                /** @description The application context path. */
                application_context_path: string;
                /** @description The message ID. */
                message_id: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["alert_descriptors_revalidation_request"];
                "text/xml": components["schemas"]["alert_descriptors_revalidation_request"];
                "application/xml": components["schemas"]["alert_descriptors_revalidation_request"];
            };
        };
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ContextObjectIdRequiredException` - If the descriptor is context specific but no context object id was provided in the request body. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AlertDescriptorNotFoundException` - If no matching alert descriptor was found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getAlertsUsersettings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["alert_settings"];
                    "text/xml": components["schemas"]["alert_settings"];
                    "application/xml": components["schemas"]["alert_settings"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchAlertsUsersettings: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["alert_settings"];
                "text/xml": components["schemas"]["alert_settings"];
                "application/xml": components["schemas"]["alert_settings"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["alert_settings"];
                    "text/xml": components["schemas"]["alert_settings"];
                    "application/xml": components["schemas"]["alert_settings"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postCatalogSearch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["catalog_search_result"];
                    "text/xml": components["schemas"]["catalog_search_result"];
                    "application/xml": components["schemas"]["catalog_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCatalogs: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
                expand?: string[];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["catalogs"];
                    "text/xml": components["schemas"]["catalogs"];
                    "application/xml": components["schemas"]["catalogs"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCatalogsByID: {
        parameters: {
            query?: {
                expand?: string[];
                /** @description the selector for the get. If not passed, the defaultSelector will be used instead. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The id of the requested catalog. */
                catalog_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["catalog"];
                    "text/xml": components["schemas"]["catalog"];
                    "application/xml": components["schemas"]["catalog"];
                };
            };
            /** @description `CatalogNotFoundException` - Thrown in case the catalog does not exist matching the given id or the catalog identified was already in deletion. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchCatalogsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the requested catalog. */
                catalog_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["catalog"];
                "text/xml": components["schemas"]["catalog"];
                "application/xml": components["schemas"]["catalog"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["catalog"];
                    "text/xml": components["schemas"]["catalog"];
                    "application/xml": components["schemas"]["catalog"];
                };
            };
            /** @description `CatalogNotFoundException` - Thrown in case the catalog id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCatalogsByIDCategories: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
                expand?: string[];
            };
            header?: never;
            path: {
                catalog_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["categories"];
                    "text/xml": components["schemas"]["categories"];
                    "application/xml": components["schemas"]["categories"];
                };
            };
            /** @description `CatalogNotFoundException` - Indicates that the catalog is not provided in the request. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCatalogsByIDCategoriesByID: {
        parameters: {
            query?: {
                /**
                 * @description Specifies how many levels of nested sub-categories you want the server to return. The default value
                 *                       	is 1.
                 */
                levels?: number;
                /** @description the expansion that client can use to specify and retrieve further information about the category (Internal use only for now). */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description the id of the catalog that the category belongs to */
                catalog_id: string;
                /** @description the id of the category requested */
                category_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["category"];
                    "text/xml": components["schemas"]["category"];
                    "application/xml": components["schemas"]["category"];
                };
            };
            /**
             * @description `CatalogNotFoundException` - Indicates that the catalog is not provided in the request. or `CategoryNotFoundException` - Indicates that the category does not exist for the catalog provided in
             *                   the request.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putCatalogsByIDCategoriesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the category to be created */
                category_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["category"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["category"];
                    "text/xml": components["schemas"]["category"];
                    "application/xml": components["schemas"]["category"];
                };
            };
            /**
             * @description `CategoryInvalidException` - Indicates that the category in the request is not valid
             *      				(the argument indicates the field that was invalid). or `IdConflictException` - Indicates that the category ID in the request URL does not match the category ID in the request body.
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CatalogNotFoundException` - Indicates that the catalog is not provided in the request. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteCatalogsByIDCategoriesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                catalog_id: string;
                /** @description The category id to remove */
                category_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `CatalogNotFoundException` - Indicates that the catalog is not provided in the request. or `CategoryNotFoundException` - Indicates that the category does not exist for the catalog provided in
             *                   the request.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchCatalogsByIDCategoriesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the category */
                category_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["category"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["category"];
                    "text/xml": components["schemas"]["category"];
                    "application/xml": components["schemas"]["category"];
                };
            };
            /**
             * @description `CategoryInvalidException` - Indicates that the category in the request is not valid
             *      				(the argument indicates the field that was invalid).
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `CatalogNotFoundException` - Indicates that the catalog is not provided in the request. or `CategoryNotFoundException` - Indicates that the category does not exist for the catalog provided in
             *                   the request.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCatalogsByIDCategoriesByIDCategoryLinks: {
        parameters: {
            query?: {
                start?: number;
                count?: number;
                /** @description Optional select clause for getting fields from the returned JSON document. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the source category. */
                category_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["category_links"];
                    "text/xml": components["schemas"]["category_links"];
                    "application/xml": components["schemas"]["category_links"];
                };
            };
            /** @description `CatalogNotFoundException` - Thrown in case the source catalog does not exist or `CategoryNotFoundException` - Thrown in case the source category does not exist */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCatalogsByIDCategoriesByIDCategoryLinksByIDByIDByID: {
        parameters: {
            query?: {
                /** @description Optional select clause for getting fields from the returned JSON document. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The id of the source catalog. */
                catalog_id: string;
                /** @description The id of the source category. */
                category_id: string;
                /** @description The id of the target catalog. */
                target_catalog_id: string;
                /** @description The id of the target category. */
                target_category_id: string;
                /** @description the link type */
                type: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["category_link"];
                    "text/xml": components["schemas"]["category_link"];
                    "application/xml": components["schemas"]["category_link"];
                };
            };
            /** @description `CatalogNotFoundException` - Thrown in case the source catalog or the target catalog do not exist or `CategoryLinkNotFoundException` - Thrown in case the category link does not exist from the source catalog/category to the destination catalog/category with the given type. or `CategoryNotFoundException` - Thrown in case the source category or the target category do not exist */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putCatalogsByIDCategoriesByIDCategoryLinksByIDByIDByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the source catalog. */
                catalog_id: string;
                /** @description The id of the source category. */
                category_id: string;
                /** @description The id of the target catalog. */
                target_catalog_id: string;
                /** @description The id of the target category. */
                target_category_id: string;
                /** @description the link type */
                type: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["category_link"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["category_link"];
                    "text/xml": components["schemas"]["category_link"];
                    "application/xml": components["schemas"]["category_link"];
                };
            };
            /** @description `CatalogNotFoundException` - Thrown in case the source catalog or the target catalog do not exist or `CategoryNotFoundException` - Thrown in case the source category or the target category do not exist */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteCatalogsByIDCategoriesByIDCategoryLinksByIDByIDByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the source catalog. */
                catalog_id: string;
                /** @description The id of the source category. */
                category_id: string;
                /** @description The id of the target catalog. */
                target_catalog_id: string;
                /** @description The id of the target category. */
                target_category_id: string;
                /** @description the link type */
                type: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CatalogNotFoundException` - Thrown in case the source catalog or the target catalog do not exist or `CategoryLinkNotFoundException` - Thrown in case the category link does not exist from the source catalog/category to the destination catalog/category with the given type. or `CategoryNotFoundException` - Thrown in case the source category or the target category do not exist */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchCatalogsByIDCategoriesByIDCategoryLinksByIDByIDByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the source catalog. */
                catalog_id: string;
                /** @description The id of the source category. */
                category_id: string;
                /** @description The id of the target catalog. */
                target_catalog_id: string;
                /** @description The id of the target category. */
                target_category_id: string;
                /** @description the link type */
                type: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["category_link"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["category_link"];
                    "text/xml": components["schemas"]["category_link"];
                    "application/xml": components["schemas"]["category_link"];
                };
            };
            /** @description `CatalogNotFoundException` - Thrown in case the source catalog or the target catalog do not exist or `CategoryLinkNotFoundException` - Thrown in case the category link does not exist from the source catalog/category to the destination catalog/category with the given type. or `CategoryNotFoundException` - Thrown in case the source category or the target category do not exist */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postCatalogsByIDCategoriesByIDCategoryProductAssignmentSearch: {
        parameters: {
            query?: {
                /** @description The site context. */
                site_id?: string;
            };
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the category. */
                category_id: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["category_product_assignment_search_request"];
                "text/xml": components["schemas"]["category_product_assignment_search_request"];
                "application/xml": components["schemas"]["category_product_assignment_search_request"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["category_product_assignment_search_result"];
                    "text/xml": components["schemas"]["category_product_assignment_search_result"];
                    "application/xml": components["schemas"]["category_product_assignment_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CatalogNotFoundException` - Thrown if the catalog does not exist matching the given category_id. or `CategoryNotFoundException` - Thrown if the category does not exist matching the given catalog_id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCatalogsByIDCategoriesByIDProductsByID: {
        parameters: {
            query?: {
                /** @description The site context. */
                site_id?: string;
                /** @description The List of expansion values applied to the product associated to the assignment. */
                expand?: string[];
                /** @description The selector for the get. If not passed, then the defaultSelector will be used instead. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The catalog of the assignment. */
                catalog_id: string;
                /** @description The id of the requested category. */
                category_id: string;
                /** @description The id (SKU) of the requested assigned product. */
                product_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["category_product_assignment"];
                    "text/xml": components["schemas"]["category_product_assignment"];
                    "application/xml": components["schemas"]["category_product_assignment"];
                };
            };
            /** @description `CatalogNotFoundException` - Thrown if the catalog does not exist matching the given id. or `CategoryNotFoundException` - Thrown if the category does not exist matching the given id. or `CategoryProductAssignmentNotFoundException` - Thrown if the category product assignment does not exist matching the given ids. or `ProductNotFoundException` - Thrown if the product does not exist matching the given id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putCatalogsByIDCategoriesByIDProductsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the requested catalog to which to assign the product. */
                catalog_id: string;
                /** @description The id of the requested category to which to assign the product. */
                category_id: string;
                /** @description The id (SKU) of the requested product to assign. */
                product_id: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["category_product_assignment"];
                "text/xml": components["schemas"]["category_product_assignment"];
                "application/xml": components["schemas"]["category_product_assignment"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["category_product_assignment"];
                    "text/xml": components["schemas"]["category_product_assignment"];
                    "application/xml": components["schemas"]["category_product_assignment"];
                };
            };
            /** @description `IdConflictException` - if the Id in request is not the same as the ID in document. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CatalogNotFoundException` - Thrown if the catalog does not exist matching the given id. or `CategoryNotFoundException` - Thrown if the category does not exist matching the given id. or `ProductNotFoundException` - Thrown if the product does not exist matching the given id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteCatalogsByIDCategoriesByIDProductsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The catalog of the assignment. */
                catalog_id: string;
                /** @description The id of the requested category. */
                category_id: string;
                /** @description The id of the requested product to un-assign. */
                product_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CatalogNotFoundException` - Thrown if the catalog does not exist matching the given id. or `CategoryNotFoundException` - Thrown if the category does not exist matching the given id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchCatalogsByIDCategoriesByIDProductsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the requested catalog to which the product is assigned. */
                catalog_id: string;
                /** @description The id of the requested category to which the product is assigned. */
                category_id: string;
                /** @description The id (SKU) of the requested assigned product. */
                product_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["category_product_assignment"];
                "text/xml": components["schemas"]["category_product_assignment"];
                "application/xml": components["schemas"]["category_product_assignment"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["category_product_assignment"];
                    "text/xml": components["schemas"]["category_product_assignment"];
                    "application/xml": components["schemas"]["category_product_assignment"];
                };
            };
            /** @description `CatalogNotFoundException` - Thrown if the catalog does not exist matching the given id. or `CategoryNotFoundException` - Thrown if the category does not exist matching the given id. or `CategoryProductAssignmentNotFoundException` - Thrown if the category product assignment does not exist. or `ProductNotFoundException` - Thrown if the product does not exist matching the given id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postCatalogsByIDCategorySearch: {
        parameters: {
            query?: {
                levels?: number;
            };
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["category_search_result"];
                    "text/xml": components["schemas"]["category_search_result"];
                    "application/xml": components["schemas"]["category_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CatalogNotFoundException` - Thrown if the specified catalog does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCatalogsByIDSharedProductOptions: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
                /** @description The currency mnemonic for retrieving the product option values according to the sorting mode.ex:'USD' */
                currency?: string;
            };
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_options"];
                    "text/xml": components["schemas"]["product_options"];
                    "application/xml": components["schemas"]["product_options"];
                };
            };
            /** @description `CatalogNotFoundException` - Indicates the catalog is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCatalogsByIDSharedProductOptionsByID: {
        parameters: {
            query?: {
                /** @description The currency mnemonic for retrieving the product option values according to the sorting mode.ex:'USD' */
                currency?: string;
            };
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the shared product option. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_option"];
                    "text/xml": components["schemas"]["product_option"];
                    "application/xml": components["schemas"]["product_option"];
                };
            };
            /** @description `CatalogNotFoundException` - Indicates the catalog is not found. or `ProductOptionNotFoundException` - Indicates the shared product option is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putCatalogsByIDSharedProductOptionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the shared product option. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["product_option"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_option"];
                    "text/xml": components["schemas"]["product_option"];
                    "application/xml": components["schemas"]["product_option"];
                };
            };
            /** @description `ProductOptionDuplicateException` - Indicates the shared product option is a duplicate. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeDefinitionNotFoundException` - Indicates the id specified is not a valid attribute definition. or `CatalogNotFoundException` - Indicates the catalog is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteCatalogsByIDSharedProductOptionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the shared product option. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CatalogNotFoundException` - Indicates the catalog is not found. or `ProductOptionNotFoundException` - Indicates the shared product option is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchCatalogsByIDSharedProductOptionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the shared product option. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["product_option"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_option"];
                    "text/xml": components["schemas"]["product_option"];
                    "application/xml": components["schemas"]["product_option"];
                };
            };
            /** @description `CatalogNotFoundException` - Indicates the catalog is not found. or `ProductOptionNotFoundException` - Indicates the shared product option is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCatalogsByIDSharedProductOptionsByIDValues: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the shared product option. */
                option_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_option_values"];
                    "text/xml": components["schemas"]["product_option_values"];
                    "application/xml": components["schemas"]["product_option_values"];
                };
            };
            /** @description `CatalogNotFoundException` - Indicates the catalog is not found. or `ProductOptionNotFoundException` - Indicates the shared product option is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCatalogsByIDSharedProductOptionsByIDValuesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the shared product option. */
                option_id: string;
                /** @description the id of shared product option value. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_option_value"];
                    "text/xml": components["schemas"]["product_option_value"];
                    "application/xml": components["schemas"]["product_option_value"];
                };
            };
            /** @description `CatalogNotFoundException` - Indicates the catalog is not found. or `ProductOptionNotFoundException` - Indicates the shared product option is not found. or `ProductOptionValueNotFoundException` - Indicates the shared product option value is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putCatalogsByIDSharedProductOptionsByIDValuesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the shared product option. */
                option_id: string;
                /** @description The id of the shared product option value. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["product_option_value"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_option_value"];
                    "text/xml": components["schemas"]["product_option_value"];
                    "application/xml": components["schemas"]["product_option_value"];
                };
            };
            /** @description `CatalogNotFoundException` - Indicates the catalog is not found. or `ProductOptionNotFoundException` - Indicates the shared product option is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteCatalogsByIDSharedProductOptionsByIDValuesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the shared product option. */
                option_id: string;
                /** @description The id of the shared product option value. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CatalogNotFoundException` - Indicates the catalog is not found. or `ProductOptionNotFoundException` - Indicates the shared product option is not found. or `ProductOptionValueNotFoundException` - Indicates the shared product option value is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchCatalogsByIDSharedProductOptionsByIDValuesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the shared product option. */
                option_id: string;
                /** @description The id of the shared product option value. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["product_option_value"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_option_value"];
                    "text/xml": components["schemas"]["product_option_value"];
                    "application/xml": components["schemas"]["product_option_value"];
                };
            };
            /** @description `CatalogNotFoundException` - Indicates the catalog is not found. or `ProductOptionNotFoundException` - Indicates the shared product option is not found. or `ProductOptionValueNotFoundException` - Indicates the shared product option value is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCatalogsByIDSharedVariationAttributes: {
        parameters: {
            query?: {
                start?: number;
                count?: number;
                select?: string;
            };
            header?: never;
            path: {
                /** @description id of the catalog. */
                catalog_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_attributes"];
                    "text/xml": components["schemas"]["variation_attributes"];
                    "application/xml": components["schemas"]["variation_attributes"];
                };
            };
            /** @description `CatalogNotFoundException` - Indicates the catalog is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCatalogsByIDSharedVariationAttributesByIDValues: {
        parameters: {
            query?: {
                /** @description the first record to get in the page */
                start?: number;
                /** @description the number of records to get */
                count?: number;
                /** @description a string that specifies which fields to return (default is all). */
                select?: string;
            };
            header?: never;
            path: {
                /** @description id of the owning catalog. */
                catalog_id: string;
                /** @description The variation attribute ID that contains the values. */
                attribute_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_attribute_values"];
                    "text/xml": components["schemas"]["variation_attribute_values"];
                    "application/xml": components["schemas"]["variation_attribute_values"];
                };
            };
            /** @description `CatalogNotFoundException` - Indicates the catalog is not found. or `VariationAttributeNotFoundException` - Indicate the variation attribute is not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCatalogsByIDSharedVariationAttributesByIDValuesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The owning catalog ID. */
                catalog_id: string;
                /** @description The variation attribute custom ID */
                attribute_id: string;
                /** @description The id of the variation attribute value */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_attribute_value"];
                    "text/xml": components["schemas"]["variation_attribute_value"];
                    "application/xml": components["schemas"]["variation_attribute_value"];
                };
            };
            /** @description `CatalogNotFoundException` - Indicates the catalog is not found. or `VariationAttributeNotFoundException` - Indicate the variation attribute is not found or `VariationAttributeValueNotFoundException` - Indicate the variation attribute value is not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putCatalogsByIDSharedVariationAttributesByIDValuesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The owning catalog ID. */
                catalog_id: string;
                /** @description The variation attribute ID */
                attribute_id: string;
                /** @description The id of the variation attribute value */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["variation_attribute_value"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_attribute_value"];
                    "text/xml": components["schemas"]["variation_attribute_value"];
                    "application/xml": components["schemas"]["variation_attribute_value"];
                };
            };
            /** @description `CatalogNotFoundException` - Indicates the catalog is not found. or `VariationAttributeNotFoundException` - Indicate the variation attribute is not found or `VariationAttributeValueNotFoundException` - Indicate the variation attribute value is not found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteCatalogsByIDSharedVariationAttributesByIDValuesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the variation attribute that contains the value. */
                attribute_id: string;
                /** @description The id of one value to remove */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CatalogNotFoundException` - if the catalog id specified cannot be found or `VariationAttributeNotFoundException` - if the attribute id specified is not a valid variation attribute or `VariationAttributeValueNotFoundException` - if the value id specified does not a valid value id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchCatalogsByIDSharedVariationAttributesByIDValuesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the requested variation attribute. */
                attribute_id: string;
                /** @description The id of the variation value. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["variation_attribute_value"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_attribute_value"];
                    "text/xml": components["schemas"]["variation_attribute_value"];
                    "application/xml": components["schemas"]["variation_attribute_value"];
                };
            };
            /** @description `CatalogNotFoundException` - if the catalog id specified cannot be found or `VariationAttributeNotFoundException` - if the attribute id specified is not a valid variation attribute or `VariationAttributeValueNotFoundException` - if the value id specified does not a valid value id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCatalogsByIDSharedVariationAttributesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the requested variation attribute. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_attribute"];
                    "text/xml": components["schemas"]["variation_attribute"];
                    "application/xml": components["schemas"]["variation_attribute"];
                };
            };
            /** @description `CatalogNotFoundException` - Indicates the catalog is not found. or `VariationAttributeNotFoundException` - Thrown if the variation attribute matching the given id does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putCatalogsByIDSharedVariationAttributesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the variation attribute to create. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["variation_attribute"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_attribute"];
                    "text/xml": components["schemas"]["variation_attribute"];
                    "application/xml": components["schemas"]["variation_attribute"];
                };
            };
            /** @description `SharedVariationAttributeIDNotUniqueException` - if the specified id isn't unique. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeDefinitionNotFoundException` - if attribute definition supplied is not a product attribute. or `CatalogNotFoundException` - Indicates the catalog is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteCatalogsByIDSharedVariationAttributesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description One variation attribute id to remove. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CatalogNotFoundException` - Indicates the catalog is not found. or `VariationAttributeNotFoundException` - Thrown if the variation attribute does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchCatalogsByIDSharedVariationAttributesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the catalog. */
                catalog_id: string;
                /** @description The id of the requested variation attribute. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["variation_attribute"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_attribute"];
                    "text/xml": components["schemas"]["variation_attribute"];
                    "application/xml": components["schemas"]["variation_attribute"];
                };
            };
            /** @description `CatalogNotFoundException` - if the specified catalog id cannot be found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postCategorySearch: {
        parameters: {
            query?: {
                levels?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["category_search_result"];
                    "text/xml": components["schemas"]["category_search_result"];
                    "application/xml": components["schemas"]["category_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCodeVersions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["code_version_result"];
                    "text/xml": components["schemas"]["code_version_result"];
                    "application/xml": components["schemas"]["code_version_result"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCodeVersionsByID: {
        parameters: {
            query?: {
                /** @description The expand parameter. Allowed value (size). */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description The id of the code version. */
                code_version_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["code_version"];
                    "text/xml": components["schemas"]["code_version"];
                    "application/xml": components["schemas"]["code_version"];
                };
            };
            /** @description `CodeVersionIdNotFoundException` - Indicates that a code version with the given id was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putCodeVersionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the code version. */
                code_version_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["code_version"];
                    "text/xml": components["schemas"]["code_version"];
                    "application/xml": components["schemas"]["code_version"];
                };
            };
            /** @description `CodeVersionIdAlreadyExistsException` - Indicates that a code version with the given id already exists. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteCodeVersionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the code version. */
                code_version_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `CodeVersionModificationException` - Indicates that a code version with the given id can't be
             *              deleted (because it is active).
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CodeVersionIdNotFoundException` - Indicates that a code version with the given id was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchCodeVersionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the code version. */
                code_version_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["code_version"];
                "text/xml": components["schemas"]["code_version"];
                "application/xml": components["schemas"]["code_version"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["code_version"];
                    "text/xml": components["schemas"]["code_version"];
                    "application/xml": components["schemas"]["code_version"];
                };
            };
            /** @description `CodeVersionModificationException` - Indicates that a code version with the given id can't be updated (because it is active). */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CodeVersionIdNotFoundException` - Indicates that a code version with the given id was not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CodeVersionIdAlreadyExistsException` - Indicates that a code version with the given id already exists. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postCustomObjectDefinitionsByIDAttributeDefinitionSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The type of object */
                object_type: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_definition_search_result"];
                    "text/xml": components["schemas"]["object_attribute_definition_search_result"];
                    "application/xml": components["schemas"]["object_attribute_definition_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Indicates the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ObjectTypeNotFoundException` - Indicates that the object type cannot be found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCustomObjectDefinitionsByIDAttributeDefinitions: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path: {
                object_type: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_definitions"];
                    "text/xml": components["schemas"]["object_attribute_definitions"];
                    "application/xml": components["schemas"]["object_attribute_definitions"];
                };
            };
            /** @description `ObjectTypeNotFoundException` - Thrown in case the object type cannot be found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCustomObjectDefinitionsByIDAttributeDefinitionsByID: {
        parameters: {
            query?: {
                /** @description The expand "value" is available to retrieve value definitions of the attribute definition. */
                expand?: string[];
                /** @description The selector for the get. If not passed, then the defaultSelector will be used instead. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The object type id that contains these definitions */
                object_type: string;
                /** @description The id of the requested attribute definition. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_definition"];
                    "text/xml": components["schemas"]["object_attribute_definition"];
                    "application/xml": components["schemas"]["object_attribute_definition"];
                };
            };
            /** @description `AttributeDefinitionNotFoundException` - Thrown in case the attribute definition does not exist matching the given id or `ObjectTypeNotFoundException` - Thrown in case the object type cannot be found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putCustomObjectDefinitionsByIDAttributeDefinitionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The metadata object that contains these definitions */
                object_type: string;
                /** @description The id of the attribute definition to create. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["object_attribute_definition"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_definition"];
                    "text/xml": components["schemas"]["object_attribute_definition"];
                    "application/xml": components["schemas"]["object_attribute_definition"];
                };
            };
            /** @description `AttributeDefinitionCreateException` - if the attribute definition could not be created. or `AttributeDefinitionKeyReadOnlyException` - Thrown when trying to create a key attribute of a custom object or `AttributeDefinitionLocalizableNotAllowedException` - if trying to create a localizable attribute with a non-localizable type or `IdConflictException` - if the Id in request is not the same as the ID in document. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ObjectTypeNotFoundException` - Thrown in case the object type cannot be found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteCustomObjectDefinitionsByIDAttributeDefinitionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The metadata object that contains these definitions */
                object_type: string;
                /** @description Attribute definition id to remove */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeDefinitionKeyReadOnlyException` - Thrown when trying to delete a key attribute of custom object or `AttributeDefinitionReadOnlyException` - Thrown when trying to delete a internal attribute of custom object */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeDefinitionNotFoundException` - Thrown in case the attribute definition does not exist matching the given id or `ObjectTypeNotFoundException` - Thrown in case the object type cannot be found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchCustomObjectDefinitionsByIDAttributeDefinitionsByID: {
        parameters: {
            query?: never;
            header?: {
                "If-Match"?: string;
            };
            path: {
                /** @description The object type id that contains these definitions */
                object_type: string;
                /** @description The id of the requested attribute definition. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["object_attribute_definition"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_definition"];
                    "text/xml": components["schemas"]["object_attribute_definition"];
                    "application/xml": components["schemas"]["object_attribute_definition"];
                };
            };
            /** @description `AttributeDefinitionKeyReadOnlyException` - Thrown when trying to modify a key attribute of custom object or `AttributeDefinitionPropertyReadOnlyException` - Thrown in case a read only system attribute it tried to be changed, which is not allowed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeDefinitionNotFoundException` - Thrown in case the attribute definition does not exist matching the given id or `ObjectTypeNotFoundException` - Thrown in case the object type cannot be found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postCustomObjectDefinitionsByIDAttributeGroupSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                object_type: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_group_search_result"];
                    "text/xml": components["schemas"]["object_attribute_group_search_result"];
                    "application/xml": components["schemas"]["object_attribute_group_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ObjectTypeNotFoundException` - Thrown in case the object type cannot be found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCustomObjectDefinitionsByIDAttributeGroups: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
                expand?: string[];
            };
            header?: never;
            path: {
                object_type: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_groups"];
                    "text/xml": components["schemas"]["object_attribute_groups"];
                    "application/xml": components["schemas"]["object_attribute_groups"];
                };
            };
            /** @description `ObjectTypeNotFoundException` - Thrown in case the object type cannot be found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putCustomObjectDefinitionsByIDAttributeGroupsByIDAttributeDefinitionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the custom object that contains the attribute definition and attribute group. */
                object_type: string;
                /** @description The ID of the attribute group. */
                group_id: string;
                /** @description The ID of the attribute definition. */
                def_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeDefinitionNotFoundException` - Indicates the specified attribute definition is not found. or `AttributeGroupNotFoundException` - Indicates the specified attribute group is not found. or `ObjectTypeNotFoundException` - Indicates the specified custom object is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteCustomObjectDefinitionsByIDAttributeGroupsByIDAttributeDefinitionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the custom object that contains the attribute definition and attribute group. */
                object_type: string;
                /** @description The ID of the attribute group. */
                group_id: string;
                /** @description The ID of the attribute definition. */
                def_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeDefinitionNotFoundException` - Indicates the specified attribute definition is not found. or `AttributeGroupNotFoundException` - Indicates the specified attribute group is not found. or `ObjectTypeNotFoundException` - Indicates the specified custom object is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCustomObjectDefinitionsByIDAttributeGroupsByID: {
        parameters: {
            query?: {
                select?: string;
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description the object type id that contains this attribute group */
                object_type: string;
                /** @description The id of the requested attribute group. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_group"];
                    "text/xml": components["schemas"]["object_attribute_group"];
                    "application/xml": components["schemas"]["object_attribute_group"];
                };
            };
            /** @description `AttributeGroupNotFoundException` - Thrown in case the attribute group does not exist matching the given id or `ObjectTypeNotFoundException` - Thrown in case the object type cannot be found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putCustomObjectDefinitionsByIDAttributeGroupsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the object type id that contains this attribute group */
                object_type: string;
                /** @description The id of the attribute group to create. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["object_attribute_group"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_group"];
                    "text/xml": components["schemas"]["object_attribute_group"];
                    "application/xml": components["schemas"]["object_attribute_group"];
                };
            };
            /** @description `IdConflictException` - when the id in the body does not match that provided in the URL */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ObjectTypeNotFoundException` - Thrown in case the object type cannot be found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteCustomObjectDefinitionsByIDAttributeGroupsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the object type id that contains this attribute group */
                object_type: string;
                /** @description One attribute group id to remove */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeGroupNotFoundException` - Thrown in case the attribute group does not exist matching the given id or `ObjectTypeNotFoundException` - Thrown in case the object type cannot be found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchCustomObjectDefinitionsByIDAttributeGroupsByID: {
        parameters: {
            query?: never;
            header?: {
                "If-Match"?: string;
            };
            path: {
                /** @description the object type id that contains this attribute group */
                object_type: string;
                /** @description The id of the requested attribute group. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["object_attribute_group"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_group"];
                    "text/xml": components["schemas"]["object_attribute_group"];
                    "application/xml": components["schemas"]["object_attribute_group"];
                };
            };
            /** @description `AttributeGroupNotFoundException` - Thrown in case the attribute group does not exist matching the given id or `ObjectTypeNotFoundException` - Thrown in case the object type cannot be found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCustomObjectsByIDByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the ID of the object type */
                object_type: string;
                /** @description the key attribute value of the Custom Object */
                key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["custom_object"];
                    "text/xml": components["schemas"]["custom_object"];
                    "application/xml": components["schemas"]["custom_object"];
                };
            };
            /** @description `MalformedKeyParameterException` - If the object key must be an integer, but the path parameter has an invalid format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ObjectTypeNotFoundException` - For an unknown object type ID or `CustomObjectNotFoundException` - For an unknown object key */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putCustomObjectsByIDByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the ID of the object type */
                object_type: string;
                /** @description the key attribute value of the Custom Object */
                key: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["custom_object2"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["custom_object"];
                    "text/xml": components["schemas"]["custom_object"];
                    "application/xml": components["schemas"]["custom_object"];
                };
            };
            /** @description `MalformedKeyParameterException` - If the object key must be an integer, but the path parameter has an invalid format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ObjectTypeNotFoundException` - For an unknown object type ID or `CustomObjectNotFoundException` - For an unknown object key */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteCustomObjectsByIDByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the ID of the object type */
                object_type: string;
                /** @description the key attribute value of the Custom Object */
                key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `MalformedKeyParameterException` - If the object key must be an integer, but the path parameter has an invalid format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ObjectTypeNotFoundException` - For an unknown object type ID */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchCustomObjectsByIDByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the ID of the object type */
                object_type: string;
                /** @description the key attribute value of the Custom Object */
                key: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["custom_object"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["custom_object"];
                    "text/xml": components["schemas"]["custom_object"];
                    "application/xml": components["schemas"]["custom_object"];
                };
            };
            /** @description `MalformedKeyParameterException` - If the object key must be an integer, but the path parameter has an invalid format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ObjectTypeNotFoundException` - For an unknown object type ID or `CustomObjectNotFoundException` - For an unknown object key */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postCustomObjectsSearchByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the object type to search objects for */
                object_type: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["custom_object_search_result"];
                    "text/xml": components["schemas"]["custom_object_search_result"];
                    "application/xml": components["schemas"]["custom_object_search_result"];
                };
            };
            /**
             * @description `TypeMissmatchException` - Indicates that the value to search with does not match the
             *                   type of the search field.
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ObjectTypeNotFoundException` - In case of an unknown object type. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postCustomerListsByIDCustomerSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer list id to search in */
                customer_list_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer_search_result"];
                    "text/xml": components["schemas"]["customer_search_result"];
                    "application/xml": components["schemas"]["customer_search_result"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCustomerListsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the id of the customerlist */
                list_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer_list"];
                    "text/xml": components["schemas"]["customer_list"];
                    "application/xml": components["schemas"]["customer_list"];
                };
            };
            /** @description `CustomerListNotFoundException` - Indicates that there was no customerlist found for the customerlist id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postCustomerListsByIDCustomers: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer list id */
                list_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["customer"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer"];
                    "text/xml": components["schemas"]["customer"];
                    "application/xml": components["schemas"]["customer"];
                };
            };
            /** @description `CredentialsMissingException` - Indicates that the mandatory credentials are missing in the input document. or `InvalidLoginException` - Indicates the login does not match the login acceptance criteria. or `LoginAlreadyInUseException` - Indicates the login is already in use. or `LoginMissingException` - Indicates that the mandatory login property is missing in the input document. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CustomerListNotFoundException` - Indicates that the customer list with the given customer list id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCustomerListsByIDCustomersByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer list id */
                list_id: string;
                /** @description The customer number */
                customer_no: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer"];
                    "text/xml": components["schemas"]["customer"];
                    "application/xml": components["schemas"]["customer"];
                };
            };
            /** @description `CustomerListCustomerNotFoundException` - Indicates that the customer with the given customer number is unknown. or `CustomerListNotFoundException` - Indicates that the customer list with the given customer list id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putCustomerListsByIDCustomersByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer list id */
                list_id: string;
                /** @description The customer number */
                customer_no: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["customer"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer"];
                    "text/xml": components["schemas"]["customer"];
                    "application/xml": components["schemas"]["customer"];
                };
            };
            /** @description `CredentialsMissingException` - Indicates that the mandatory credentials are missing in the input document. or `InvalidLoginException` - Indicates the login does not match the login acceptance criteria. or `LoginAlreadyInUseException` - Indicates that the given login is already in use. or `LoginMissingException` - Indicates that the mandatory login property is missing in the input document. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CustomerListNotFoundException` - Indicates that the customer list with the given customer list id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteCustomerListsByIDCustomersByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer list id */
                list_id: string;
                /** @description The customer number */
                customer_no: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `CustomerListCustomerNotFoundException` - Indicates that the customer with the given customer number is
             *                  unknown. or `CustomerListNotFoundException` - Indicates that the customer list with the given customer list id is
             *                  unknown.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchCustomerListsByIDCustomersByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer list id */
                list_id: string;
                /** @description The customer number */
                customer_no: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["customer"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer"];
                    "text/xml": components["schemas"]["customer"];
                    "application/xml": components["schemas"]["customer"];
                };
            };
            /** @description `InvalidLoginException` - Indicates the login does not match the login acceptance criteria. or `LoginAlreadyInUseException` - Indicates the login is already in use. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CustomerListCustomerNotFoundException` - Indicates that the customer with the given customer number is unknown. or `CustomerListNotFoundException` - Indicates that the customer list with the given customer list id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCustomerListsByIDCustomersByIDAddresses: {
        parameters: {
            query?: {
                /** @description The result set index to return the first instance for. Default value is 0. */
                start?: number;
                /** @description The maximum number of instances per request. Default value is 25. */
                count?: number;
            };
            header?: never;
            path: {
                /** @description The customer list id */
                list_id: string;
                /** @description The customer number */
                customer_no: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer_address_result"];
                    "text/xml": components["schemas"]["customer_address_result"];
                    "application/xml": components["schemas"]["customer_address_result"];
                };
            };
            /** @description `CustomerListCustomerNotFoundException` - Indicates that the customer with the given customer number is unknown. or `CustomerListNotFoundException` - Indicates that the customer list with the given customer list id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postCustomerListsByIDCustomersByIDAddresses: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer list id */
                list_id: string;
                /** @description The customer number */
                customer_no: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["customer_address"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer_address"];
                    "text/xml": components["schemas"]["customer_address"];
                    "application/xml": components["schemas"]["customer_address"];
                };
            };
            /** @description `AddressIdAlreadyInUseException` - If the address id is already in use. or `InvalidAddressIdException` - If the address id is null or empty. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CustomerListCustomerNotFoundException` - Indicates that the customer with the given customer number is unknown. or `CustomerListNotFoundException` - Indicates that the customer list with the given customer list id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getCustomerListsByIDCustomersByIDAddressesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer list id */
                list_id: string;
                /** @description The customer number */
                customer_no: string;
                /** @description The address id */
                address_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer_address"];
                    "text/xml": components["schemas"]["customer_address"];
                    "application/xml": components["schemas"]["customer_address"];
                };
            };
            /** @description `CustomerListCustomerAddressNotFoundException` - Indicates that the customer address id is unknown. or `CustomerListCustomerNotFoundException` - Indicates that the customer with the given customer number is unknown. or `CustomerListNotFoundException` - Indicates that the customer list with the given customer list id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteCustomerListsByIDCustomersByIDAddressesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer list id */
                list_id: string;
                /** @description The customer number */
                customer_no: string;
                /** @description The address id */
                address_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CustomerListCustomerNotFoundException` - Indicates that the customer with the given customer number is unknown. or `CustomerListNotFoundException` - Indicates that the customer list with the given customer list id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchCustomerListsByIDCustomersByIDAddressesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The customer list id */
                list_id: string;
                /** @description The customer number */
                customer_no: string;
                /** @description The address id */
                address_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["customer_address"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer_address"];
                    "text/xml": components["schemas"]["customer_address"];
                    "application/xml": components["schemas"]["customer_address"];
                };
            };
            /** @description `AddressIdAlreadyInUseException` - If the new address id is already in use. or `InvalidAddressIdException` - If the new address id is empty. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CustomerListCustomerAddressNotFoundException` - Indicates that the customer address id is unknown. or `CustomerListCustomerNotFoundException` - Indicates that the customer with the given customer number is unknown. or `CustomerListNotFoundException` - Indicates that the customer list with the given customer list id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getGlobalPreferencesPreferenceGroupsByIDByID: {
        parameters: {
            query?: {
                /** @description Set to true to mask the values of preferences of type Password. */
                mask_passwords?: boolean;
                /** @description The expansion "sites" retrieves the custom preferences in the preference group for all the available sites. */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description One of {staging,development,sandbox,production,current}. */
                instance_type: string;
                /** @description The ID of the preference group. */
                group_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["organization_preferences"];
                    "text/xml": components["schemas"]["organization_preferences"];
                    "application/xml": components["schemas"]["organization_preferences"];
                };
            };
            /** @description `CustomPreferenceGroupNotFoundException` - Indicates the preference group is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchGlobalPreferencesPreferenceGroupsByIDByID: {
        parameters: {
            query?: {
                /** @description Set to true to mask the values of preferences of type Password. */
                mask_passwords?: boolean;
            };
            header?: never;
            path: {
                /** @description One of {staging,development,sandbox,production}. */
                instance_type: string;
                /** @description The ID of the preference group. */
                group_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["organization_preferences"];
                "text/xml": components["schemas"]["organization_preferences"];
                "application/xml": components["schemas"]["organization_preferences"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["organization_preferences"];
                    "text/xml": components["schemas"]["organization_preferences"];
                    "application/xml": components["schemas"]["organization_preferences"];
                };
            };
            /** @description `CustomPreferenceGroupNotFoundException` - Indicates the preference group is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postInventoryListSearch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["inventory_list_search_result"];
                    "text/xml": components["schemas"]["inventory_list_search_result"];
                    "application/xml": components["schemas"]["inventory_list_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. or `MalformedSelectorException` - Thrown if the given selector is invalid. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getInventoryLists: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["inventory_lists"];
                    "text/xml": components["schemas"]["inventory_lists"];
                    "application/xml": components["schemas"]["inventory_lists"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getInventoryListsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the requested inventory list. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["inventory_list"];
                    "text/xml": components["schemas"]["inventory_list"];
                    "application/xml": components["schemas"]["inventory_list"];
                };
            };
            /** @description `InventoryListNotFoundException` - Thrown in case the inventory list does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putInventoryListsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the inventory list to create. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["inventory_list"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["inventory_list"];
                    "text/xml": components["schemas"]["inventory_list"];
                    "application/xml": components["schemas"]["inventory_list"];
                };
            };
            /** @description `IdConflictException` - if the Id in request is not the same as the ID in document. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteInventoryListsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description One inventory list id to remove */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchInventoryListsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the requested inventory list. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["inventory_list"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["inventory_list"];
                    "text/xml": components["schemas"]["inventory_list"];
                    "application/xml": components["schemas"]["inventory_list"];
                };
            };
            /** @description `InventoryListNotFoundException` - Thrown in case the inventory list does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getInventoryListsByIDProductInventoryRecords: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The inventory list ID */
                inventory_list_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_inventory_records"];
                    "text/xml": components["schemas"]["product_inventory_records"];
                    "application/xml": components["schemas"]["product_inventory_records"];
                };
            };
            /** @description `InventoryListNotFoundException` - Indicates the inventory list does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getInventoryListsByIDProductInventoryRecordsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The inventory list ID */
                inventory_list_id: string;
                /** @description The product ID */
                product_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_inventory_record"];
                    "text/xml": components["schemas"]["product_inventory_record"];
                    "application/xml": components["schemas"]["product_inventory_record"];
                };
            };
            /** @description `InventoryListNotFoundException` - Indicates the inventory list does not exist. or `ProductInventoryRecordNotFoundException` - Indicates the product inventory record does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putInventoryListsByIDProductInventoryRecordsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The inventory list ID */
                inventory_list_id: string;
                /** @description The product ID */
                product_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["product_inventory_record"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_inventory_record"];
                    "text/xml": components["schemas"]["product_inventory_record"];
                    "application/xml": components["schemas"]["product_inventory_record"];
                };
            };
            /** @description `InventoryListNotFoundException` - Indicates the inventory list does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ConflictException` - Indicates a concurrent update */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteInventoryListsByIDProductInventoryRecordsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The inventory list ID */
                inventory_list_id: string;
                /** @description The product ID */
                product_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `InventoryListNotFoundException` - Indicates the inventory list does not exist. or `ProductInventoryRecordNotFoundException` - Indicates the product inventory record does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchInventoryListsByIDProductInventoryRecordsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The inventory list ID */
                inventory_list_id: string;
                /** @description The product ID */
                product_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["product_inventory_record"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_inventory_record"];
                    "text/xml": components["schemas"]["product_inventory_record"];
                    "application/xml": components["schemas"]["product_inventory_record"];
                };
            };
            /** @description `InventoryListNotFoundException` - Indicates the inventory list does not exist. or `ProductInventoryRecordNotFoundException` - Indicates the product inventory record does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ConflictException` - Indicates a concurrent update */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postJobExecutionSearch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["job_execution_search_result"];
                    "text/xml": components["schemas"]["job_execution_search_result"];
                    "application/xml": components["schemas"]["job_execution_search_result"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postJobsByIDExecutions: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the job to execute. */
                job_id: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["string"];
                "text/xml": components["schemas"]["string"];
                "application/xml": components["schemas"]["string"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["job_execution"];
                    "text/xml": components["schemas"]["job_execution"];
                    "application/xml": components["schemas"]["job_execution"];
                };
            };
            /**
             * @description `JobAlreadyRunningException` - if the job is
             *                  already running. or `JobExecutionException` - if the job could
             *                  not be executed. or `JobInvalidException` - if the job is invalid
             *                  and is therefore not executable. or `JobNotRestartableException` - if the job
             *                  does not support restarting. or `JobRestartException` - if the job could not
             *                  be restarted.
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `JobNotFoundException` - if the job with the given job ID
             *                  doesn't exist.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getJobsByIDExecutionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the ID of the job. */
                job_id: string;
                /** @description the ID of the job execution */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["job_execution"];
                    "text/xml": components["schemas"]["job_execution"];
                    "application/xml": components["schemas"]["job_execution"];
                };
            };
            /**
             * @description `JobExecutionNotFoundException` - for an
             *                  unknown job ID or job execution ID
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteJobsByIDExecutionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the ID of the job. */
                job_id: string;
                /** @description the ID of the job execution */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `JobExecutionNotFinishedException` - if the
             *                  job execution is not finished.
             */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `JobExecutionNotFoundException` - for an
             *                  unknown job ID or job execution ID
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getLibrariesByIDContentByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the shared library or the site-id in case of a private library. */
                library_id: string;
                /** @description the ID of the content asset to retrieve. */
                content_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["content_asset"];
                    "text/xml": components["schemas"]["content_asset"];
                    "application/xml": components["schemas"]["content_asset"];
                };
            };
            /** @description `ContentNotFoundException` - Indicates that the content asset with the given id is unknown. or `LibraryNotFoundException` - Indicates that library with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putLibrariesByIDContentByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the shared library or the site-id in case of a private library. */
                library_id: string;
                /** @description the ID of the content asset to retrieve. */
                content_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["content_asset"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["content_asset"];
                    "text/xml": components["schemas"]["content_asset"];
                    "application/xml": components["schemas"]["content_asset"];
                };
            };
            /** @description `IdConflictException` - Indicates that the ID from the request body doesn't match the URL-Id. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ContentNotFoundException` - Indicates that the content asset with the given id is unknown. or `LibraryNotFoundException` - Indicates that library with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ResourceLockedException` - Indicates that the ID from the request body doesn't match the URL-Id. */
            412: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteLibrariesByIDContentByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the shared library or the site-id in case of a private library. */
                library_id: string;
                /** @description the ID of the content asset to remove. */
                content_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ContentNotFoundException` - Indicates that the content asset with the given id is unknown. or `LibraryNotFoundException` - Indicates that library with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ResourceLockedException` - Indicates that the ID from the request body doesn't match the URL-Id. */
            412: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchLibrariesByIDContentByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the shared library or the site-id in case of a private library. */
                library_id: string;
                /** @description the ID of the content asset to retrieve. */
                content_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["content_asset"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["content_asset"];
                    "text/xml": components["schemas"]["content_asset"];
                    "application/xml": components["schemas"]["content_asset"];
                };
            };
            /** @description `ContentIdAlreadyInUseException` - Indicates that a content asset with the ID to change to is already existing. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ContentNotFoundException` - Indicates that the content asset with the given id is unknown. or `LibraryNotFoundException` - Indicates that library with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ResourceLockedException` - Indicates that the ID from the request body doesn't match the URL-Id. */
            412: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getLibrariesByIDContentByIDFolders: {
        parameters: {
            query?: {
                /** @description The result set index to return the first instance for. Default value is 0. */
                start?: number;
                /** @description The maximum number of instances per request. Default value is 25. */
                count?: number;
            };
            header?: never;
            path: {
                /** @description ID of the shared library or the site-id in case of a private library. */
                library_id: string;
                /** @description The content id of the assignment. */
                content_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["content_folder_result"];
                    "text/xml": components["schemas"]["content_folder_result"];
                    "application/xml": components["schemas"]["content_folder_result"];
                };
            };
            /** @description `ContentNotFoundException` - Indicates that the content asset with the given id is unknown. or `LibraryNotFoundException` - Indicates that library with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getLibrariesByIDFolderAssignmentsByIDByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the shared library or the site-id in case of a private library. */
                library_id: string;
                /** @description the ID of the content asset to retrieve. */
                content_id: string;
                /** @description ID of a target folder. */
                folder_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["content_folder_assignment"];
                    "text/xml": components["schemas"]["content_folder_assignment"];
                    "application/xml": components["schemas"]["content_folder_assignment"];
                };
            };
            /** @description `AssignmentNotFoundException` - Indicates that no assignment between the given content asset and folder exists or `ContentNotFoundException` - Indicates that the content asset with the given id is unknown. or `LibraryNotFoundException` - Indicates that library with the given id is unknown. or `ParentFolderNotFoundException` - Indicates that the parent folder with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putLibrariesByIDFolderAssignmentsByIDByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the ID of the shared library or the site-id in case of a private library */
                library_id: string;
                /** @description the content id */
                content_id: string;
                /** @description the folder id */
                folder_id: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["content_folder_assignment"];
                "text/xml": components["schemas"]["content_folder_assignment"];
                "application/xml": components["schemas"]["content_folder_assignment"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["content_folder_assignment"];
                    "text/xml": components["schemas"]["content_folder_assignment"];
                    "application/xml": components["schemas"]["content_folder_assignment"];
                };
            };
            /** @description `ContentNotFoundException` - Indicates that the content asset with the given id is unknown. or `LibraryNotFoundException` - Indicates that library with the given id is unknown. or `ParentFolderNotFoundException` - Indicates that the parent folder with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteLibrariesByIDFolderAssignmentsByIDByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the shared library or the site-id in case of a private library. */
                library_id: string;
                /** @description the ID of the content asset to retrieve. */
                content_id: string;
                /** @description ID of a target folder. */
                folder_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AssignmentNotFoundException` - Indicates that no assignment between the given content asset and folder exists or `ContentNotFoundException` - Indicates that the content asset with the given id is unknown. or `LibraryNotFoundException` - Indicates that library with the given id is unknown. or `ParentFolderNotFoundException` - Indicates that the parent folder with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchLibrariesByIDFolderAssignmentsByIDByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the shared library or the site-id in case of a private library. */
                library_id: string;
                /** @description the content id of the assignment */
                content_id: string;
                /** @description ID of a target folder. */
                folder_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["content_folder_assignment"];
                "text/xml": components["schemas"]["content_folder_assignment"];
                "application/xml": components["schemas"]["content_folder_assignment"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["content_folder_assignment"];
                    "text/xml": components["schemas"]["content_folder_assignment"];
                    "application/xml": components["schemas"]["content_folder_assignment"];
                };
            };
            /** @description `AssignmentNotFoundException` - Indicates that no assignment between the given content asset and folder exists. or `ContentNotFoundException` - Indicates that the content asset with the given id is unknown. or `FolderNotFoundException` - Indicates that the folder with the given id is unknown. or `LibraryNotFoundException` - Indicates that library with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getLibrariesByIDFoldersByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the shared library or the site-id in case of a private library. */
                library_id: string;
                /** @description ID of a target folder. */
                folder_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["content_folder"];
                    "text/xml": components["schemas"]["content_folder"];
                    "application/xml": components["schemas"]["content_folder"];
                };
            };
            /** @description `FolderNotFoundException` - Indicates that the folder with the given id is unknown. or `LibraryNotFoundException` - Indicates that library with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putLibrariesByIDFoldersByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the shared library or the site-id in case of a private library. */
                library_id: string;
                /** @description ID of a target folder. */
                folder_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["content_folder"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["content_folder"];
                    "text/xml": components["schemas"]["content_folder"];
                    "application/xml": components["schemas"]["content_folder"];
                };
            };
            /** @description `IdConflictException` - Indicates that the ID from the request body doesn't match the URL-Id. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `LibraryNotFoundException` - Indicates that library with the given id is unknown. or `ParentFolderNotFoundException` - Indicates that the parent folder with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteLibrariesByIDFoldersByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the shared library or the site-id in case of a private library. */
                library_id: string;
                /** @description ID of a target folder. */
                folder_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `LibraryNotFoundException` - Indicates that library with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchLibrariesByIDFoldersByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the shared library or the site-id in case of a private library. */
                library_id: string;
                /** @description ID of a target folder. */
                folder_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["content_folder"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["content_folder"];
                    "text/xml": components["schemas"]["content_folder"];
                    "application/xml": components["schemas"]["content_folder"];
                };
            };
            /** @description `ContentFolderIdAlreadyInUseException` - Indicates that a content folder with the ID to change to is already existing. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `FolderNotFoundException` - Indicates that the folder with the given id is unknown. or `LibraryNotFoundException` - Indicates that library with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getLibrariesByIDFoldersByIDContent: {
        parameters: {
            query?: {
                /** @description The result set index to return the first instance for. Default value is 0. */
                start?: number;
                /** @description The maximum number of instances per request. Default value is 25. */
                count?: number;
            };
            header?: never;
            path: {
                /** @description ID of the shared library or the site-id in case of a private library. */
                library_id: string;
                /** @description ID of a target folder. */
                folder_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["content_asset_result"];
                    "text/xml": components["schemas"]["content_asset_result"];
                    "application/xml": components["schemas"]["content_asset_result"];
                };
            };
            /** @description `FolderNotFoundException` - Indicates that the folder with the given id is unknown. or `LibraryNotFoundException` - Indicates that library with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getLibrariesByIDFoldersByIDSubFolders: {
        parameters: {
            query?: {
                /** @description The result set index to return the first instance for. Default value is 0. */
                start?: number;
                /** @description The maximum number of instances per request. Default value is 25. */
                count?: number;
            };
            header?: never;
            path: {
                /** @description ID of the shared library or the site-id in case of a private library. */
                library_id: string;
                /** @description ID of a target folder. */
                folder_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["content_sub_folder_result"];
                    "text/xml": components["schemas"]["content_sub_folder_result"];
                    "application/xml": components["schemas"]["content_sub_folder_result"];
                };
            };
            /** @description `FolderNotFoundException` - Indicates that the folder with the given id is unknown. or `LibraryNotFoundException` - Indicates that library with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getLocaleInfoLocales: {
        parameters: {
            query?: {
                /**
                 * @description optional locale to return by id.  If specified, that locale is looked up and returned, otherwise the
                 *                    list is returned.
                 */
                id?: string;
                /** @description the set of fields to return from the request.  Default is only the locale id. */
                select?: string;
                /** @description the start index for paging.  Default is 0. */
                start?: number;
                /** @description the count of the records to return in this page.  Default is 25. */
                count?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["locale_result"];
                    "text/xml": components["schemas"]["locale_result"];
                    "application/xml": components["schemas"]["locale_result"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postLogRequestsEcdn: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Request body */
        requestBody: {
            content: {
                "application/json": components["schemas"]["ecdn_log_fetch_request"];
                "text/xml": components["schemas"]["ecdn_log_fetch_request"];
                "application/xml": components["schemas"]["ecdn_log_fetch_request"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ecdn_log_fetch_response"];
                    "text/xml": components["schemas"]["ecdn_log_fetch_response"];
                    "application/xml": components["schemas"]["ecdn_log_fetch_response"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getLogRequestsEcdnByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the log fetching execution */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ecdn_log_fetch_response"];
                    "text/xml": components["schemas"]["ecdn_log_fetch_response"];
                    "application/xml": components["schemas"]["ecdn_log_fetch_response"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getMetricsByID: {
        parameters: {
            query?: {
                /** @description Optional offset of the result set not counting commentaries or empty lines. */
                offset?: number;
                /** @description Optional limit of the result set not counting commentaries or empty lines. */
                limit?: number;
            };
            header?: never;
            path: {
                /** @description Type of the api. Values are  <code> data </code>  or  <code> shop </code> . */
                apitype: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["metric_response"];
                    "text/xml": components["schemas"]["metric_response"];
                    "application/xml": components["schemas"]["metric_response"];
                };
            };
            /** @description `TooManyRequestsException` - Too many requests. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `FeatureNotEnabledException` - Feature not enabled. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getOcapiConfigsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description client ID */
                clientId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ocapi_configs_api_response"];
                    "text/xml": components["schemas"]["ocapi_configs_api_response"];
                    "application/xml": components["schemas"]["ocapi_configs_api_response"];
                };
            };
            /** @description `InvalidOCAPIConfigException` - Indicates that at least one of the existing configs can not be parsed */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putOcapiConfigsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description client ID */
                clientId: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["ocapi_configs_api_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ocapi_configs_api_response"];
                    "text/xml": components["schemas"]["ocapi_configs_api_response"];
                    "application/xml": components["schemas"]["ocapi_configs_api_response"];
                };
            };
            /** @description `InvalidOCAPIConfigException` - Indicates that the resulting config is not valid or `SelfUpdateException` - Write operation on self is not allowed. (The clientId being used for calling this API should be different from target clientId) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `SiteNotFoundException` - Indicates that at least one of the target sites is unknown */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postOcapiConfigsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description client ID */
                clientId: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["ocapi_configs_api_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ocapi_configs_api_response"];
                    "text/xml": components["schemas"]["ocapi_configs_api_response"];
                    "application/xml": components["schemas"]["ocapi_configs_api_response"];
                };
            };
            /** @description `InvalidOCAPIConfigException` - Indicates that the resulting config is not valid or `SelfUpdateException` - Write operation on self is not allowed. (The clientId being used for calling this API should be different from target clientId) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `SiteNotFoundException` - Indicates that at least one of the target sites is unknown */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `DuplicateClientIdException` - Indicates that the client id already exists in original OCAPI configuration */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteOcapiConfigsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Id of the client to be deleted. */
                clientId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `InvalidOCAPIConfigException` - Indicates that the resulting config is not valid or `SelfUpdateException` - Write operation on self is not allowed. (The clientId being used for calling this API should be different from target clientId) */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getPermissions: {
        parameters: {
            query?: {
                /** @description The permission expand. A comma separated list with the allowed values (bm, csc). */
                expand?: string[];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["application_permissions"];
                    "text/xml": components["schemas"]["application_permissions"];
                    "application/xml": components["schemas"]["application_permissions"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getPermissionsBm: {
        parameters: {
            query?: {
                /**
                 * @description The permission expand. A comma separated list with the allowed values
                 *      (module, functional, webdav, locale).
                 */
                expand?: string[];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["bmpermissions"];
                    "text/xml": components["schemas"]["bmpermissions"];
                    "application/xml": components["schemas"]["bmpermissions"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getPermissionsBmFunctional: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["functional_permissions"];
                    "text/xml": components["schemas"]["functional_permissions"];
                    "application/xml": components["schemas"]["functional_permissions"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getPermissionsBmLocale: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["locale_permissions"];
                    "text/xml": components["schemas"]["locale_permissions"];
                    "application/xml": components["schemas"]["locale_permissions"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getPermissionsBmModule: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["module_permissions"];
                    "text/xml": components["schemas"]["module_permissions"];
                    "application/xml": components["schemas"]["module_permissions"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getPermissionsBmWebdav: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["webdav_permissions"];
                    "text/xml": components["schemas"]["webdav_permissions"];
                    "application/xml": components["schemas"]["webdav_permissions"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getPermissionsCsc: {
        parameters: {
            query?: {
                /**
                 * @description The permission expand. A comma separated list with the allowed values
                 *      (module, functional, webdav, locale).
                 */
                expand?: string[];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["cscpermissions"];
                    "text/xml": components["schemas"]["cscpermissions"];
                    "application/xml": components["schemas"]["cscpermissions"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getPermissionsCscModule: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["module_permissions"];
                    "text/xml": components["schemas"]["module_permissions"];
                    "application/xml": components["schemas"]["module_permissions"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postProductSearch: {
        parameters: {
            query?: {
                /** @description The site context. */
                site_id?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["search_request"];
                "text/xml": components["schemas"]["search_request"];
                "application/xml": components["schemas"]["search_request"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_search_result"];
                    "text/xml": components["schemas"]["product_search_result"];
                    "application/xml": components["schemas"]["product_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Indicates the search query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getProductsByID: {
        parameters: {
            query?: {
                /** @description The site context. */
                site_id?: string;
                /**
                 * @description The list of expansions that can be applied to the product. They are:
                 *      		   <ul>
                 *             	 <li> 'all' will retrieve all the product properties. </li>
                 *                <li> 'availability' will retrieve the following properties:
                 *                  <ul> <li> ats </li>
                 *                  <li> in_stock </li>
                 *                  <li> online </li> </ul>
                 *     		     </li>
                 *                <li> 'images' will retrieve the following properties:
                 *                  <ul> <li> image </li>
                 *                      <li> image_groups </li> </ul>
                 *     			 </li>
                 *     			 <li> 'all_images' used with images will retrieve the following properties, including the images specified for its variants and variation groups:
                 *                  <ul> <li> image </li>
                 *                      <li> image_groups </li> </ul>
                 *     			 </li>
                 *     		     <li> 'categories' will retrieve the following properties:
                 *     		       <ul> <li> assigned_categories </li>
                 *                           <li> primary_category </li>
                 *                           <li> classification_category </li>
                 *                       </ul>
                 *     		     </li>
                 *                <li> 'options' will retrieve the following properties:
                 *                  <ul> <li> product_options </li> </ul>
                 *     			 </li>
                 *                <li> 'prices' will retrieve the following properties:
                 *                  <ul> <li> price </li>
                 *                  <li> price_currency </li> </ul>
                 *     			 </li>
                 *                <li> 'variations' will retrieve the following properties:
                 *                  <ul> <li> master </li>
                 *                  <li> variation_attributes </li>
                 *                  <li> variation_groups </li>
                 *                  <li> variation_values </li>
                 *                  <li> variants </li> </ul>
                 *                </li>
                 *                <li> 'sets' will retrieve the following properties:
                 *                  <ul> <li> set_products </li>
                 *                  <li> product_sets </li>
                 *                  </ul>
                 *     			 </li>
                 *                <li> 'bundles' will retrieve the following properties:
                 *                  <ul> <li> product_bundles </li>
                 *                  <li> bundled_products </li>
                 *                  </ul>
                 *     			 </li>
                 *              </ul>
                 *             Note that only variants with variation values are retrieved for a product of type variation master.
                 */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description The product ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product"];
                    "text/xml": components["schemas"]["product"];
                    "application/xml": components["schemas"]["product"];
                };
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putProductsByID: {
        parameters: {
            query?: never;
            header?: {
                "x-dw-validate-existing"?: boolean;
            };
            path: {
                /** @description The product ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["product"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product"];
                    "text/xml": components["schemas"]["product"];
                    "application/xml": components["schemas"]["product"];
                };
            };
            /** @description `IdConflictException` - Indicates the ID in request URL does not match the ID in the product document. or `ProductDuplicateException` - Indicate the product is already existed. or `ProductInvalidException` - Indicates the catalog is not provided in the request. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CatalogNotFoundException` - Indicates the catalog is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteProductsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The product ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchProductsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The product ID. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["product"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product"];
                    "text/xml": components["schemas"]["product"];
                    "application/xml": components["schemas"]["product"];
                };
            };
            /** @description `IdConflictException` - Indicates the ID in request URL does not match the ID in the product document. or `ProductDefaultVariantException` - Indicates there is a problem to set default variant for a product. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates the product to be updated is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postProductsByIDVariantSearch: {
        parameters: {
            query?: {
                /** @description The id of the site to get site specific product attributes. */
                site_id?: string;
            };
            header?: never;
            path: {
                /** @description The product id of master product or variation group product */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variant_search_result"];
                    "text/xml": components["schemas"]["variant_search_result"];
                    "application/xml": components["schemas"]["variant_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. or `ProductNotMasterGroupException` - Thrown if the id is not the product id of a Variation Master product or Variation Group product. or `SiteIdMissingForSiteSpecificFilterException` - Thrown if the Site ID query parameter is missing in the search of Variants by a site-specific product attribute. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Thrown if the product is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getProductsByIDVariationGroups: {
        parameters: {
            query?: {
                /** @description The site context. */
                site_id?: string;
                /** @description The start index of the variation groups to return (defaults to 0). */
                start?: number;
                /** @description The maximum number of variation groups to return (defaults to 25). */
                count?: number;
                /** @description A selector that specifies the fields to return in the variation groups document. */
                select?: string;
                /** @description The valid expands are {price,availability} */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description The id of the master product. */
                master_product_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_groups"];
                    "text/xml": components["schemas"]["variation_groups"];
                    "application/xml": components["schemas"]["variation_groups"];
                };
            };
            /** @description `ProductNotMasterException` - Indicates that the given product is not a variation master. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates the master product is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getProductsByIDVariationGroupsByID: {
        parameters: {
            query?: {
                site_id?: string;
                /** @description The valid expands are {price,availability} */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description The id of the master product that contains the variation group. */
                master_product_id: string;
                /** @description The id of the variation group product. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_group"];
                    "text/xml": components["schemas"]["variation_group"];
                    "application/xml": components["schemas"]["variation_group"];
                };
            };
            /** @description `ProductIsNotVariationGroupException` - Indicates the product specified is not a variation group. or `ProductNotMasterException` - Indicates the master product id does not represent a master product. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates either the master product or the variation group product cannot be found. or `VariationGroupNotFoundException` - Indicates the product does not belong to the master product. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putProductsByIDVariationGroupsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the master product that contains the variation group. */
                master_product_id: string;
                /** @description The id of the variation group product. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["variation_group"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_group"];
                    "text/xml": components["schemas"]["variation_group"];
                    "application/xml": components["schemas"]["variation_group"];
                };
            };
            /** @description `ProductNotMasterException` - Indicates the master product id does not represent a master product. or `VariationValueNotValidException` - Indicates the values passed are not valid for the variation attributes. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates either the master product or the variation group product cannot be found. or `VariationAttributeValueNotFoundException` - Indicates the value passed into a variation attribute is not one found in the valid values. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteProductsByIDVariationGroupsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                master_product_id: string;
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductIsNotVariationGroupException` - Indicates product specified is not a variation group. or `ProductNotMasterException` - Indicates the master product id does not represent a master product. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates either the master product or the variation group product cannot be found. or `VariationGroupNotFoundException` - Indicates the product does not belong to the master product. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchProductsByIDVariationGroupsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the master product that contains the variation group. */
                master_product_id: string;
                /** @description The id of the variation group product. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["variation_group"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_group"];
                    "text/xml": components["schemas"]["variation_group"];
                    "application/xml": components["schemas"]["variation_group"];
                };
            };
            /** @description `ProductIsNotVariationGroupException` - Indicates product specified is not a variation group. or `ProductNotMasterException` - Indicates the master product id does not represent a master product. or `VariationValueNotValidException` - Indicates the values passed are not valid for the variation attributes. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates either the master product or the variation group product cannot be found. or `VariationGroupNotFoundException` - Indicates the product does not belong to the master product. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getProductsByIDVariations: {
        parameters: {
            query?: {
                /** @description The site context. */
                site_id?: string;
                /** @description The start index of the variations to return (defaults to 0). */
                start?: number;
                /** @description The maximum number of variations to return (defaults to 25). */
                count?: number;
                /** @description A selector that specifies the fields to return in the variations document. */
                select?: string;
                /** @description The valid expands are {price,availability} */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description The id of the master product. */
                master_product_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variants"];
                    "text/xml": components["schemas"]["variants"];
                    "application/xml": components["schemas"]["variants"];
                };
            };
            /** @description `ProductNotMasterException` - Indicates that the given product is not a variation master. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates the master product is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getProductsByIDVariationsByID: {
        parameters: {
            query?: {
                site_id?: string;
                /** @description The valid expands are {variation,attributes,availability,prices} */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description The id of the master product that contains the variation. */
                master_product_id: string;
                /** @description The id of the variation product. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variant"];
                    "text/xml": components["schemas"]["variant"];
                    "application/xml": components["schemas"]["variant"];
                };
            };
            /** @description `ProductIsNotVariationException` - Indicates the product specified is not a variation. or `ProductNotMasterException` - Indicates the master product id does not represent a master product. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates either the master product or the variation product cannot be found. or `VariationNotFoundException` - Indicates the product does not belong to the master product. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putProductsByIDVariationsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the master product that contains the variation. */
                master_product_id: string;
                /** @description The id of the variation product. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["variant"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variant"];
                    "text/xml": components["schemas"]["variant"];
                    "application/xml": components["schemas"]["variant"];
                };
            };
            /** @description `ProductNotMasterException` - Indicates the master product id does not represent a master product. or `VariationValueNotValidException` - Indicates the values passed are not valid for the variation attributes. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates either the master product or the variation product cannot be found. or `VariationAttributeValueNotFoundException` - Indicates the value passed into a variation attribute is not one found in the valid values. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteProductsByIDVariationsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                master_product_id: string;
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductIsNotVariationException` - Indicates product specified is not a variation. or `ProductNotMasterException` - Indicates the master product id does not represent a master product. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates either the master product or the variation product cannot be found. or `VariationNotFoundException` - Indicates the product does not belong to the master product. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchProductsByIDVariationsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the master product that contains the variation. */
                master_product_id: string;
                /** @description The id of the variation product. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["variant"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variant"];
                    "text/xml": components["schemas"]["variant"];
                    "application/xml": components["schemas"]["variant"];
                };
            };
            /** @description `ProductIsNotVariationException` - Indicates product specified is not a variation. or `ProductNotMasterException` - Indicates the master product id does not represent a master product. or `VariationValueNotValidException` - Indicates the values passed are not valid for the variation attributes. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates either the master product or the variation product cannot be found. or `VariationNotFoundException` - Indicates the product does not belong to the master product. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getProductsByIDProductOptions: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
                /** @description The currency mnemonic for retrieving the product option values according to the sorting mode.ex:'USD' */
                currency?: string;
            };
            header?: never;
            path: {
                /** @description The id of the product. */
                product_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_options"];
                    "text/xml": components["schemas"]["product_options"];
                    "application/xml": components["schemas"]["product_options"];
                };
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getProductsByIDProductOptionsByID: {
        parameters: {
            query?: {
                /** @description The currency mnemonic for retrieving the product option values according to the sorting mode.ex:'USD' */
                currency?: string;
            };
            header?: never;
            path: {
                /** @description The id of the product. */
                product_id: string;
                /** @description The id of the local or shared product option. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_option"];
                    "text/xml": components["schemas"]["product_option"];
                    "application/xml": components["schemas"]["product_option"];
                };
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. or `ProductOptionNotFoundException` - Indicates the local or shared product option is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putProductsByIDProductOptionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the product. */
                product_id: string;
                /** @description The id of the local or shared product option. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["product_option"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_option"];
                    "text/xml": components["schemas"]["product_option"];
                    "application/xml": components["schemas"]["product_option"];
                };
            };
            /** @description `ProductOptionCreateException` - Indicates the local product option cannot be created for a product of type variation group. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteProductsByIDProductOptionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the product. */
                product_id: string;
                /** @description The id of the local or shared product option. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. or `ProductOptionNotFoundException` - Indicates the local or shared product option is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchProductsByIDProductOptionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the product. */
                product_id: string;
                /** @description The id of the local product option. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["product_option"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_option"];
                    "text/xml": components["schemas"]["product_option"];
                    "application/xml": components["schemas"]["product_option"];
                };
            };
            /** @description `ProductOptionUpdateException` - Indicates the shared product option cannot be updated. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. or `ProductOptionNotFoundException` - Indicates the local product option is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getProductsByIDProductOptionsByIDValues: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The id of the product. */
                product_id: string;
                /** @description The id of the local product option. */
                option_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_option_values"];
                    "text/xml": components["schemas"]["product_option_values"];
                    "application/xml": components["schemas"]["product_option_values"];
                };
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. or `ProductOptionNotFoundException` - Indicates the local product option is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getProductsByIDProductOptionsByIDValuesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the product. */
                product_id: string;
                /** @description The id of the local product option. */
                option_id: string;
                /** @description the id of local product option value. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_option_value"];
                    "text/xml": components["schemas"]["product_option_value"];
                    "application/xml": components["schemas"]["product_option_value"];
                };
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. or `ProductOptionNotFoundException` - Indicates the local product option is not found. or `ProductOptionValueNotFoundException` - Indicates the local product option value is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putProductsByIDProductOptionsByIDValuesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the product. */
                product_id: string;
                /** @description The id of the local product option. */
                option_id: string;
                /** @description The id of the local product option value. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["product_option_value"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_option_value"];
                    "text/xml": components["schemas"]["product_option_value"];
                    "application/xml": components["schemas"]["product_option_value"];
                };
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. or `ProductOptionNotFoundException` - Indicates the local product option is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteProductsByIDProductOptionsByIDValuesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the product. */
                product_id: string;
                /** @description The id of the local product option. */
                option_id: string;
                /** @description The id of the local product option value. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. or `ProductOptionNotFoundException` - Indicates the local product option is not found. or `ProductOptionValueNotFoundException` - Indicates the local product option value is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchProductsByIDProductOptionsByIDValuesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the product. */
                product_id: string;
                /** @description The id of the local product option. */
                option_id: string;
                /** @description The id of the local product option value. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["product_option_value"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["product_option_value"];
                    "text/xml": components["schemas"]["product_option_value"];
                    "application/xml": components["schemas"]["product_option_value"];
                };
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. or `ProductOptionNotFoundException` - Indicates the local product option is not found. or `ProductOptionValueNotFoundException` - Indicates the local product option value is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getProductsByIDVariationAttributes: {
        parameters: {
            query?: {
                start?: number;
                count?: number;
                select?: string;
            };
            header?: never;
            path: {
                /** @description The product ID of a variant or a variation master or a variation group. */
                product_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_attributes"];
                    "text/xml": components["schemas"]["variation_attributes"];
                    "application/xml": components["schemas"]["variation_attributes"];
                };
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getProductsByIDVariationAttributesByIDValues: {
        parameters: {
            query?: {
                site_id?: string;
                /** @description the first record to get in the page */
                start?: number;
                /** @description the number of records to get */
                count?: number;
                /** @description a string that specifies which fields to return (default is all). */
                select?: string;
                /** @description set of expands to retrieve additional information: {availability, image} */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description id of the product */
                product_id: string;
                /** @description The variation attribute ID that contains the values. */
                attribute_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_attribute_values"];
                    "text/xml": components["schemas"]["variation_attribute_values"];
                    "application/xml": components["schemas"]["variation_attribute_values"];
                };
            };
            /** @description `ProductNotMasterException` - Indicates the master product is not found. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. or `VariationAttributeNotFoundException` - If the attribute id specified is not a valid product attribute. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getProductsByIDVariationAttributesByIDValuesByID: {
        parameters: {
            query?: {
                /** @description The site context. */
                site_id?: string;
                /** @description set of expands to retrieve additional information: {availability, image} */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description The master product ID. */
                product_id: string;
                /** @description The variation attribute custom ID */
                attribute_id: string;
                /** @description The id of the variation attribute value */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_attribute_value"];
                    "text/xml": components["schemas"]["variation_attribute_value"];
                    "application/xml": components["schemas"]["variation_attribute_value"];
                };
            };
            /** @description `ProductNotMasterException` - Indicates the master product is not found. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. or `VariationAttributeValueNotFoundException` - If the value id specified is not a valid value id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putProductsByIDVariationAttributesByIDValuesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The master product ID. */
                product_id: string;
                /** @description The variation attribute ID */
                attribute_id: string;
                /** @description The id of the variation attribute value */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["variation_attribute_value"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_attribute_value"];
                    "text/xml": components["schemas"]["variation_attribute_value"];
                    "application/xml": components["schemas"]["variation_attribute_value"];
                };
            };
            /** @description `ProductNotMasterException` - Indicates the master product is not found. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. or `VariationAttributeNotFoundException` - If the attribute id specified is not a valid product attribute. or `VariationAttributeValueNotFoundException` - If the value id specified is not a valid value id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteProductsByIDVariationAttributesByIDValuesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the product. */
                product_id: string;
                /** @description The id of the variation attribute that contains the value. */
                attribute_id: string;
                /** @description The id of one value to remove */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - If the product id specified cannot be found. or `VariationAttributeNotFoundException` - If the attribute id specified is not a valid product attribute. or `VariationAttributeValueNotFoundException` - If the value id specified is not a valid value id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchProductsByIDVariationAttributesByIDValuesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the product. */
                product_id: string;
                /** @description The id of the requested variation attribute. */
                attribute_id: string;
                /** @description The id of the variation value. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["variation_attribute_value"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_attribute_value"];
                    "text/xml": components["schemas"]["variation_attribute_value"];
                    "application/xml": components["schemas"]["variation_attribute_value"];
                };
            };
            /** @description `ProductNotFoundException` - If the product id specified cannot be found. or `VariationAttributeNotFoundException` - If the attribute id specified is not a valid product attribute. or `VariationAttributeValueNotFoundException` - If the value id specified is not a valid value id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getProductsByIDVariationAttributesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The product ID of a variant or a variation master or a variation group. */
                product_id: string;
                /** @description The id of the requested variation attribute. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_attribute"];
                    "text/xml": components["schemas"]["variation_attribute"];
                    "application/xml": components["schemas"]["variation_attribute"];
                };
            };
            /** @description `ProductNotMasterException` - Indicates the master product is not found. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. or `VariationAttributeNotFoundException` - Indicates that the variation attribute is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putProductsByIDVariationAttributesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the product. */
                product_id: string;
                /** @description The id of the variation attribute to create. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["variation_attribute"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_attribute"];
                    "text/xml": components["schemas"]["variation_attribute"];
                    "application/xml": components["schemas"]["variation_attribute"];
                };
            };
            /** @description `ProductNotMasterException` - Indicates the master product is not found. or `ProductVariationAttributeDefinitionNotUniqueException` - Indicates that the variation attribute definition is not unique. or `ProductVariationAttributeIDNotUniqueException` - Indicates that the variation attribute id is not unique. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeDefinitionNotFoundException` - If attribute definition supplied is not a product attribute. or `ProductNotFoundException` - Indicates the product is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteProductsByIDVariationAttributesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the product. */
                product_id: string;
                /** @description One variation attribute id to remove. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotMasterException` - Indicates the master product is not found. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. or `VariationAttributeNotFoundException` - Indicates that the variation attribute is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchProductsByIDVariationAttributesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the product. */
                product_id: string;
                /** @description The id of the requested variation attribute. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["variation_attribute"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["variation_attribute"];
                    "text/xml": components["schemas"]["variation_attribute"];
                    "application/xml": components["schemas"]["variation_attribute"];
                };
            };
            /** @description `ProductNotMasterException` - Indicates the master product is not found. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ProductNotFoundException` - Indicates the product is not found. or `VariationAttributeNotFoundException` - Indicates that the variation attribute is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postRoleSearch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["role_search_request"];
                "text/xml": components["schemas"]["role_search_request"];
                "application/xml": components["schemas"]["role_search_request"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["role_search_result"];
                    "text/xml": components["schemas"]["role_search_result"];
                    "application/xml": components["schemas"]["role_search_result"];
                };
            };
            /** @description `InvalidSearchQueryException` - Throws when one of the search request restrictions is violated or `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getRoles: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
                /** @description List of expansions. */
                expand?: string[];
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["roles"];
                    "text/xml": components["schemas"]["roles"];
                    "application/xml": components["schemas"]["roles"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getRolesByID: {
        parameters: {
            query?: {
                /** @description The list of expansions. */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description The id of the requested access role. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["role"];
                    "text/xml": components["schemas"]["role"];
                    "application/xml": components["schemas"]["role"];
                };
            };
            /** @description `RoleNotFoundException` - Thrown if the access role with the given id does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putRolesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the access role to create. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["role"];
                "text/xml": components["schemas"]["role"];
                "application/xml": components["schemas"]["role"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["role"];
                    "text/xml": components["schemas"]["role"];
                    "application/xml": components["schemas"]["role"];
                };
            };
            /** @description `IdConflictException` - Thrown when id in query parameter is different from the id in the body. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `RoleOperationNotAllowedException` - Thrown when an access role with the id "Support" or "Business Support" should be created. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `RoleAlreadyExistsException` - Thrown when an access role with the given id already exists. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteRolesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the access role to delete. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `RoleOperationNotAllowedException` - Thrown if deletion of the given role is not allowed */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `RoleNotFoundException` - Thrown if the given role does not exist */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getRolesByIDPermissions: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the requested access role. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["role_permissions"];
                    "text/xml": components["schemas"]["role_permissions"];
                    "application/xml": components["schemas"]["role_permissions"];
                };
            };
            /** @description `RoleNotFoundException` - If the specified access role does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putRolesByIDPermissions: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the access role for which the permissions will be set. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["role_permissions"];
                "text/xml": components["schemas"]["role_permissions"];
                "application/xml": components["schemas"]["role_permissions"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["role_permissions"];
                    "text/xml": components["schemas"]["role_permissions"];
                    "application/xml": components["schemas"]["role_permissions"];
                };
            };
            /** @description `DefaultLocalePermissionMissingException` - If no permission for the 'default' locale is given (permission for 'default' locale is mandatory). or `DuplicatePermissionException` - If a permission is listed more than once within a scope. or `InvalidPermissionTypeException` - If the type of a given permission does not match the expected type. or `InvalidPermissionValueException` - If a permission value is given that is either unknown or not supported for a certain permission. or `InvalidPermissionValueScopeException` - If values are given permission multi values are used where only single values are support or vice versa (e.g. setting 'values' attribute of ModulePermissionWO in organization scope). or `SystemFlagMissingException` - If the 'system' flag is not set for a module permission. or `UnknownPermissionException` - If the id of a given permission could not be resolved to a permission. or `UnknownSiteIdException` - If a site specific permission is given for a site that is not known. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `RoleNotFoundException` - If the specified access role does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ResourceStateConflictException` - In case of state token conflicts. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postRolesByIDUserSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["user_search_result"];
                    "text/xml": components["schemas"]["user_search_result"];
                    "application/xml": components["schemas"]["user_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `RoleNotFoundException` - If the specified access role does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getRolesByIDUsers: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description ID of the access role. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["users"];
                    "text/xml": components["schemas"]["users"];
                    "application/xml": components["schemas"]["users"];
                };
            };
            /** @description `RoleNotFoundException` - Thrown if the access role with the given id does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putRolesByIDUsersByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the access role. */
                id: string;
                /** @description Login of the user. */
                login: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["user"];
                    "text/xml": components["schemas"]["user"];
                    "application/xml": components["schemas"]["user"];
                };
            };
            /** @description `InvalidRoleException` - Thrown if the access role with the given id does not exist. or `InvalidUserLoginException` - Thrown if a user with the given login does not exist. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `UserOperationNotAllowedException` - Thrown if the operation is not allowed. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteRolesByIDUsersByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the access role. */
                id: string;
                /** @description Login of the user. */
                login: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `UserOperationNotAllowedException` - Thrown if the admin user is unassigned from the Administrator role. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `RoleNotFoundException` - Thrown if the access role with the given id does not exist. or `UserNotFoundException` - Thrown if a user with the given login does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSettingsLoggingCustom: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["custom_log_settings"];
                    "text/xml": components["schemas"]["custom_log_settings"];
                    "application/xml": components["schemas"]["custom_log_settings"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSettingsLoggingCustom: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["custom_log_settings"];
                "text/xml": components["schemas"]["custom_log_settings"];
                "application/xml": components["schemas"]["custom_log_settings"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["custom_log_settings"];
                    "text/xml": components["schemas"]["custom_log_settings"];
                    "application/xml": components["schemas"]["custom_log_settings"];
                };
            };
            /** @description `InvalidCustomLogCategoryException` - if one of the categories names are invalid. or `InvalidLogLevelException` - if on a production instance the configured level is DEBUG. or `InvalidRecipientEmailException` - if the email addresses are invalid. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitePreferencesPreferenceGroupsByIDByIDPreferenceSearch: {
        parameters: {
            query?: {
                /** @description The preference values of type Password are masked when set. */
                mask_passwords?: boolean;
                /** @description The expand "value" is available to retrieve value definitions of the attribute definition. */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description An instance type, one of {staging,development,sandbox,production}. */
                instance_type: string;
                /** @description The ID of the preference group. */
                group_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["preference_value_search_result"];
                    "text/xml": components["schemas"]["preference_value_search_result"];
                    "application/xml": components["schemas"]["preference_value_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Indicates the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CustomPreferenceGroupNotFoundException` - Indicates the preference group is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitePreferencesPreferenceGroupsByIDByIDPreferencesByID: {
        parameters: {
            query?: {
                /** @description The preference values of type Password are masked when set. */
                mask_passwords?: boolean;
            };
            header?: never;
            path: {
                /** @description An instance type, one of {staging,development,sandbox,production}. */
                instance_type: string;
                /** @description The ID of the preference group. */
                group_id: string;
                /** @description The ID of the preference to retrieve. */
                preference_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["preference_value"];
                    "text/xml": components["schemas"]["preference_value"];
                    "application/xml": components["schemas"]["preference_value"];
                };
            };
            /** @description `CustomPreferenceGroupNotFoundException` - Indicates the preference group is not found. or `PreferenceNotFoundException` - Indicates the preference is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSiteSearch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["site_search_result"];
                    "text/xml": components["schemas"]["site_search_result"];
                    "application/xml": components["schemas"]["site_search_result"];
                };
            };
            /** @description `EnumConstraintViolationException` - Thrown if the invalid value is entered for access_type or `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSites: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["sites"];
                    "text/xml": components["schemas"]["sites"];
                    "application/xml": components["schemas"]["sites"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the id of the site */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["site"];
                    "text/xml": components["schemas"]["site"];
                    "application/xml": components["schemas"]["site"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDAbTestSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site that the A/B tests are contained within. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ab_test_search_result"];
                    "text/xml": components["schemas"]["ab_test_search_result"];
                    "application/xml": components["schemas"]["ab_test_search_result"];
                };
            };
            /** @description `SiteNotFoundException` - Indicates that site specified with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDAbTests: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description ID of the site that the A/B tests are contained within. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ab_tests"];
                    "text/xml": components["schemas"]["ab_tests"];
                    "application/xml": components["schemas"]["ab_tests"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDAbTestsByIDSegmentsByIDPromotionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the site that contains the abTest and promotion. */
                site_id: string;
                /** @description The ID of the abTest which contains the segment. */
                ab_test_id: string;
                /** @description The ID of the segment to to which the promotion is to be assigned. */
                segment_id: string;
                /** @description The ID of the promotion that is to be assigned to the abTest. */
                promotion_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ABTestNotFoundException` - Indicates that the abTest with the given abTest ID is not found. or `ABTestSegmentNotFoundException` - thrown when the segment with the given id is not found. or `PromotionNotFoundException` - Indicates that the promotion with the given promotion ID is not found. or `SiteNotFoundException` - thrown when the site with the given id is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDAbTestsByIDSegmentsByIDPromotionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                site_id: string;
                /** @description The abTest ID that promotions are to be unbound from */
                ab_test_id: string;
                /** @description the segment to bind to */
                segment_id: string;
                /** @description The ID of the promotion that is to be assigned to the abTest. */
                promotion_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ABTestNotFoundException` - Indicates that the abTest with the given abTest ID is not found. or `ABTestSegmentNotFoundException` - thrown when the segment with the given id is not found. or `PromotionNotFoundException` - thrown when promotion is not found for one of the specified promotion ids. or `SiteNotFoundException` - thrown when the site with the given id is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDAbTestsByIDSegmentsByIDSlotConfigurationsByIDByID: {
        parameters: {
            query?: {
                /**
                 * @description The context string, which consists of three parts: the context type (which must be folder,
                 *                         category or global), an equals sign (=), and the context id (either the category id or folder id).
                 *                         If you do not set this query parameter, the global context is used by default.
                 */
                context?: string;
            };
            header?: never;
            path: {
                /** @description The id of the abTest */
                ab_test_id: string;
                segment_id: string;
                /** @description The id of the site */
                site_id: string;
                /** @description The of the slot */
                slot_id: string;
                /** @description The id of the slot configuration */
                slot_config_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `InvalidContextTypeException` - Indicates the slot context type is not one of "global", "category", or "folder" */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ABTestNotFoundException` - Indicates that the abTest with the given abTest ID is not found. or `ABTestSegmentNotFoundException` - thrown when the segment with the given id is not found. or `SiteNotFoundException` - thrown when the site with the given id is not found. or `SlotConfigurationIdentifierNotFoundException` - Indicates that the slot with the given slot ID, slot configuration ID and context type is not found. or `SlotWithContextTypeNotFoundException` - Indicates that the slot with the given slot ID and context type is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDAbTestsByIDSegmentsByIDSlotConfigurationsByIDByID: {
        parameters: {
            query?: {
                /**
                 * @description The context string, which consists of three parts: the context type (which must be folder,
                 *                         category or global), an equals sign (=), and the context id (either the category id or folder id).
                 */
                context?: string;
            };
            header?: never;
            path: {
                /** @description The id of the abTest */
                ab_test_id: string;
                segment_id: string;
                /** @description The id of the site */
                site_id: string;
                /** @description The of the slot */
                slot_id: string;
                /** @description The id of the slot configuration */
                slot_config_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `InvalidContextTypeException` - Indicates the slot context type is not one of "global", "category", or "folder" */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ABTestNotFoundException` - Indicates that the abTest with the given abTest ID is not found. or `ABTestSegmentNotFoundException` - thrown when the segment with the given id is not found. or `SiteNotFoundException` - thrown when the site with the given id is not found. or `SlotConfigurationIdentifierNotFoundException` - Indicates that the slot with the given slot ID, slot configuration ID and context type is not found. or `SlotWithContextTypeNotFoundException` - Indicates that the slot with the given slot ID and context type is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDAbTestsByIDSegmentsByIDSortingRulesByIDByID: {
        parameters: {
            query?: {
                /** @description the optional context of the sorting rule, either "site" (default) or "global" */
                rule_context?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the site that contains the abTest, sorting rule and category. */
                site_id: string;
                /** @description The ID of the abTest to which the sorting rule is to be assigned. */
                ab_test_id: string;
                segment_id: string;
                /** @description The ID of sorting rule that is to be assigned to the abTest. */
                sorting_rule_id: string;
                /** @description The ID of the category that is associated with the sorting rule. */
                category_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `InvalidCategoryException` - Indicates that the category with the given category ID is not found. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ABTestNotFoundException` - Indicates that the abTest with the given abTest ID is not found. or `ABTestSegmentNotFoundException` - thrown when the segment with the given id is not found. or `SiteNotFoundException` - thrown when the site with the given id is not found. or `SortingRuleNotFoundException` - Indicates that the sorting rule with the given sorting rule ID is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `SortingRuleCampaignAssignConflictException` - Indicates that there is a sorting rule already assigned to the given abTest ID and category ID.
             *                   The sorting rule with the given sorting rule ID cannot be assigned to the same abTest ID and category ID.
             */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDAbTestsByIDSegmentsByIDSortingRulesByIDByID: {
        parameters: {
            query?: {
                /** @description the optional context of the sorting rule, either "site" (default) or "global" */
                rule_context?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the site that contains the abTest, sorting rule and category. */
                site_id: string;
                /** @description The ID of the abTest to which the sorting rule is to be assigned. */
                ab_test_id: string;
                segment_id: string;
                /** @description The ID of sorting rule that is to be assigned to the abTest. */
                sorting_rule_id: string;
                /** @description The ID of the category that is associated with the sorting rule. */
                category_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `InvalidCategoryException` - Indicates that the category with the given category ID is not found. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ABTestNotFoundException` - Indicates that the abTest with the given abTest ID is not found. or `ABTestSegmentNotFoundException` - thrown when the segment with the given id is not found. or `SiteNotFoundException` - thrown when the site with the given id is not found. or `SortingRuleNotFoundException` - Indicates that the sorting rule with the given sorting rule ID is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDAbTestsByID: {
        parameters: {
            query?: {
                /** @description The expand parameter. A comma separated list with the allowed values (stats, promotions, sorting_rules, slot_configs) */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description ID of the site that the A/B tests are contained within. */
                site_id: string;
                /** @description The id of the requested A/B Test. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ab_test"];
                    "text/xml": components["schemas"]["ab_test"];
                    "application/xml": components["schemas"]["ab_test"];
                };
            };
            /** @description `SiteNotFoundException` - Indicates that site specified with the given id is unknown. or `ABTestNotFoundException` - Thrown in case the A/B Test does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDAbTestsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site that the A/B tests are contained within. */
                site_id: string;
                /** @description The id of the requested A/B Test. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["ab_test"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ab_test"];
                    "text/xml": components["schemas"]["ab_test"];
                    "application/xml": components["schemas"]["ab_test"];
                };
            };
            /** @description `ABTestInvalidEmailException` - Thrown if an invalid email is specified. or `ABTestInvalidPipelineException` - Thrown if an invalid pipeline is specified. or `ABTestInvalidTriggerException` - Thrown if there is missing pipline_call or categories in the specified trigger of type pipeline_call or category_view_page respectively. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `SiteNotFoundException` - Indicates that site specified with the given id is unknown. or `ABTestNotFoundException` - Thrown in case the A/B Test does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `ABTestDuplicateException` - If an A/B Test exists already in the site with the given identifier and the header
             *     x-dw-validate-existing=true is passed in with the request.
             */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDAbTestsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site that the A/B tests are contained within. */
                site_id: string;
                /** @description The id of the requested A/B Test. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `SiteNotFoundException` - Indicates that site specified with the given id is unknown. or `ABTestNotFoundException` - Thrown in case the A/B Test does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDAbTestsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site that the A/B tests are contained within. */
                site_id: string;
                /** @description The id of the requested A/B Test. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["ab_test"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ab_test"];
                    "text/xml": components["schemas"]["ab_test"];
                    "application/xml": components["schemas"]["ab_test"];
                };
            };
            /** @description `ABTestInvalidEmailException` - Thrown if an invalid email is specified. or `ABTestInvalidPipelineException` - Thrown if an invalid pipeline is specified. or `ABTestInvalidTriggerException` - Thrown if there is missing pipline_call or categories in the specified trigger of type pipeline_call or category_view_page respectively. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `SiteNotFoundException` - Indicates that site specified with the given id is unknown. or `ABTestNotFoundException` - Thrown in case the A/B Test does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ABTestDuplicateException` - Thrown if an A/B Test exists already in the site with the given identifier specified in the body that is different from the identifier in the path. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDAbTestsByIDSegmentsByID: {
        parameters: {
            query?: {
                /** @description The expand parameter. A comma separated list with the allowed values (stats, promotions, sorting_rules, slot_configs) */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description ID of the site that the A/B tests are contained within. */
                site_id: string;
                /** @description The id of the requested A/B Test. */
                id: string;
                /** @description The id of the segment in the test. */
                segment_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ab_test_segment"];
                    "text/xml": components["schemas"]["ab_test_segment"];
                    "application/xml": components["schemas"]["ab_test_segment"];
                };
            };
            /** @description `SiteNotFoundException` - Indicates that site specified with the given id is unknown. or `ABTestNotFoundException` - Thrown in case the A/B Test does not exist matching the given id or `ABTestSegmentNotFoundException` - Thrown if the segment cannot be found in the A/B Test provided */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDAbTestsByIDSegmentsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site that the A/B tests are contained within. */
                site_id: string;
                /** @description The id of the requested A/B Test. */
                id: string;
                /** @description The id of the segment in the test. */
                segment_id: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["ab_test_segment"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ab_test_segment"];
                    "text/xml": components["schemas"]["ab_test_segment"];
                    "application/xml": components["schemas"]["ab_test_segment"];
                };
            };
            /** @description `SiteNotFoundException` - Indicates that site specified with the given id is unknown. or `ABTestNotFoundException` - Thrown in case the A/B Test does not exist matching the given id or `ABTestSegmentNotFoundException` - Thrown if the segment cannot be found in the A/B Test provided */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDAbTestsByIDSegmentsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site that the A/B tests are contained within. */
                site_id: string;
                /** @description The id of the requested A/B Test. */
                id: string;
                /** @description The id of the segment in the test. */
                segment_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `SiteNotFoundException` - Indicates that site specified with the given id is unknown. or `ABTestNotFoundException` - Thrown in case the A/B Test does not exist matching the given id or `ABTestSegmentNotFoundException` - Thrown if the segment cannot be found in the A/B Test provided */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDAbTestsByIDSegmentsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site that the A/B tests are contained within. */
                site_id: string;
                /** @description The id of the requested A/B Test. */
                id: string;
                /** @description The id of the segment in the test. */
                segment_id: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["ab_test_segment"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ab_test_segment"];
                    "text/xml": components["schemas"]["ab_test_segment"];
                    "application/xml": components["schemas"]["ab_test_segment"];
                };
            };
            /** @description `SiteNotFoundException` - Indicates that site specified with the given id is unknown. or `ABTestNotFoundException` - Thrown in case the A/B Test does not exist matching the given id or `ABTestSegmentNotFoundException` - Thrown if the segment cannot be found in the A/B Test provided */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDAiRecommenderNames: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description Site ID to get a list of recommenders for. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["recommenders_result"];
                    "text/xml": components["schemas"]["recommenders_result"];
                    "application/xml": components["schemas"]["recommenders_result"];
                };
            };
            /** @description `CQuotientException` - If CQuotient responds with a non-success status code. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `SiteNotFoundException` - If the given site does not exist. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDCampaignSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["campaign_search_result"];
                    "text/xml": components["schemas"]["campaign_search_result"];
                    "application/xml": components["schemas"]["campaign_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDCampaignsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site the requested campaign belongs to. */
                site_id: string;
                /** @description The id of the requested campaign. */
                campaign_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["campaign"];
                    "text/xml": components["schemas"]["campaign"];
                    "application/xml": components["schemas"]["campaign"];
                };
            };
            /** @description `CampaignNotFoundException` - Thrown in case the campaign does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDCampaignsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the campaign to create. */
                campaign_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["campaign"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["campaign"];
                    "text/xml": components["schemas"]["campaign"];
                    "application/xml": components["schemas"]["campaign"];
                };
            };
            /** @description `IdConflictException` - if the Id in request is not the same as the ID in document. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDCampaignsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description A campaign id to remove */
                campaign_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDCampaignsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the requested campaign. */
                campaign_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["campaign"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["campaign"];
                    "text/xml": components["schemas"]["campaign"];
                    "application/xml": components["schemas"]["campaign"];
                };
            };
            /** @description `CampaignDuplicateException` - if a campaign exists already in the site with the given campaign id. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CampaignNotFoundException` - Thrown in case the campaign does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDCampaignsByIDCouponsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                site_id: string;
                /** @description The campaign ID that coupons are to be bound to */
                campaign_id: string;
                /** @description The coupon ID to bind to a campaign */
                coupon_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ConstraintViolationException` - Indicates some parameter constraint violation occurs */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `CampaignNotFoundException` - Indicates that the campaign with the given campaign id
             *      				is unknown.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDCampaignsByIDCouponsByID: {
        parameters: {
            query?: {
                removeInPCA?: string;
            };
            header?: never;
            path: {
                site_id: string;
                /** @description The campaign ID that coupons are to be unbound from */
                campaign_id: string;
                /** @description The coupon ID to unbind from a campaign */
                coupon_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ConstraintViolationException` - Indicates some parameter constraint violation occurs */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `CampaignNotFoundException` - Indicates that the campaign with the given campaign id
             *      				is unknown.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDCampaignsByIDCustomerGroupsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                site_id: string;
                /** @description The campaign ID that coupons are to be bound to */
                campaign_id: string;
                /** @description The customer group ID to bind to a campaign */
                customer_group_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ConstraintViolationException` - Indicates some parameter constraint violation occurs */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `CampaignNotFoundException` - Indicates that the campaign with the given campaign id
             *                   is unknown.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDCampaignsByIDCustomerGroupsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                site_id: string;
                /** @description The campaign ID that coupons are to be unbound from */
                campaign_id: string;
                /** @description The customer group ID to unbind from a campaign */
                customer_group_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ConstraintViolationException` - Indicates some parameter constraint violation occurs */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `CampaignNotFoundException` - Indicates that the campaign with the given campaign id
             *                   is unknown.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDCampaignsByIDPromotionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the site that contains the campaign and promotion. */
                site_id: string;
                /** @description The ID of the campaign to which the promotion is to be assigned. */
                campaign_id: string;
                /** @description The ID of the promotion that is to be assigned to the campaign. */
                promotion_id: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["promotion_campaign_assignment"];
                "text/xml": components["schemas"]["promotion_campaign_assignment"];
                "application/xml": components["schemas"]["promotion_campaign_assignment"];
            };
        };
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CampaignNotFoundException` - Indicates that the campaign with the given campaign ID is not found. or `PromotionNotFoundException` - Indicates that the promotion with the given promotion ID is not found. or `SiteNotFoundException` - thrown when site with the given site id is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDCampaignsByIDPromotionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the site that contains the campaign and promotion. */
                site_id: string;
                /** @description The ID of the campaign to which the promotion is to be assigned. */
                campaign_id: string;
                /** @description The ID of the promotion that is to be assigned to the campaign. */
                promotion_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CampaignNotFoundException` - Indicates that the campaign with the given campaign ID is not found. or `PromotionNotFoundException` - Indicates that the campaign with the given promotion ID is not found. or `SiteNotFoundException` - thrown when site with the given site id is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDCampaignsByIDPromotionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the campaign. */
                campaign_id: string;
                /** @description The ID of the site. */
                site_id: string;
                /** @description The ID of the promotion. */
                promotion_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["promotion_campaign_assignment"];
                "text/xml": components["schemas"]["promotion_campaign_assignment"];
                "application/xml": components["schemas"]["promotion_campaign_assignment"];
            };
        };
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `CampaignNotFoundException` - Indicates that the campaign with the given campaign ID is not found. or `CouponNotFoundException` - Indicates that the coupon with the given coupon ID is not found. or `CustomerGroupNotFoundException` - Indicates that the customer group with the given customer group ID is not
             *                  found. or `PromotionNotFoundException` - Indicates that the promotion with the given promotion ID is not found. or `SiteNotFoundException` - thrown when site with the given site id is not found. or `SourceCodeGroupNotFoundException` - Indicates that the source code group with the given source code group ID
             *                  is not found.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDCampaignsByIDSlotConfigurationsByIDByID: {
        parameters: {
            query?: {
                /**
                 * @description The context string, which consists of three parts: the context type (which must be folder,
                 *                 category or global), an equals sign (=), and the context id (either the category id or folder id). If
                 *                 you do not set this query parameter, the global context is used by default.
                 */
                context?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the campaign. */
                campaign_id: string;
                /** @description The ID of the site. */
                site_id: string;
                /** @description The ID of the slot. */
                slot_id: string;
                /** @description The ID of the slot configuration. */
                slot_config_id: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["slot_configuration_campaign_assignment"];
                "text/xml": components["schemas"]["slot_configuration_campaign_assignment"];
                "application/xml": components["schemas"]["slot_configuration_campaign_assignment"];
            };
        };
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `IdConflictException` - Indicates the ID in the URL does not match the ID in the request or `InvalidContextTypeException` - Indicates the slot context type is not one of "global", "category", or
             *                  "folder"
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `CampaignNotFoundException` - Indicates that the campaign with the given campaign ID is not found. or `SiteNotFoundException` - thrown when site with the given site id is not found. or `SlotConfigurationIdentifierNotFoundException` - Indicates that the slot with the given slot ID, slot
             *                  configuration ID and context type is not found. or `SlotWithContextTypeNotFoundException` - Indicates that the slot with the given slot ID and context type is
             *                  not found.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDCampaignsByIDSlotConfigurationsByIDByID: {
        parameters: {
            query?: {
                /**
                 * @description The context string, which consists of three parts: the context type (which must be folder,
                 *                 category or global), an equals sign (=), and the context id (either the category id or folder id).
                 */
                context?: string;
            };
            header?: never;
            path: {
                /** @description The id of the campaign */
                campaign_id: string;
                /** @description The id of the site */
                site_id: string;
                /** @description The of the slot */
                slot_id: string;
                /** @description The id of the slot configuration */
                slot_config_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `InvalidContextTypeException` - Indicates the slot context type is not one of "global", "category", or
             *                  "folder"
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `CampaignNotFoundException` - Indicates that the campaign with the given campaign ID is not found. or `SiteNotFoundException` - thrown when site with the given site id is not found. or `SlotConfigurationIdentifierNotFoundException` - Indicates that the slot with the given slot ID, slot
             *                  configuration ID and context type is not found. or `SlotWithContextTypeNotFoundException` - Indicates that the slot with the given slot ID and context type is
             *                  not found.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDCampaignsByIDSlotConfigurationsByIDByID: {
        parameters: {
            query?: {
                /**
                 * @description The context string, which consists of three parts: the context type (which must be folder,
                 *                 category or global), an equals sign (=), and the context id (either the category id or folder id). If
                 *                 you do not set this query parameter, the global context is used by default.
                 */
                context?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the campaign. */
                campaign_id: string;
                /** @description The ID of the site. */
                site_id: string;
                /** @description The ID of the slot. */
                slot_id: string;
                /** @description The ID of the slot configuration. */
                slot_config_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["slot_configuration_campaign_assignment"];
                "text/xml": components["schemas"]["slot_configuration_campaign_assignment"];
                "application/xml": components["schemas"]["slot_configuration_campaign_assignment"];
            };
        };
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `InvalidContextTypeException` - Indicates the slot context type is not one of "global", "category", or
             *                  "folder"
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `CampaignNotFoundException` - Indicates that the campaign with the given campaign ID is not found. or `SiteNotFoundException` - thrown when site with the given site id is not found. or `SlotConfigurationIdentifierNotFoundException` - Indicates that the slot with the given slot ID, slot
             *                  configuration ID and context type is not found. or `SlotWithContextTypeNotFoundException` - Indicates that the slot with the given slot ID and context type is
             *                  not found.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDCampaignsByIDSortingRulesByIDByID: {
        parameters: {
            query?: {
                /** @description The context in which the rule lives, either "site" or "global" */
                rule_context?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the site that contains the campaign, sorting rule and category. */
                site_id: string;
                /** @description The ID of the campaign to which the sorting rule is to be assigned. */
                campaign_id: string;
                /** @description The ID of sorting rule that is to be assigned to the campaign. */
                sorting_rule_id: string;
                /** @description The ID of the category that is associated with the sorting rule. */
                category_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `InvalidCategoryException` - Indicates that the category with the given category ID is not found. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CampaignNotFoundException` - Indicates that the campaign with the given campaign ID is not found. or `SiteNotFoundException` - thrown when site with the given site id is not found. or `SortingRuleNotFoundException` - Indicates that the sorting rule with the given sorting rule ID is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `SortingRuleCampaignAssignConflictException` - Indicates that there is a sorting rule already assigned to the
             *                  given campaign ID and category ID. The sorting rule with the given sorting rule ID cannot be assigned
             *                  to the same campaign ID and category ID.
             */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDCampaignsByIDSortingRulesByIDByID: {
        parameters: {
            query?: {
                /** @description The context in which the rule lives, either "site" or "global" */
                rule_context?: string;
            };
            header?: never;
            path: {
                /** @description The ID of the site that contains the campaign, sorting rule and category. */
                site_id: string;
                /** @description The ID of the campaign to which the sorting rule is to be assigned. */
                campaign_id: string;
                /** @description The ID of sorting rule that is to be assigned to the campaign. */
                sorting_rule_id: string;
                /** @description The ID of the category that is associated with the sorting rule. */
                category_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `InvalidCategoryException` - Indicates that the category with the given category ID is not found. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CampaignNotFoundException` - Indicates that the campaign with the given campaign ID is not found. or `SiteNotFoundException` - thrown when site with the given site id is not found. or `SortingRuleNotFoundException` - Indicates that the sorting rule with the given sorting rule ID is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDCampaignsByIDSourceCodeGroupsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                site_id: string;
                /** @description The campaign ID that source code group are to be bound to */
                campaign_id: string;
                /** @description The source code group ID to bind to a campaign */
                source_code_group_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ConstraintViolationException` - Indicates some parameter constraint violation occurs */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `CampaignNotFoundException` - Indicates that the campaign with the given campaign id
             *                   is unknown.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDCampaignsByIDSourceCodeGroupsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                site_id: string;
                /** @description The campaign ID that source code groups are to be unbound from */
                campaign_id: string;
                /** @description The source code group ID to unbind from a campaign */
                source_code_group_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ConstraintViolationException` - Indicates some parameter constraint violation occurs */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `CampaignNotFoundException` - Indicates that the campaign with the given campaign id
             *                   is unknown.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDCartridges: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["cartridge_path_create_request"];
                "text/xml": components["schemas"]["cartridge_path_create_request"];
                "application/xml": components["schemas"]["cartridge_path_create_request"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["cartridge_path_api_response"];
                    "text/xml": components["schemas"]["cartridge_path_api_response"];
                    "application/xml": components["schemas"]["cartridge_path_api_response"];
                };
            };
            /** @description `InvalidCartridgePathException` - Indicates that the cartridge path is invalid */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `SiteNotFoundException` - Indicates that site specified with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDCartridges: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["cartridge_path_add_request"];
                "text/xml": components["schemas"]["cartridge_path_add_request"];
                "application/xml": components["schemas"]["cartridge_path_add_request"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["cartridge_path_api_response"];
                    "text/xml": components["schemas"]["cartridge_path_api_response"];
                    "application/xml": components["schemas"]["cartridge_path_api_response"];
                };
            };
            /** @description `CartridgeAlreadyExistException` - Indicates that the cartridge already exist in cartridge path or `InvalidCartridgeException` - Indicates that the cartridge name is invalid or `InvalidOperationException` - The error may happen when position is either 'after' or 'before'. It indicates either target cartridge is not a existing custom cartridge. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `SiteNotFoundException` - Indicates that site specified with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDCartridgesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site. */
                site_id: string;
                /** @description request body */
                cartridge_name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["cartridge_path_api_response"];
                    "text/xml": components["schemas"]["cartridge_path_api_response"];
                    "application/xml": components["schemas"]["cartridge_path_api_response"];
                };
            };
            /** @description `InvalidOperationException` - It indicates either the cartridge doesn't exist in cartridge path or the cartridge can not be deleted (e.g. System Cartridge). */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `SiteNotFoundException` - Indicates that site specified with the given id is unknown. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDCouponRedemptionSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["coupon_redemption_search_result"];
                    "text/xml": components["schemas"]["coupon_redemption_search_result"];
                    "application/xml": components["schemas"]["coupon_redemption_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDCouponSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["coupon_search_result"];
                    "text/xml": components["schemas"]["coupon_search_result"];
                    "application/xml": components["schemas"]["coupon_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDCoupons: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the codes from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the codes (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["coupons"];
                    "text/xml": components["schemas"]["coupons"];
                    "application/xml": components["schemas"]["coupons"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDCouponsByID: {
        parameters: {
            query?: {
                /** @description The property selector. */
                select?: string;
                /** @description The expand parameter. A comma separated list with the allowed values ( <i> stats </i> ). */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the requested coupon. */
                coupon_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["coupon"];
                    "text/xml": components["schemas"]["coupon"];
                    "application/xml": components["schemas"]["coupon"];
                };
            };
            /** @description `CouponNotFoundException` - Thrown in case the coupon does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDCouponsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the coupon to create. */
                coupon_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["coupon"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["coupon"];
                    "text/xml": components["schemas"]["coupon"];
                    "application/xml": components["schemas"]["coupon"];
                };
            };
            /**
             * @description `CouponCodeDuplicateException` - Thrown if the code provided is in use by another coupon. or `CouponCreateSingleCodeException` - Thrown if a single code coupon does not set the coupon code properly. or `CouponInvalidException` - Thrown if the coupon passed in is not valid (the argument indicates
             *                   the field that was invalid). or `IdConflictException` - if the Id in request is not the same as the ID in document. or `SystemGeneratedCouponQuotaException` - Thrown whenever a quota regarding system-generated coupons is violated
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `SiteAccessForbiddenException` - Thrown if the resource requires global instead of site-specific context. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDCouponsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description Id of the coupon to delete from the site. */
                coupon_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDCouponsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the requested coupon. */
                coupon_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["coupon"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["coupon"];
                    "text/xml": components["schemas"]["coupon"];
                    "application/xml": components["schemas"]["coupon"];
                };
            };
            /**
             * @description `CouponCodeDuplicateException` - Thrown if the code provided is in use by another coupon. or `CouponUpdateReadOnlyException` - Thrown if you try to update certain fields in a coupon after
             *                   redeeming or exporting it. or `SystemGeneratedCouponQuotaException` - Thrown whenever a quota regarding system-generated coupons is violated
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CouponLegacyUpdateForbiddenException` - Thrown when trying to update a legacy coupon. or `CouponUpdateForbiddenException` - Thrown when trying to update a broken coupon, that should be deleted and re-created. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CouponNotFoundException` - Thrown if the coupon does not exist matching the given id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDCouponsByIDCampaigns: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the campaigns (default 0). */
                start?: number;
                /** @description Optional count for retrieving the campaigns (default is 25). */
                count?: number;
                select?: string;
            };
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the coupon that is assigned to campaigns directly or through promotions. */
                coupon_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["campaigns"];
                    "text/xml": components["schemas"]["campaigns"];
                    "application/xml": components["schemas"]["campaigns"];
                };
            };
            /** @description `CouponNotFoundException` - Thrown if the coupon does not exist matching the given id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDCouponsByIDCampaignsByIDPromotions: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the promotions (default 0). */
                start?: number;
                /** @description Optional count for retrieving the promotions (default is 25). */
                count?: number;
                select?: string;
            };
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the coupon that is assigned to promotions directly or through campaigns. */
                coupon_id: string;
                /** @description The id of the campaign that we want to restrict the set of promotions for. */
                campaign_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["promotions"];
                    "text/xml": components["schemas"]["promotions"];
                    "application/xml": components["schemas"]["promotions"];
                };
            };
            /** @description `CampaignNotFoundException` - Thrown if the campaign does not exist matching the given id. or `CouponNotFoundException` - Thrown if the coupon does not exist matching the given id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDCouponsByIDCodes: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the codes from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the codes (default is 25). */
                count?: number;
                /** @description Optional select clause for getting fields from the returned JSON document. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the coupon from which to delete codes (must be a multiple code coupon). */
                coupon_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["coupon_codes"];
                    "text/xml": components["schemas"]["coupon_codes"];
                    "application/xml": components["schemas"]["coupon_codes"];
                };
            };
            /** @description `CouponNotFoundException` - Thrown if the coupon does not exist matching the given id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDCouponsByIDMultipleCodes: {
        parameters: {
            query?: {
                /** @description Optional parameter for specifying when to delete multiple codes. */
                delete?: boolean;
            };
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the coupon to modify codes (must be multiple code coupon). */
                coupon_id: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["coupon_multi_codes_request"];
                "text/xml": components["schemas"]["coupon_multi_codes_request"];
                "application/xml": components["schemas"]["coupon_multi_codes_request"];
            };
        };
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CouponCodeCreateException` - Thrown if the coupon code could not be created. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CouponNotFoundException` - Thrown if the coupon does not exist matching the given id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDCouponsByIDPromotions: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the promotions (default 0). */
                start?: number;
                /** @description Optional count for retrieving the promotions (default is 25). */
                count?: number;
                select?: string;
            };
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the coupon that is assigned to promotions directly or through campaigns. */
                coupon_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["promotions"];
                    "text/xml": components["schemas"]["promotions"];
                    "application/xml": components["schemas"]["promotions"];
                };
            };
            /** @description `CouponNotFoundException` - Thrown if the coupon does not exist matching the given id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDCustomObjectsByIDByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the ID of the site */
                site_id: string;
                /** @description the ID of the object type */
                object_type: string;
                /** @description the key attribute value of the Custom Object */
                key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["custom_object"];
                    "text/xml": components["schemas"]["custom_object"];
                    "application/xml": components["schemas"]["custom_object"];
                };
            };
            /** @description `MalformedKeyParameterException` - If the object key must be an integer, but the path parameter has an invalid format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ObjectTypeNotFoundException` - For an unknown object type ID or `CustomObjectNotFoundException` - For an unknown object key */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDCustomObjectsByIDByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the ID of the site */
                site_id: string;
                /** @description the ID of the object type */
                object_type: string;
                /** @description the key attribute value of the Custom Object */
                key: string;
            };
            cookie?: never;
        };
        requestBody?: components["requestBodies"]["custom_object2"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["custom_object"];
                    "text/xml": components["schemas"]["custom_object"];
                    "application/xml": components["schemas"]["custom_object"];
                };
            };
            /** @description `MalformedKeyParameterException` - If the object key must be an integer, but the path parameter has an invalid format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ObjectTypeNotFoundException` - For an unknown object type ID or `CustomObjectNotFoundException` - For an unknown object key */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDCustomObjectsByIDByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the ID of the site */
                site_id: string;
                /** @description the ID of the object type */
                object_type: string;
                /** @description the key attribute value of the Custom Object */
                key: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `MalformedKeyParameterException` - If the object key must be an integer, but the path parameter has an invalid format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ObjectTypeNotFoundException` - For an unknown object type ID */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDCustomObjectsByIDByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the ID of the site */
                site_id: string;
                /** @description the ID of the object type */
                object_type: string;
                /** @description the key attribute value of the Custom Object */
                key: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["custom_object"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["custom_object"];
                    "text/xml": components["schemas"]["custom_object"];
                    "application/xml": components["schemas"]["custom_object"];
                };
            };
            /** @description `MalformedKeyParameterException` - If the object key must be an integer, but the path parameter has an invalid format */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ObjectTypeNotFoundException` - For an unknown object type ID or `CustomObjectNotFoundException` - For an unknown object key */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDCustomerGroupSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer_group_search_result"];
                    "text/xml": components["schemas"]["customer_group_search_result"];
                    "application/xml": components["schemas"]["customer_group_search_result"];
                };
            };
            /** @description `CustomerGroupTypeInvalidException` - Thrown if the search term in term query does not match any of the customer group type. or `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDCustomerGroups: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer_groups"];
                    "text/xml": components["schemas"]["customer_groups"];
                    "application/xml": components["schemas"]["customer_groups"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDCustomerGroupsByID: {
        parameters: {
            query?: {
                /** @description The attribute selector. Include 'member_count' explicitly if member count per customer group is required. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
                /** @description The id of the requested customer group. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer_group"];
                    "text/xml": components["schemas"]["customer_group"];
                    "application/xml": components["schemas"]["customer_group"];
                };
            };
            /** @description `CustomerGroupNotFoundException` - Thrown in case the customer group does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDCustomerGroupsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
                /** @description The id of the customer group to create. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["customer_group"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer_group"];
                    "text/xml": components["schemas"]["customer_group"];
                    "application/xml": components["schemas"]["customer_group"];
                };
            };
            /** @description `CustomerGroupCreateException` - Thrown when there are system error in creating the customer group. or `IdConflictException` - Thrown when id in query parameter is different from the id in the body. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `SystemCustomerGroupCreateForbiddenException` - Thrown when attempting to create the system customer group. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CustomerGroupAlreadyExistsException` - if a customer group exists already in the site with the given identifier. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDCustomerGroupsByID: {
        parameters: {
            query?: {
                /** @description The attribute selector for the customer group which is now in deletion */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
                /** @description One customer group id to remove */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer_group"];
                    "text/xml": components["schemas"]["customer_group"];
                    "application/xml": components["schemas"]["customer_group"];
                };
            };
            /** @description `SystemCustomerGroupDeleteForbiddenException` - Thrown when attempting to delete the system customer group. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDCustomerGroupsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
                /** @description The id of the requested customer group. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["customer_group"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer_group"];
                    "text/xml": components["schemas"]["customer_group"];
                    "application/xml": components["schemas"]["customer_group"];
                };
            };
            /** @description `SystemCustomerGroupUpdateForbiddenException` - Thrown when attempting to update the system customer group. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CustomerGroupNotFoundException` - Thrown in case the customer group does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDCustomerGroupsByIDMemberSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
                /** @description The id of the requested members customer group. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer_group_member_search_result"];
                    "text/xml": components["schemas"]["customer_group_member_search_result"];
                    "application/xml": components["schemas"]["customer_group_member_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CustomerGroupNotFoundException` - Thrown in case the customer group does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDCustomerGroupsByIDMembers: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path: {
                site_id: string;
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer_group_members"];
                    "text/xml": components["schemas"]["customer_group_members"];
                    "application/xml": components["schemas"]["customer_group_members"];
                };
            };
            /** @description `CustomerGroupNotFoundException` - Thrown in case the customer group does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDCustomerGroupsByIDMembersByID: {
        parameters: {
            query?: {
                /** @description The selector for selective response content. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
                /** @description The id of the requested members customer group. */
                id: string;
                /** @description The customer number of the requested customer group member. */
                customer_no: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer_group_member"];
                    "text/xml": components["schemas"]["customer_group_member"];
                    "application/xml": components["schemas"]["customer_group_member"];
                };
            };
            /** @description `CustomerGroupMemberNotFoundException` - Thrown in case the customer group member did not exist, or the group is not a static group or `CustomerGroupNotFoundException` - Thrown in case the customer group does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDCustomerGroupsByIDMembersByID: {
        parameters: {
            query?: {
                /** @description The selector for selective response content. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
                /** @description The id of the customer group. */
                id: string;
                /** @description The customer number of the customer to add to the group. */
                customer_no: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["customer_group_member"];
                    "text/xml": components["schemas"]["customer_group_member"];
                    "application/xml": components["schemas"]["customer_group_member"];
                };
            };
            /** @description `CustomerGroupUnsupportedAssignmentException` - Thrown when the customer group is not a static group. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CustomerGroupNotFoundException` - Thrown in case the customer group does not exist matching the given id. or `CustomerNotFoundException` - Thrown in case the customer list did not exist, or the customer does not exist in in the list. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDCustomerGroupsByIDMembersByID: {
        parameters: {
            query?: {
                /** @description The selector for selective response content. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
                /** @description The id of the customer group. */
                id: string;
                /** @description The customer number of the customer to remove from the group. */
                customer_no: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CustomerGroupUnsupportedAssignmentException` - Thrown when the customer group is not a static group. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CustomerGroupNotFoundException` - Thrown in case the customer group does not exist matching the given id. or `CustomerNotFoundException` - Thrown in case the customer list did not exist, or the customer does not exist in the list. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDGiftCertificateSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["gift_certificate_search_result"];
                    "text/xml": components["schemas"]["gift_certificate_search_result"];
                    "application/xml": components["schemas"]["gift_certificate_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDGiftCertificates: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["gift_certificates"];
                    "text/xml": components["schemas"]["gift_certificates"];
                    "application/xml": components["schemas"]["gift_certificates"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDGiftCertificates: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["gift_certificate"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["gift_certificate"];
                    "text/xml": components["schemas"]["gift_certificate"];
                    "application/xml": components["schemas"]["gift_certificate"];
                };
            };
            /**
             * @description `GiftCertificateAmountOutOfRangeException` - If the amount specified is out of range or `GiftCertificateCreateMerchantIDNotUniqueException` - If merchant id is not unique or `InvalidGiftCertificateException` - if the gift certificate passed in is not valid (the
             *                   argument indicates the field that was invalid). or `InvalidGiftCertificateStatusException` - If gift certificate status specified is invalid or `InvalidRecipientEmailException` - If recipient email address is invalid
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDGiftCertificatesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
                /** @description The merchant id of the requested gift certificate. */
                merchant_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["gift_certificate"];
                    "text/xml": components["schemas"]["gift_certificate"];
                    "application/xml": components["schemas"]["gift_certificate"];
                };
            };
            /** @description `GiftCertificateNotFoundException` - Thrown in case the gift certificate does not exist matching the given merchant id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDGiftCertificatesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
                /** @description One gift certificate merchant id to remove */
                merchant_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDGiftCertificatesByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
                /** @description The merchant id of the requested gift certificate. */
                merchant_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["gift_certificate"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["gift_certificate"];
                    "text/xml": components["schemas"]["gift_certificate"];
                    "application/xml": components["schemas"]["gift_certificate"];
                };
            };
            /** @description `InvalidGiftCertificateStatusException` - If gift certificate status specified is invalid or `InvalidRecipientEmailException` - If recipient email address is invalid */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `GiftCertificateNotFoundException` - Thrown in case the gift certificate does not exist matching the given merchant id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDLocaleInfoLocales: {
        parameters: {
            query?: {
                /** @description true if we want to include all the locales.  Default is false. */
                include_all?: boolean;
                /**
                 * @description optional locale to return by id.  If specified, that locale is looked up and returned, otherwise the
                 *                             list is returned.
                 */
                id?: string;
                /** @description the set of fields to return from the request.  Default is only the locale id. */
                select?: string;
                /** @description the start index for paging.  Default is 0. */
                start?: number;
                /** @description the count of the records to return in this page.  Default is 25. */
                count?: number;
            };
            header?: never;
            path: {
                /** @description Only locales specified for the site are returned */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["locale_result"];
                    "text/xml": components["schemas"]["locale_result"];
                    "application/xml": components["schemas"]["locale_result"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDOrdersByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site */
                site_id: string;
                /** @description The order number */
                order_no: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["order_update_request"];
                "text/xml": components["schemas"]["order_update_request"];
                "application/xml": components["schemas"]["order_update_request"];
            };
        };
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `OrderNotFoundException` - In case of the given order_no does not reference an existing order. or `SiteNotFoundException` - In case of the given site_id does not reference an existing site. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDOrdersByIDConfirmationStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site. */
                site_id: string;
                /** @description The order number */
                order_no: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["order_confirmation_status_update_request"];
                "text/xml": components["schemas"]["order_confirmation_status_update_request"];
                "application/xml": components["schemas"]["order_confirmation_status_update_request"];
            };
        };
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `OrderNotFoundException` - In case of the given order_no does not reference an existing order. or `SiteNotFoundException` - In case of the given site_id does not reference an existing site. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDOrdersByIDExportStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site. */
                site_id: string;
                /** @description The order number */
                order_no: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["order_export_status_update_request"];
                "text/xml": components["schemas"]["order_export_status_update_request"];
                "application/xml": components["schemas"]["order_export_status_update_request"];
            };
        };
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `OrderNotFoundException` - In case of the given order_no does not reference an existing order. or `SiteNotFoundException` - In case of the given site_id does not reference an existing site. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDOrdersByIDExternalStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site. */
                site_id: string;
                /** @description The order number */
                order_no: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["order_external_status_update_request"];
                "text/xml": components["schemas"]["order_external_status_update_request"];
                "application/xml": components["schemas"]["order_external_status_update_request"];
            };
        };
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `OrderNotFoundException` - In case of the given order_no does not reference an existing order. or `SiteNotFoundException` - In case of the given site_id does not reference an existing site. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDOrdersByIDPaymentInstrumentsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site */
                site_id: string;
                /** @description The order number */
                order_no: string;
                /** @description ID of the payment instrument */
                payment_instrument_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["payment_instrument_update_request"];
                "text/xml": components["schemas"]["payment_instrument_update_request"];
                "application/xml": components["schemas"]["payment_instrument_update_request"];
            };
        };
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `OrderNotFoundException` - In case of the given order_no does not reference an existing order. or `PaymentInstrumentNotFoundException` - In case of the given payment_instrument_id does not reference an existing payment instrument. or `SiteNotFoundException` - In case of the given site_id does not reference an existing site. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDOrdersByIDPaymentInstrumentsByIDTransaction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site */
                site_id: string;
                /** @description The order number */
                order_no: string;
                /** @description ID of the payment instrument */
                payment_instrument_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["payment_transaction_update_request"];
                "text/xml": components["schemas"]["payment_transaction_update_request"];
                "application/xml": components["schemas"]["payment_transaction_update_request"];
            };
        };
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `OrderNotFoundException` - In case of the given order_no does not reference an existing order. or `PaymentInstrumentNotFoundException` - In case of the given payment_instrument_id does not reference an existing payment instrument. or `PaymentTransactionNotFoundException` - In case of the payment instrument does not reference a payment transaction. or `SiteNotFoundException` - In case of the given site_id does not reference an existing site. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDOrdersByIDPaymentStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site. */
                site_id: string;
                /** @description The order number */
                order_no: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["order_payment_status_update_request"];
                "text/xml": components["schemas"]["order_payment_status_update_request"];
                "application/xml": components["schemas"]["order_payment_status_update_request"];
            };
        };
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `OrderNotFoundException` - In case of the given order_no does not reference an existing order. or `SiteNotFoundException` - In case of the given site_id does not reference an existing site. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDOrdersByIDShipmentsByIDShippingAddress: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site */
                site_id: string;
                /** @description The order number */
                order_no: string;
                /** @description ID of the shipment */
                shipment_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["shipping_address_update_request"];
                "text/xml": components["schemas"]["shipping_address_update_request"];
                "application/xml": components["schemas"]["shipping_address_update_request"];
            };
        };
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `OrderNotFoundException` - In case of the given order_no does not reference an existing order. or `ShipmentNotFoundException` - In case of the given shipment_id does not reference an existing shipment. or `SiteNotFoundException` - In case of the given site_id does not reference an existing site. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDOrdersByIDShippingStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site. */
                site_id: string;
                /** @description The order number */
                order_no: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["order_shipping_status_update_request"];
                "text/xml": components["schemas"]["order_shipping_status_update_request"];
                "application/xml": components["schemas"]["order_shipping_status_update_request"];
            };
        };
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `OrderNotFoundException` - In case of the given order_no does not reference an existing order. or `SiteNotFoundException` - In case of the given site_id does not reference an existing site. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDOrdersByIDStatus: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description ID of the site */
                site_id: string;
                /** @description The order number */
                order_no: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["order_status_update_request"];
                "text/xml": components["schemas"]["order_status_update_request"];
                "application/xml": components["schemas"]["order_status_update_request"];
            };
        };
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `OrderNotFoundException` - In case of the given order_no does not reference an existing order. or `SiteNotFoundException` - In case of the given site_id does not reference an existing site. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `CancelOrderException` - The order could not be cancelled. or `OrderIntegrationStatusException` - The status change is not supported. An external order management system is integrated which has responsibility for further status changes on placed orders. or `OrderPreviouslyIntegratedStatusException` - The status change is not supported. The order was previously integrated with an external order management system which has responsibility for further status changes. or `OrderStatusTransitionException` - The status change is not supported. or `PlaceOrderException` - The order could not be placed. or `UndoCancelOrderException` - The cancelled order can not be reopened. or `UndoFailOrderException` - The failed order can not be reopened. */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDPromotionCampaignAssignmentSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["promotion_campaign_assignment_search_result"];
                    "text/xml": components["schemas"]["promotion_campaign_assignment_search_result"];
                    "application/xml": components["schemas"]["promotion_campaign_assignment_search_result"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDPromotionSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["promotion_search_result"];
                    "text/xml": components["schemas"]["promotion_search_result"];
                    "application/xml": components["schemas"]["promotion_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDPromotionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the requested promotion. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["promotion"];
                    "text/xml": components["schemas"]["promotion"];
                    "application/xml": components["schemas"]["promotion"];
                };
            };
            /** @description `PromotionNotFoundException` - Thrown in case the promotion does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDPromotionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the promotion to create. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["promotion"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["promotion"];
                    "text/xml": components["schemas"]["promotion"];
                    "application/xml": components["schemas"]["promotion"];
                };
            };
            /** @description `IdConflictException` - if the Id in request is not the same as the ID in document. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDPromotionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description Promotion id to remove */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDPromotionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the requested promotion. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["promotion"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["promotion"];
                    "text/xml": components["schemas"]["promotion"];
                    "application/xml": components["schemas"]["promotion"];
                };
            };
            /** @description `PromotionNotFoundException` - Thrown in case the promotion does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDSitePreferencesPreferenceGroupsByIDByID: {
        parameters: {
            query?: {
                /** @description Set to true to mask the values of preferences of type Password. */
                mask_passwords?: boolean;
            };
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description One of {staging,development,sandbox,production,current}. */
                instance_type: string;
                /** @description The ID of the preference group. */
                group_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["site_preferences"];
                    "text/xml": components["schemas"]["site_preferences"];
                    "application/xml": components["schemas"]["site_preferences"];
                };
            };
            /** @description `CustomPreferenceGroupNotFoundException` - Indicates the preference group is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDSitePreferencesPreferenceGroupsByIDByID: {
        parameters: {
            query?: {
                /** @description Set to true to mask the values of preferences of type Password. */
                mask_passwords?: boolean;
            };
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description One of {staging,development,sandbox,production}. */
                instance_type: string;
                /** @description The ID of the preference group. */
                group_id: string;
            };
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["site_preferences"];
                "text/xml": components["schemas"]["site_preferences"];
                "application/xml": components["schemas"]["site_preferences"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["site_preferences"];
                    "text/xml": components["schemas"]["site_preferences"];
                    "application/xml": components["schemas"]["site_preferences"];
                };
            };
            /** @description `CustomPreferenceGroupNotFoundException` - Indicates the preference group is not found. or `ObjectTypeNotFoundException` - Indicates the SitePreferences system object is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDSlotConfigurationCampaignAssignmentSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["slot_configuration_campaign_assignment_search_result"];
                    "text/xml": components["schemas"]["slot_configuration_campaign_assignment_search_result"];
                    "application/xml": components["schemas"]["slot_configuration_campaign_assignment_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDSlotConfigurationSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["slot_configuration_search_result"];
                    "text/xml": components["schemas"]["slot_configuration_search_result"];
                    "application/xml": components["schemas"]["slot_configuration_search_result"];
                };
            };
            /**
             * @description `TypeMissmatchException` - Indicates that the value to search with does not match the
             *                   type of the search field.
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDSlotConfigurations: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["slot_configurations"];
                    "text/xml": components["schemas"]["slot_configurations"];
                    "application/xml": components["schemas"]["slot_configurations"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDSlotSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["slot_search_result"];
                    "text/xml": components["schemas"]["slot_search_result"];
                    "application/xml": components["schemas"]["slot_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDSlots: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["slots"];
                    "text/xml": components["schemas"]["slots"];
                    "application/xml": components["schemas"]["slots"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDSlotsByIDSlotConfigurationsByID: {
        parameters: {
            query?: {
                /**
                 * @description The context string, which consists of three parts: the context type (which must be
                 *                                <i> folder </i> ,  <i> category </i>  or  <i> global </i> ), an equals sign ( <b> = </b> ),
                 *                               and the context id (either the category id or folder id). If you do not set this
                 *                               query parameter, the global context is used by default.
                 */
                context?: string;
            };
            header?: never;
            path: {
                /** @description The id of the site for which you want to create the slot configuration. */
                site_id: string;
                /** @description The id of the slot. */
                slot_id: string;
                /** @description The id of the slot configuration. */
                configuration_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["slot_configuration"];
                    "text/xml": components["schemas"]["slot_configuration"];
                    "application/xml": components["schemas"]["slot_configuration"];
                };
            };
            /** @description `InvalidContextTypeException` - Thrown if the specified context type is invalid. or `MissingSlotConfigurationContextIdException` - Thrown if the specified context id for given context 'category' or 'folder' is missing. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `SlotConfigurationNotFoundException` - Thrown if there was no slot configuration found for the specified
             *                   configuration id. or `SlotNotFoundException` - Throw if there was no slot with the specified id found for the
             *                   requested site.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDSlotsByIDSlotConfigurationsByID: {
        parameters: {
            query?: {
                /**
                 * @description The context string, which consists of three parts: the context type (which must be
                 *                                <i> folder </i> ,  <i> category </i>  or  <i> global </i> ), an equals sign ( <b> = </b> ),
                 *                               and the context id (either the category id or folder id). If you do not set this
                 *                               query parameter, the global context is used by default.
                 */
                context?: string;
            };
            header?: never;
            path: {
                /** @description The id of the site for which you want to create the slot configuration. */
                site_id: string;
                /** @description The id of the slot. */
                slot_id: string;
                /** @description The id of the slot configuration. */
                configuration_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["slot_configuration"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["slot_configuration"];
                    "text/xml": components["schemas"]["slot_configuration"];
                    "application/xml": components["schemas"]["slot_configuration"];
                };
            };
            /** @description `IdConflictException` - if the Id in request is not the same as the ID in document. or `InvalidContextTypeException` - Thrown if the specified context type is invalid. or `MissingSlotConfigurationContextIdException` - Thrown if the specified context id for given context 'category' or 'folder' is missing. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `ContentNotFoundException` - Thrown if content asset does not exist in the library of the current domain
             *                   but is assigned during creation of the configuration. or `SlotNotFoundException` - Thrown if there was no slot with the given id found for the
             *                   requested site.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDSlotsByIDSlotConfigurationsByID: {
        parameters: {
            query?: {
                /**
                 * @description The context string, which consists of three parts: the context type (which must be
                 *                                <i> folder </i> ,  <i> category </i>  or  <i> global </i> ), an equals sign ( <b> = </b> ),
                 *                               and the context id (either the category id or folder id). If you do not set this
                 *                               query parameter, the global context is used by default.
                 */
                context?: string;
            };
            header?: never;
            path: {
                /** @description The id of the site for which you want to create the slot configuration. */
                site_id: string;
                /** @description The id of the slot. */
                slot_id: string;
                /** @description The id of the slot configuration. */
                configuration_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `InvalidContextTypeException` - Thrown if the specified context type is invalid. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `SlotNotFoundException` - Throw if there was no slot with the specified id found for the
             *                   requested site.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDSlotsByIDSlotConfigurationsByID: {
        parameters: {
            query?: {
                /**
                 * @description The context string, which consists of three parts: the context type (which must be
                 *                                <i> folder </i> ,  <i> category </i>  or  <i> global </i> ), an equals sign ( <b> = </b> ),
                 *                               and the context id (either the category id or folder id). If you do not set this
                 *                               query parameter, the global context is used by default.
                 */
                context?: string;
            };
            header?: never;
            path: {
                /** @description The id of the site for which you want to create the slot configuration. */
                site_id: string;
                /** @description The id of the slot. */
                slot_id: string;
                /** @description The id of the slot configuration. */
                configuration_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["slot_configuration"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["slot_configuration"];
                    "text/xml": components["schemas"]["slot_configuration"];
                    "application/xml": components["schemas"]["slot_configuration"];
                };
            };
            /** @description `InvalidContextTypeException` - Thrown if the specified context type is invalid. or `MissingSlotConfigurationContextIdException` - Thrown if the specified context id for given context 'category' or 'folder' is missing. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `ContentNotFoundException` - Thrown if content asset does not exist in the library of the current domain
             *                   but is assigned during update. or `SlotConfigurationNotFoundException` - Thrown if there was no slot configuration found for the specified configuration
             *                   id. or `SlotNotFoundException` - Thrown if there was no slot with the given id found for the
             *                   requested site.
             */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /**
             * @description `SlotConfigurationAlreadyExistsException` - Thrown if the configuration ID should be updated into one that is already
             *                   assigned.
             */
            409: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDSlotsByIDByID: {
        parameters: {
            query?: {
                /** @description The property selector. If not passed, then the default selector will be used. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the requested slot. */
                slot_id: string;
                /** @description The context type (folder, global, category). */
                context_type: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["slot"];
                    "text/xml": components["schemas"]["slot"];
                    "application/xml": components["schemas"]["slot"];
                };
            };
            /** @description `SlotNotFoundException` - Indicates the slot does not exist matching the given id. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDSortingRuleSearch: {
        parameters: {
            query?: {
                /** @description the optional context in which the sorting rule should be looked up, either "site", "global", or "any" (default) */
                rule_context?: string;
            };
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["sorting_rule_search_result"];
                    "text/xml": components["schemas"]["sorting_rule_search_result"];
                    "application/xml": components["schemas"]["sorting_rule_search_result"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDSourceCodeGroupSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["source_code_group_search_result"];
                    "text/xml": components["schemas"]["source_code_group_search_result"];
                    "application/xml": components["schemas"]["source_code_group_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDSourceCodeGroups: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
                expand?: string[];
            };
            header?: never;
            path: {
                site_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["source_code_groups"];
                    "text/xml": components["schemas"]["source_code_groups"];
                    "application/xml": components["schemas"]["source_code_groups"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDSourceCodeGroupsByID: {
        parameters: {
            query?: {
                /**
                 * @description the query parameter takes an expansion list to include extra information, such as specifications.
                 *      		  usage: expand=specifications.
                 */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
                /** @description The id of the requested source code group. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["source_code_group"];
                    "text/xml": components["schemas"]["source_code_group"];
                    "application/xml": components["schemas"]["source_code_group"];
                };
            };
            /** @description `SourceCodeGroupNotFoundException` - Thrown in case the source code group does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDSourceCodeGroupsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
                /** @description The id of the source code group to create. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["source_code_group"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["source_code_group"];
                    "text/xml": components["schemas"]["source_code_group"];
                    "application/xml": components["schemas"]["source_code_group"];
                };
            };
            /** @description `IdConflictException` - Thrown when the id given in request URL is different from the id provided in the source code group document or `SourceCodeGroupInvalidException` - if the source code group passed in is not valid (the argument indicates the field that was invalid). */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDSourceCodeGroupsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
                /** @description One source code group id to remove */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDSourceCodeGroupsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the site. */
                site_id: string;
                /** @description The id of the requested source code group. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["source_code_group"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["source_code_group"];
                    "text/xml": components["schemas"]["source_code_group"];
                    "application/xml": components["schemas"]["source_code_group"];
                };
            };
            /** @description `SourceCodeGroupNotFoundException` - Thrown in case the source code group does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSitesByIDStoreSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["store_search_result"];
                    "text/xml": components["schemas"]["store_search_result"];
                    "application/xml": components["schemas"]["store_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDStores: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path: {
                site_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["stores"];
                    "text/xml": components["schemas"]["stores"];
                    "application/xml": components["schemas"]["stores"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSitesByIDStoresByID: {
        parameters: {
            query?: {
                /** @description the selector for the get. If not passed, then the defaultSelector will be used instead. */
                select?: string;
            };
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the requested store. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["store"];
                    "text/xml": components["schemas"]["store"];
                    "application/xml": components["schemas"]["store"];
                };
            };
            /** @description `StoreNotFoundException` - Thrown in case the store does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSitesByIDStoresByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the store to create. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["store"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["store"];
                    "text/xml": components["schemas"]["store"];
                    "application/xml": components["schemas"]["store"];
                };
            };
            /** @description `IdConflictException` - if the Id in request is not the same as the ID in document. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSitesByIDStoresByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description One store id to remove */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `StoreNotFoundException` - Thrown in case the store does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSitesByIDStoresByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The site context. */
                site_id: string;
                /** @description The id of the requested store. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["store"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["store"];
                    "text/xml": components["schemas"]["store"];
                    "application/xml": components["schemas"]["store"];
                };
            };
            /** @description `StoreNotFoundException` - Thrown in case the store does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSystemObjectDefinitionSearch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_type_definition_search_result"];
                    "text/xml": components["schemas"]["object_type_definition_search_result"];
                    "application/xml": components["schemas"]["object_type_definition_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSystemObjectDefinitions: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_type_definitions"];
                    "text/xml": components["schemas"]["object_type_definitions"];
                    "application/xml": components["schemas"]["object_type_definitions"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSystemObjectDefinitionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id of the object type for the requested system object. */
                object_type: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_type_definition"];
                    "text/xml": components["schemas"]["object_type_definition"];
                    "application/xml": components["schemas"]["object_type_definition"];
                };
            };
            /** @description `SystemObjectNotFoundException` - Thrown in case the system object does not exist matching the given objectType */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSystemObjectDefinitionsByIDAttributeDefinitionSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The object type id that contains these definitions */
                object_type: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_definition_search_result"];
                    "text/xml": components["schemas"]["object_attribute_definition_search_result"];
                    "application/xml": components["schemas"]["object_attribute_definition_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Indicates the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ObjectTypeNotFoundException` - in case the object type does not match an existing system type */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSystemObjectDefinitionsByIDAttributeDefinitions: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path: {
                object_type: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_definitions"];
                    "text/xml": components["schemas"]["object_attribute_definitions"];
                    "application/xml": components["schemas"]["object_attribute_definitions"];
                };
            };
            /** @description `ObjectTypeNotFoundException` - in case the object type does not match an existing system type */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSystemObjectDefinitionsByIDAttributeDefinitionsByID: {
        parameters: {
            query?: {
                /** @description The selector for the get. If not passed, then the defaultSelector will be used instead. */
                select?: string;
                /** @description The expansion "value" is available to retrieve value definitions of the attribute definition. */
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description The object type id that contains these definitions */
                object_type: string;
                /** @description The id of the requested attribute definition. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_definition"];
                    "text/xml": components["schemas"]["object_attribute_definition"];
                    "application/xml": components["schemas"]["object_attribute_definition"];
                };
            };
            /** @description `AttributeDefinitionNotFoundException` - Thrown in case the attribute definition does not exist matching the given id or `ObjectTypeNotFoundException` - in case the object type does not match an existing system type */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSystemObjectDefinitionsByIDAttributeDefinitionsByID: {
        parameters: {
            query?: never;
            header?: {
                "x-dw-validate-existing"?: boolean;
            };
            path: {
                /** @description The metadata object that contains these definitions */
                object_type: string;
                /** @description The id of the attribute definition to create. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["object_attribute_definition"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_definition"];
                    "text/xml": components["schemas"]["object_attribute_definition"];
                    "application/xml": components["schemas"]["object_attribute_definition"];
                };
            };
            /** @description `AttributeDefinitionCreateException` - if the attribute definition could not be created. or `AttributeDefinitionDuplicateException` - if a attribute definition exists already with the given attribute definition id. or `AttributeDefinitionReadOnlyException` - Thrown when trying to create an internal attribute definition or `IdConflictException` - if the Id in request is not the same as the ID in document. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `ObjectTypeNotFoundException` - Thrown in case the object type cannot be found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSystemObjectDefinitionsByIDAttributeDefinitionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The metadata object that contains these definitions */
                object_type: string;
                /** @description Attribute definition id to remove */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeDefinitionReadOnlyException` - Thrown when trying to delete an internal attribute definition */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeDefinitionNotFoundException` - Thrown in case the attribute definition cannot be found or `ObjectTypeNotFoundException` - Thrown in case the object type cannot be found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSystemObjectDefinitionsByIDAttributeDefinitionsByID: {
        parameters: {
            query?: never;
            header?: {
                /** @description must match the last eTag */
                "If-Match"?: string;
            };
            path: {
                /** @description The object type id that contains these definitions */
                object_type: string;
                /** @description The id of the requested attribute definition. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["object_attribute_definition"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_definition"];
                    "text/xml": components["schemas"]["object_attribute_definition"];
                    "application/xml": components["schemas"]["object_attribute_definition"];
                };
            };
            /**
             * @description `AttributeDefinitionPropertyReadOnlyException` - Thrown in case a read only system attribute it tried to be changed, which is not allowed. or `AttributeDefinitionReadOnlyException` - Thrown when trying to modify a read-only field of an internal
             *         attribute definition
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeDefinitionNotFoundException` - Thrown in case the attribute definition does not exist matching the given id or `ObjectTypeNotFoundException` - Thrown in case the object type cannot be found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postSystemObjectDefinitionsByIDAttributeGroupSearch: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                object_type: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_group_search_result"];
                    "text/xml": components["schemas"]["object_attribute_group_search_result"];
                    "application/xml": components["schemas"]["object_attribute_group_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSystemObjectDefinitionsByIDAttributeGroups: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
                expand?: string[];
            };
            header?: never;
            path: {
                object_type: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_groups"];
                    "text/xml": components["schemas"]["object_attribute_groups"];
                    "application/xml": components["schemas"]["object_attribute_groups"];
                };
            };
            /** @description `ObjectTypeNotFoundException` - in case the object type does not match an existing system type */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSystemObjectDefinitionsByIDAttributeGroupsByIDAttributeDefinitionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the system object that contains the attribute definition and attribute group. */
                object_type: string;
                /** @description The ID of the attribute group. */
                group_id: string;
                /** @description The ID of the attribute definition. */
                def_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeDefinitionNotFoundException` - Indicates the specified attribute definition is not found. or `AttributeGroupNotFoundException` - Indicates the specified attribute group is not found. or `ObjectTypeNotFoundException` - Indicates the specified system object is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSystemObjectDefinitionsByIDAttributeGroupsByIDAttributeDefinitionsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The ID of the system object that contains the attribute definition and attribute group. */
                object_type: string;
                /** @description The ID of the attribute group. */
                group_id: string;
                /** @description The ID of the attribute definition. */
                def_id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeDefinitionNotFoundException` - Indicates the specified attribute definition is not found. or `AttributeGroupNotFoundException` - Indicates the specified attribute group is not found. or `ObjectTypeNotFoundException` - Indicates the specified system object is not found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getSystemObjectDefinitionsByIDAttributeGroupsByID: {
        parameters: {
            query?: {
                select?: string;
                expand?: string[];
            };
            header?: never;
            path: {
                /** @description the object type id that contains this attribute group */
                object_type: string;
                /** @description The id of the requested attribute group. */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_group"];
                    "text/xml": components["schemas"]["object_attribute_group"];
                    "application/xml": components["schemas"]["object_attribute_group"];
                };
            };
            /** @description `AttributeGroupNotFoundException` - Thrown in case the attribute group does not exist matching the given id or `ObjectTypeNotFoundException` - in case the object type does not match an existing system type */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putSystemObjectDefinitionsByIDAttributeGroupsByID: {
        parameters: {
            query?: never;
            header?: {
                /** @description if true, and a attribute group already exists, will throw a AttributeGroupDuplicateException. */
                "x-dw-validate-existing"?: boolean;
            };
            path: {
                /** @description the object type id that contains this attribute group */
                object_type: string;
                /** @description The id of the attribute group to create. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["object_attribute_group"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_group"];
                    "text/xml": components["schemas"]["object_attribute_group"];
                    "application/xml": components["schemas"]["object_attribute_group"];
                };
            };
            /** @description `AttributeGroupDuplicateException` - if a attribute group exists already in the site with the given identifier and the header x-dw-validate-existing=true is passed in with the request. or `AttributeGroupReadOnlyException` - Thrown when trying to create an internal attribute group */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteSystemObjectDefinitionsByIDAttributeGroupsByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description the object type id that contains this attribute group */
                object_type: string;
                /** @description One attribute group id to remove */
                id: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeGroupReadOnlyException` - Thrown when trying to delete an internal attribute group */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeGroupNotFoundException` - Thrown in case the attribute group cannot be found or `ObjectTypeNotFoundException` - Thrown in case the object type cannot be found */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchSystemObjectDefinitionsByIDAttributeGroupsByID: {
        parameters: {
            query?: never;
            header?: {
                /** @description must match the last eTag */
                "If-Match"?: string;
            };
            path: {
                /** @description the object type id that contains this attribute group */
                object_type: string;
                /** @description The id of the requested attribute group. */
                id: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["object_attribute_group"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["object_attribute_group"];
                    "text/xml": components["schemas"]["object_attribute_group"];
                    "application/xml": components["schemas"]["object_attribute_group"];
                };
            };
            /**
             * @description `AttributeGroupReadOnlyException` - Thrown when trying to modify an attribute of a field of an attribute group
             *          that is read only
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AttributeGroupNotFoundException` - Thrown in case the attribute group does not exist matching the given id */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    postUserSearch: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: components["requestBodies"]["search_request"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["user_search_result"];
                    "text/xml": components["schemas"]["user_search_result"];
                    "application/xml": components["schemas"]["user_search_result"];
                };
            };
            /** @description `MalformedSearchParameterException` - Thrown if the query is ill-formed. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getUsers: {
        parameters: {
            query?: {
                /** @description Optional start index for retrieving the items from a given index (default 0). */
                start?: number;
                /** @description Optional count for retrieving only a subset of the items (default is 25). */
                count?: number;
                /** @description The property selector. */
                select?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["users"];
                    "text/xml": components["schemas"]["users"];
                    "application/xml": components["schemas"]["users"];
                };
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getUsersThis: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["user"];
                    "text/xml": components["schemas"]["user"];
                    "application/xml": components["schemas"]["user"];
                };
            };
            /** @description `UserIsLockedException` - If the user profile is currently locked. or `UserNotAvailableException` - If the user provided by the OAuth token cannot be found. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchUsersThisPassword: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["password_change_request"];
                "text/xml": components["schemas"]["password_change_request"];
                "application/xml": components["schemas"]["password_change_request"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["user"];
                    "text/xml": components["schemas"]["user"];
                    "application/xml": components["schemas"]["user"];
                };
            };
            /**
             * @description `InvalidPasswordException` - If the provided current user password is invalid. or `PasswordNotValidForReuseException` - If the same new password was set recently before. or `PasswordPolicyViolationException` - If the new password doesn't meet the acceptance crtiteria of a user
             *                  password.
             */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `UserIsLockedException` - If the user profile is currently locked. or `UserNotAvailableException` - If the user provided by the OAuth token cannot be found. */
            401: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getUsersByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description login of the user */
                login: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["user"];
                    "text/xml": components["schemas"]["user"];
                    "application/xml": components["schemas"]["user"];
                };
            };
            /** @description `UserNotFoundException` - If no user with the specified login could be found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putUsersByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description login of the user */
                login: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["user"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["user"];
                    "text/xml": components["schemas"]["user"];
                    "application/xml": components["schemas"]["user"];
                };
            };
            /** @description `ExternalIdAlreadyExistsException` - If another user with the same external id already exists. or `InvalidCredentialsException` - If password or external id of the user are invalid. or `LocalUserCreationException` - If creation of a local Business Manager user is not allowed with the current server settings. or `PasswordPolicyViolationException` - If the password doesn't meet the acceptance crtiteria of a user password. or `UnknownLocaleException` - If either the Preferred UI Locale or the Preferred Data Locale are unknown. or `IdConflictException` - If the login in the request URL is different from the login in the request body. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `UserOperationNotAllowedException` - If creation or replacement of a user with the given login is not allowed. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteUsersByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description login of the user */
                login: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `UserNotFoundException` - If no user with the specified login could be found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchUsersByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description login of the user */
                login: string;
            };
            cookie?: never;
        };
        requestBody: components["requestBodies"]["user"];
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["user"];
                    "text/xml": components["schemas"]["user"];
                    "application/xml": components["schemas"]["user"];
                };
            };
            /** @description `ExternalIdAlreadyExistsException` - If another user with the same external id already exists. or `ExternalIdNullException` - If the external id is explicitly set to null for an externally managed user or `UnknownLocaleException` - If either the Preferred UI Locale or the Preferred Data Locale are unknown. or `IdConflictException` - If the login in the request URL is different from the login in the request body. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `UserOperationNotAllowedException` - If creation or replacement of a user with the given login is not allowed. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `UserNotFoundException` - If no user with the specified login could be found. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    getUsersByIDAccessKeyByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The login of the user. */
                login: string;
                /** @description The scope of the access key. */
                scope: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["access_key_details"];
                    "text/xml": components["schemas"]["access_key_details"];
                    "application/xml": components["schemas"]["access_key_details"];
                };
            };
            /** @description `UserNotExternallyManagedException` - When the specified user is not externally managed. or `UserAccessForbiddenException` - When the user executing the request is missing the required functional permission 'Manage_Users_Access_Keys'. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AccessKeyNotFoundException` - If the access key does not exist. or `AuthenticationScopeNotFoundException` - If the access scope does not exist. or `UserNotFoundException` - If no user was found for the login. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    putUsersByIDAccessKeyByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The login of the user. */
                login: string;
                /** @description The scope of the access key. */
                scope: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["empty_body"];
                "text/xml": components["schemas"]["empty_body"];
                "application/xml": components["schemas"]["empty_body"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["access_key_details"];
                    "text/xml": components["schemas"]["access_key_details"];
                    "application/xml": components["schemas"]["access_key_details"];
                };
            };
            /** @description `AccessKeyIsExpiredException` - If the acces key is already expired. */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `UserNotExternallyManagedException` - When the specified user is not externally managed. or `UserAccessForbiddenException` - When the user executing the request is missing the required functional permission 'Manage_Users_Access_Keys'. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AuthenticationScopeNotFoundException` - If the access scope does not exist. or `UserNotFoundException` - If no user was found for the login. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    deleteUsersByIDAccessKeyByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The login of the user. */
                login: string;
                /** @description The scope of the access key. */
                scope: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `UserNotExternallyManagedException` - When the specified user is not externally managed. or `UserAccessForbiddenException` - When the user executing the request is missing the required functional permission 'Manage_Users_Access_Keys'. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AccessKeyNotFoundException` - If the access key does not exist. or `AuthenticationScopeNotFoundException` - If the access scope does not exist. or `UserNotFoundException` - If no user was found for the login. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
    patchUsersByIDAccessKeyByID: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The login of the user. */
                login: string;
                /** @description The scope of the access key. */
                scope: string;
            };
            cookie?: never;
        };
        requestBody?: {
            content: {
                "application/json": components["schemas"]["access_key_update_request"];
                "text/xml": components["schemas"]["access_key_update_request"];
                "application/xml": components["schemas"]["access_key_update_request"];
            };
        };
        responses: {
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["access_key_details"];
                    "text/xml": components["schemas"]["access_key_details"];
                    "application/xml": components["schemas"]["access_key_details"];
                };
            };
            /** @description `UserNotExternallyManagedException` - When the specified user is not externally managed. or `UserAccessForbiddenException` - When the user executing the request is missing the required functional permission 'Manage_Users_Access_Keys'. */
            403: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description `AccessKeyNotFoundException` - If the access key does not exist. or `AuthenticationScopeNotFoundException` - If the access scope does not exist. or `UserNotFoundException` - If no user was found for the login. */
            404: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Error response */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["fault"];
                };
            };
        };
    };
}
